// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/python/tpu/tensor_tracer.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fpython_2ftpu_2ftensor_5ftracer_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fpython_2ftpu_2ftensor_5ftracer_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/framework/graph.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fpython_2ftpu_2ftensor_5ftracer_2eproto 

namespace protobuf_tensorflow_2fpython_2ftpu_2ftensor_5ftracer_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fpython_2ftpu_2ftensor_5ftracer_2eproto
namespace tensorflow {
class TensorTracerReport;
class TensorTracerReportDefaultTypeInternal;
extern TensorTracerReportDefaultTypeInternal _TensorTracerReport_default_instance_;
class TensorTracerReport_TensorTracerConfig;
class TensorTracerReport_TensorTracerConfigDefaultTypeInternal;
extern TensorTracerReport_TensorTracerConfigDefaultTypeInternal _TensorTracerReport_TensorTracerConfig_default_instance_;
class TensorTracerReport_TensordefEntry_DoNotUse;
class TensorTracerReport_TensordefEntry_DoNotUseDefaultTypeInternal;
extern TensorTracerReport_TensordefEntry_DoNotUseDefaultTypeInternal _TensorTracerReport_TensordefEntry_DoNotUse_default_instance_;
class TensorTracerReport_TracedTensorDef;
class TensorTracerReport_TracedTensorDefDefaultTypeInternal;
extern TensorTracerReport_TracedTensorDefDefaultTypeInternal _TensorTracerReport_TracedTensorDef_default_instance_;
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::TensorTracerReport* Arena::CreateMaybeMessage<::tensorflow::TensorTracerReport>(Arena*);
template<> ::tensorflow::TensorTracerReport_TensorTracerConfig* Arena::CreateMaybeMessage<::tensorflow::TensorTracerReport_TensorTracerConfig>(Arena*);
template<> ::tensorflow::TensorTracerReport_TensordefEntry_DoNotUse* Arena::CreateMaybeMessage<::tensorflow::TensorTracerReport_TensordefEntry_DoNotUse>(Arena*);
template<> ::tensorflow::TensorTracerReport_TracedTensorDef* Arena::CreateMaybeMessage<::tensorflow::TensorTracerReport_TracedTensorDef>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {

// ===================================================================

class TensorTracerReport_TensordefEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<TensorTracerReport_TensordefEntry_DoNotUse, 
    ::std::string, ::tensorflow::TensorTracerReport_TracedTensorDef,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<TensorTracerReport_TensordefEntry_DoNotUse, 
    ::std::string, ::tensorflow::TensorTracerReport_TracedTensorDef,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  TensorTracerReport_TensordefEntry_DoNotUse();
  TensorTracerReport_TensordefEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const TensorTracerReport_TensordefEntry_DoNotUse& other);
  static const TensorTracerReport_TensordefEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const TensorTracerReport_TensordefEntry_DoNotUse*>(&_TensorTracerReport_TensordefEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class TensorTracerReport_TensorTracerConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TensorTracerReport.TensorTracerConfig) */ {
 public:
  TensorTracerReport_TensorTracerConfig();
  virtual ~TensorTracerReport_TensorTracerConfig();

  TensorTracerReport_TensorTracerConfig(const TensorTracerReport_TensorTracerConfig& from);

  inline TensorTracerReport_TensorTracerConfig& operator=(const TensorTracerReport_TensorTracerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorTracerReport_TensorTracerConfig(TensorTracerReport_TensorTracerConfig&& from) noexcept
    : TensorTracerReport_TensorTracerConfig() {
    *this = ::std::move(from);
  }

  inline TensorTracerReport_TensorTracerConfig& operator=(TensorTracerReport_TensorTracerConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorTracerReport_TensorTracerConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorTracerReport_TensorTracerConfig* internal_default_instance() {
    return reinterpret_cast<const TensorTracerReport_TensorTracerConfig*>(
               &_TensorTracerReport_TensorTracerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(TensorTracerReport_TensorTracerConfig* other);
  friend void swap(TensorTracerReport_TensorTracerConfig& a, TensorTracerReport_TensorTracerConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorTracerReport_TensorTracerConfig* New() const final {
    return CreateMaybeMessage<TensorTracerReport_TensorTracerConfig>(NULL);
  }

  TensorTracerReport_TensorTracerConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TensorTracerReport_TensorTracerConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TensorTracerReport_TensorTracerConfig& from);
  void MergeFrom(const TensorTracerReport_TensorTracerConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorTracerReport_TensorTracerConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 included_cores = 8;
  int included_cores_size() const;
  void clear_included_cores();
  static const int kIncludedCoresFieldNumber = 8;
  ::google::protobuf::int32 included_cores(int index) const;
  void set_included_cores(int index, ::google::protobuf::int32 value);
  void add_included_cores(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      included_cores() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_included_cores();

  // repeated string signatures = 9;
  int signatures_size() const;
  void clear_signatures();
  static const int kSignaturesFieldNumber = 9;
  const ::std::string& signatures(int index) const;
  ::std::string* mutable_signatures(int index);
  void set_signatures(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_signatures(int index, ::std::string&& value);
  #endif
  void set_signatures(int index, const char* value);
  void set_signatures(int index, const char* value, size_t size);
  ::std::string* add_signatures();
  void add_signatures(const ::std::string& value);
  #if LANG_CXX11
  void add_signatures(::std::string&& value);
  #endif
  void add_signatures(const char* value);
  void add_signatures(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& signatures() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_signatures();

  // string version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  const ::std::string& version() const;
  void set_version(const ::std::string& value);
  #if LANG_CXX11
  void set_version(::std::string&& value);
  #endif
  void set_version(const char* value);
  void set_version(const char* value, size_t size);
  ::std::string* mutable_version();
  ::std::string* release_version();
  void set_allocated_version(::std::string* version);

  // string device = 2;
  void clear_device();
  static const int kDeviceFieldNumber = 2;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  #if LANG_CXX11
  void set_device(::std::string&& value);
  #endif
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // string trace_mode = 3;
  void clear_trace_mode();
  static const int kTraceModeFieldNumber = 3;
  const ::std::string& trace_mode() const;
  void set_trace_mode(const ::std::string& value);
  #if LANG_CXX11
  void set_trace_mode(::std::string&& value);
  #endif
  void set_trace_mode(const char* value);
  void set_trace_mode(const char* value, size_t size);
  ::std::string* mutable_trace_mode();
  ::std::string* release_trace_mode();
  void set_allocated_trace_mode(::std::string* trace_mode);

  // string submode = 6;
  void clear_submode();
  static const int kSubmodeFieldNumber = 6;
  const ::std::string& submode() const;
  void set_submode(const ::std::string& value);
  #if LANG_CXX11
  void set_submode(::std::string&& value);
  #endif
  void set_submode(const char* value);
  void set_submode(const char* value, size_t size);
  ::std::string* mutable_submode();
  ::std::string* release_submode();
  void set_allocated_submode(::std::string* submode);

  // int32 num_cores = 4;
  void clear_num_cores();
  static const int kNumCoresFieldNumber = 4;
  ::google::protobuf::int32 num_cores() const;
  void set_num_cores(::google::protobuf::int32 value);

  // int32 num_hosts = 5;
  void clear_num_hosts();
  static const int kNumHostsFieldNumber = 5;
  ::google::protobuf::int32 num_hosts() const;
  void set_num_hosts(::google::protobuf::int32 value);

  // int32 num_cores_per_host = 7;
  void clear_num_cores_per_host();
  static const int kNumCoresPerHostFieldNumber = 7;
  ::google::protobuf::int32 num_cores_per_host() const;
  void set_num_cores_per_host(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.TensorTracerReport.TensorTracerConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > included_cores_;
  mutable int _included_cores_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> signatures_;
  ::google::protobuf::internal::ArenaStringPtr version_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::google::protobuf::internal::ArenaStringPtr trace_mode_;
  ::google::protobuf::internal::ArenaStringPtr submode_;
  ::google::protobuf::int32 num_cores_;
  ::google::protobuf::int32 num_hosts_;
  ::google::protobuf::int32 num_cores_per_host_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fpython_2ftpu_2ftensor_5ftracer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorTracerReport_TracedTensorDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TensorTracerReport.TracedTensorDef) */ {
 public:
  TensorTracerReport_TracedTensorDef();
  virtual ~TensorTracerReport_TracedTensorDef();

  TensorTracerReport_TracedTensorDef(const TensorTracerReport_TracedTensorDef& from);

  inline TensorTracerReport_TracedTensorDef& operator=(const TensorTracerReport_TracedTensorDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorTracerReport_TracedTensorDef(TensorTracerReport_TracedTensorDef&& from) noexcept
    : TensorTracerReport_TracedTensorDef() {
    *this = ::std::move(from);
  }

  inline TensorTracerReport_TracedTensorDef& operator=(TensorTracerReport_TracedTensorDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorTracerReport_TracedTensorDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorTracerReport_TracedTensorDef* internal_default_instance() {
    return reinterpret_cast<const TensorTracerReport_TracedTensorDef*>(
               &_TensorTracerReport_TracedTensorDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TensorTracerReport_TracedTensorDef* other);
  friend void swap(TensorTracerReport_TracedTensorDef& a, TensorTracerReport_TracedTensorDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorTracerReport_TracedTensorDef* New() const final {
    return CreateMaybeMessage<TensorTracerReport_TracedTensorDef>(NULL);
  }

  TensorTracerReport_TracedTensorDef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TensorTracerReport_TracedTensorDef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TensorTracerReport_TracedTensorDef& from);
  void MergeFrom(const TensorTracerReport_TracedTensorDef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorTracerReport_TracedTensorDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string trace_point_name = 3;
  void clear_trace_point_name();
  static const int kTracePointNameFieldNumber = 3;
  const ::std::string& trace_point_name() const;
  void set_trace_point_name(const ::std::string& value);
  #if LANG_CXX11
  void set_trace_point_name(::std::string&& value);
  #endif
  void set_trace_point_name(const char* value);
  void set_trace_point_name(const char* value, size_t size);
  ::std::string* mutable_trace_point_name();
  ::std::string* release_trace_point_name();
  void set_allocated_trace_point_name(::std::string* trace_point_name);

  // string explanation = 5;
  void clear_explanation();
  static const int kExplanationFieldNumber = 5;
  const ::std::string& explanation() const;
  void set_explanation(const ::std::string& value);
  #if LANG_CXX11
  void set_explanation(::std::string&& value);
  #endif
  void set_explanation(const char* value);
  void set_explanation(const char* value, size_t size);
  ::std::string* mutable_explanation();
  ::std::string* release_explanation();
  void set_allocated_explanation(::std::string* explanation);

  // int32 cache_index = 2;
  void clear_cache_index();
  static const int kCacheIndexFieldNumber = 2;
  ::google::protobuf::int32 cache_index() const;
  void set_cache_index(::google::protobuf::int32 value);

  // bool is_traced = 4;
  void clear_is_traced();
  static const int kIsTracedFieldNumber = 4;
  bool is_traced() const;
  void set_is_traced(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.TensorTracerReport.TracedTensorDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr trace_point_name_;
  ::google::protobuf::internal::ArenaStringPtr explanation_;
  ::google::protobuf::int32 cache_index_;
  bool is_traced_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fpython_2ftpu_2ftensor_5ftracer_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TensorTracerReport : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TensorTracerReport) */ {
 public:
  TensorTracerReport();
  virtual ~TensorTracerReport();

  TensorTracerReport(const TensorTracerReport& from);

  inline TensorTracerReport& operator=(const TensorTracerReport& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TensorTracerReport(TensorTracerReport&& from) noexcept
    : TensorTracerReport() {
    *this = ::std::move(from);
  }

  inline TensorTracerReport& operator=(TensorTracerReport&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorTracerReport& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TensorTracerReport* internal_default_instance() {
    return reinterpret_cast<const TensorTracerReport*>(
               &_TensorTracerReport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TensorTracerReport* other);
  friend void swap(TensorTracerReport& a, TensorTracerReport& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TensorTracerReport* New() const final {
    return CreateMaybeMessage<TensorTracerReport>(NULL);
  }

  TensorTracerReport* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TensorTracerReport>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TensorTracerReport& from);
  void MergeFrom(const TensorTracerReport& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TensorTracerReport* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TensorTracerReport_TensorTracerConfig TensorTracerConfig;
  typedef TensorTracerReport_TracedTensorDef TracedTensorDef;

  // accessors -------------------------------------------------------

  // map<string, .tensorflow.TensorTracerReport.TracedTensorDef> tensordef = 3;
  int tensordef_size() const;
  void clear_tensordef();
  static const int kTensordefFieldNumber = 3;
  const ::google::protobuf::Map< ::std::string, ::tensorflow::TensorTracerReport_TracedTensorDef >&
      tensordef() const;
  ::google::protobuf::Map< ::std::string, ::tensorflow::TensorTracerReport_TracedTensorDef >*
      mutable_tensordef();

  // .tensorflow.TensorTracerReport.TensorTracerConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  private:
  const ::tensorflow::TensorTracerReport_TensorTracerConfig& _internal_config() const;
  public:
  const ::tensorflow::TensorTracerReport_TensorTracerConfig& config() const;
  ::tensorflow::TensorTracerReport_TensorTracerConfig* release_config();
  ::tensorflow::TensorTracerReport_TensorTracerConfig* mutable_config();
  void set_allocated_config(::tensorflow::TensorTracerReport_TensorTracerConfig* config);

  // .tensorflow.GraphDef graphdef = 2;
  bool has_graphdef() const;
  void clear_graphdef();
  static const int kGraphdefFieldNumber = 2;
  private:
  const ::tensorflow::GraphDef& _internal_graphdef() const;
  public:
  const ::tensorflow::GraphDef& graphdef() const;
  ::tensorflow::GraphDef* release_graphdef();
  ::tensorflow::GraphDef* mutable_graphdef();
  void set_allocated_graphdef(::tensorflow::GraphDef* graphdef);

  // @@protoc_insertion_point(class_scope:tensorflow.TensorTracerReport)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      TensorTracerReport_TensordefEntry_DoNotUse,
      ::std::string, ::tensorflow::TensorTracerReport_TracedTensorDef,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > tensordef_;
  ::tensorflow::TensorTracerReport_TensorTracerConfig* config_;
  ::tensorflow::GraphDef* graphdef_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fpython_2ftpu_2ftensor_5ftracer_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// TensorTracerReport_TensorTracerConfig

// string version = 1;
inline void TensorTracerReport_TensorTracerConfig::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TensorTracerReport_TensorTracerConfig::version() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TensorTracerConfig.version)
  return version_.GetNoArena();
}
inline void TensorTracerReport_TensorTracerConfig::set_version(const ::std::string& value) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TensorTracerConfig.version)
}
#if LANG_CXX11
inline void TensorTracerReport_TensorTracerConfig::set_version(::std::string&& value) {
  
  version_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorTracerReport.TensorTracerConfig.version)
}
#endif
inline void TensorTracerReport_TensorTracerConfig::set_version(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorTracerReport.TensorTracerConfig.version)
}
inline void TensorTracerReport_TensorTracerConfig::set_version(const char* value, size_t size) {
  
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorTracerReport.TensorTracerConfig.version)
}
inline ::std::string* TensorTracerReport_TensorTracerConfig::mutable_version() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorTracerReport.TensorTracerConfig.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorTracerReport_TensorTracerConfig::release_version() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorTracerReport.TensorTracerConfig.version)
  
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorTracerReport_TensorTracerConfig::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    
  } else {
    
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorTracerReport.TensorTracerConfig.version)
}

// string device = 2;
inline void TensorTracerReport_TensorTracerConfig::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TensorTracerReport_TensorTracerConfig::device() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TensorTracerConfig.device)
  return device_.GetNoArena();
}
inline void TensorTracerReport_TensorTracerConfig::set_device(const ::std::string& value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TensorTracerConfig.device)
}
#if LANG_CXX11
inline void TensorTracerReport_TensorTracerConfig::set_device(::std::string&& value) {
  
  device_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorTracerReport.TensorTracerConfig.device)
}
#endif
inline void TensorTracerReport_TensorTracerConfig::set_device(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorTracerReport.TensorTracerConfig.device)
}
inline void TensorTracerReport_TensorTracerConfig::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorTracerReport.TensorTracerConfig.device)
}
inline ::std::string* TensorTracerReport_TensorTracerConfig::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorTracerReport.TensorTracerConfig.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorTracerReport_TensorTracerConfig::release_device() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorTracerReport.TensorTracerConfig.device)
  
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorTracerReport_TensorTracerConfig::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorTracerReport.TensorTracerConfig.device)
}

// string trace_mode = 3;
inline void TensorTracerReport_TensorTracerConfig::clear_trace_mode() {
  trace_mode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TensorTracerReport_TensorTracerConfig::trace_mode() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TensorTracerConfig.trace_mode)
  return trace_mode_.GetNoArena();
}
inline void TensorTracerReport_TensorTracerConfig::set_trace_mode(const ::std::string& value) {
  
  trace_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TensorTracerConfig.trace_mode)
}
#if LANG_CXX11
inline void TensorTracerReport_TensorTracerConfig::set_trace_mode(::std::string&& value) {
  
  trace_mode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorTracerReport.TensorTracerConfig.trace_mode)
}
#endif
inline void TensorTracerReport_TensorTracerConfig::set_trace_mode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  trace_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorTracerReport.TensorTracerConfig.trace_mode)
}
inline void TensorTracerReport_TensorTracerConfig::set_trace_mode(const char* value, size_t size) {
  
  trace_mode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorTracerReport.TensorTracerConfig.trace_mode)
}
inline ::std::string* TensorTracerReport_TensorTracerConfig::mutable_trace_mode() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorTracerReport.TensorTracerConfig.trace_mode)
  return trace_mode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorTracerReport_TensorTracerConfig::release_trace_mode() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorTracerReport.TensorTracerConfig.trace_mode)
  
  return trace_mode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorTracerReport_TensorTracerConfig::set_allocated_trace_mode(::std::string* trace_mode) {
  if (trace_mode != NULL) {
    
  } else {
    
  }
  trace_mode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_mode);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorTracerReport.TensorTracerConfig.trace_mode)
}

// int32 num_cores = 4;
inline void TensorTracerReport_TensorTracerConfig::clear_num_cores() {
  num_cores_ = 0;
}
inline ::google::protobuf::int32 TensorTracerReport_TensorTracerConfig::num_cores() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TensorTracerConfig.num_cores)
  return num_cores_;
}
inline void TensorTracerReport_TensorTracerConfig::set_num_cores(::google::protobuf::int32 value) {
  
  num_cores_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TensorTracerConfig.num_cores)
}

// int32 num_hosts = 5;
inline void TensorTracerReport_TensorTracerConfig::clear_num_hosts() {
  num_hosts_ = 0;
}
inline ::google::protobuf::int32 TensorTracerReport_TensorTracerConfig::num_hosts() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TensorTracerConfig.num_hosts)
  return num_hosts_;
}
inline void TensorTracerReport_TensorTracerConfig::set_num_hosts(::google::protobuf::int32 value) {
  
  num_hosts_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TensorTracerConfig.num_hosts)
}

// string submode = 6;
inline void TensorTracerReport_TensorTracerConfig::clear_submode() {
  submode_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TensorTracerReport_TensorTracerConfig::submode() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TensorTracerConfig.submode)
  return submode_.GetNoArena();
}
inline void TensorTracerReport_TensorTracerConfig::set_submode(const ::std::string& value) {
  
  submode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TensorTracerConfig.submode)
}
#if LANG_CXX11
inline void TensorTracerReport_TensorTracerConfig::set_submode(::std::string&& value) {
  
  submode_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorTracerReport.TensorTracerConfig.submode)
}
#endif
inline void TensorTracerReport_TensorTracerConfig::set_submode(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  submode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorTracerReport.TensorTracerConfig.submode)
}
inline void TensorTracerReport_TensorTracerConfig::set_submode(const char* value, size_t size) {
  
  submode_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorTracerReport.TensorTracerConfig.submode)
}
inline ::std::string* TensorTracerReport_TensorTracerConfig::mutable_submode() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorTracerReport.TensorTracerConfig.submode)
  return submode_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorTracerReport_TensorTracerConfig::release_submode() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorTracerReport.TensorTracerConfig.submode)
  
  return submode_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorTracerReport_TensorTracerConfig::set_allocated_submode(::std::string* submode) {
  if (submode != NULL) {
    
  } else {
    
  }
  submode_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), submode);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorTracerReport.TensorTracerConfig.submode)
}

// int32 num_cores_per_host = 7;
inline void TensorTracerReport_TensorTracerConfig::clear_num_cores_per_host() {
  num_cores_per_host_ = 0;
}
inline ::google::protobuf::int32 TensorTracerReport_TensorTracerConfig::num_cores_per_host() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TensorTracerConfig.num_cores_per_host)
  return num_cores_per_host_;
}
inline void TensorTracerReport_TensorTracerConfig::set_num_cores_per_host(::google::protobuf::int32 value) {
  
  num_cores_per_host_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TensorTracerConfig.num_cores_per_host)
}

// repeated int32 included_cores = 8;
inline int TensorTracerReport_TensorTracerConfig::included_cores_size() const {
  return included_cores_.size();
}
inline void TensorTracerReport_TensorTracerConfig::clear_included_cores() {
  included_cores_.Clear();
}
inline ::google::protobuf::int32 TensorTracerReport_TensorTracerConfig::included_cores(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TensorTracerConfig.included_cores)
  return included_cores_.Get(index);
}
inline void TensorTracerReport_TensorTracerConfig::set_included_cores(int index, ::google::protobuf::int32 value) {
  included_cores_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TensorTracerConfig.included_cores)
}
inline void TensorTracerReport_TensorTracerConfig::add_included_cores(::google::protobuf::int32 value) {
  included_cores_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorTracerReport.TensorTracerConfig.included_cores)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorTracerReport_TensorTracerConfig::included_cores() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorTracerReport.TensorTracerConfig.included_cores)
  return included_cores_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorTracerReport_TensorTracerConfig::mutable_included_cores() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorTracerReport.TensorTracerConfig.included_cores)
  return &included_cores_;
}

// repeated string signatures = 9;
inline int TensorTracerReport_TensorTracerConfig::signatures_size() const {
  return signatures_.size();
}
inline void TensorTracerReport_TensorTracerConfig::clear_signatures() {
  signatures_.Clear();
}
inline const ::std::string& TensorTracerReport_TensorTracerConfig::signatures(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
  return signatures_.Get(index);
}
inline ::std::string* TensorTracerReport_TensorTracerConfig::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
  return signatures_.Mutable(index);
}
inline void TensorTracerReport_TensorTracerConfig::set_signatures(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
  signatures_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TensorTracerReport_TensorTracerConfig::set_signatures(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
  signatures_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TensorTracerReport_TensorTracerConfig::set_signatures(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
}
inline void TensorTracerReport_TensorTracerConfig::set_signatures(int index, const char* value, size_t size) {
  signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
}
inline ::std::string* TensorTracerReport_TensorTracerConfig::add_signatures() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
  return signatures_.Add();
}
inline void TensorTracerReport_TensorTracerConfig::add_signatures(const ::std::string& value) {
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
}
#if LANG_CXX11
inline void TensorTracerReport_TensorTracerConfig::add_signatures(::std::string&& value) {
  signatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
}
#endif
inline void TensorTracerReport_TensorTracerConfig::add_signatures(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
}
inline void TensorTracerReport_TensorTracerConfig::add_signatures(const char* value, size_t size) {
  signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TensorTracerReport_TensorTracerConfig::signatures() const {
  // @@protoc_insertion_point(field_list:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
  return signatures_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TensorTracerReport_TensorTracerConfig::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TensorTracerReport.TensorTracerConfig.signatures)
  return &signatures_;
}

// -------------------------------------------------------------------

// TensorTracerReport_TracedTensorDef

// string name = 1;
inline void TensorTracerReport_TracedTensorDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TensorTracerReport_TracedTensorDef::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TracedTensorDef.name)
  return name_.GetNoArena();
}
inline void TensorTracerReport_TracedTensorDef::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TracedTensorDef.name)
}
#if LANG_CXX11
inline void TensorTracerReport_TracedTensorDef::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorTracerReport.TracedTensorDef.name)
}
#endif
inline void TensorTracerReport_TracedTensorDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorTracerReport.TracedTensorDef.name)
}
inline void TensorTracerReport_TracedTensorDef::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorTracerReport.TracedTensorDef.name)
}
inline ::std::string* TensorTracerReport_TracedTensorDef::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorTracerReport.TracedTensorDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorTracerReport_TracedTensorDef::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorTracerReport.TracedTensorDef.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorTracerReport_TracedTensorDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorTracerReport.TracedTensorDef.name)
}

// int32 cache_index = 2;
inline void TensorTracerReport_TracedTensorDef::clear_cache_index() {
  cache_index_ = 0;
}
inline ::google::protobuf::int32 TensorTracerReport_TracedTensorDef::cache_index() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TracedTensorDef.cache_index)
  return cache_index_;
}
inline void TensorTracerReport_TracedTensorDef::set_cache_index(::google::protobuf::int32 value) {
  
  cache_index_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TracedTensorDef.cache_index)
}

// string trace_point_name = 3;
inline void TensorTracerReport_TracedTensorDef::clear_trace_point_name() {
  trace_point_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TensorTracerReport_TracedTensorDef::trace_point_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TracedTensorDef.trace_point_name)
  return trace_point_name_.GetNoArena();
}
inline void TensorTracerReport_TracedTensorDef::set_trace_point_name(const ::std::string& value) {
  
  trace_point_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TracedTensorDef.trace_point_name)
}
#if LANG_CXX11
inline void TensorTracerReport_TracedTensorDef::set_trace_point_name(::std::string&& value) {
  
  trace_point_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorTracerReport.TracedTensorDef.trace_point_name)
}
#endif
inline void TensorTracerReport_TracedTensorDef::set_trace_point_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  trace_point_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorTracerReport.TracedTensorDef.trace_point_name)
}
inline void TensorTracerReport_TracedTensorDef::set_trace_point_name(const char* value, size_t size) {
  
  trace_point_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorTracerReport.TracedTensorDef.trace_point_name)
}
inline ::std::string* TensorTracerReport_TracedTensorDef::mutable_trace_point_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorTracerReport.TracedTensorDef.trace_point_name)
  return trace_point_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorTracerReport_TracedTensorDef::release_trace_point_name() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorTracerReport.TracedTensorDef.trace_point_name)
  
  return trace_point_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorTracerReport_TracedTensorDef::set_allocated_trace_point_name(::std::string* trace_point_name) {
  if (trace_point_name != NULL) {
    
  } else {
    
  }
  trace_point_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), trace_point_name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorTracerReport.TracedTensorDef.trace_point_name)
}

// bool is_traced = 4;
inline void TensorTracerReport_TracedTensorDef::clear_is_traced() {
  is_traced_ = false;
}
inline bool TensorTracerReport_TracedTensorDef::is_traced() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TracedTensorDef.is_traced)
  return is_traced_;
}
inline void TensorTracerReport_TracedTensorDef::set_is_traced(bool value) {
  
  is_traced_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TracedTensorDef.is_traced)
}

// string explanation = 5;
inline void TensorTracerReport_TracedTensorDef::clear_explanation() {
  explanation_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TensorTracerReport_TracedTensorDef::explanation() const {
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.TracedTensorDef.explanation)
  return explanation_.GetNoArena();
}
inline void TensorTracerReport_TracedTensorDef::set_explanation(const ::std::string& value) {
  
  explanation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.TensorTracerReport.TracedTensorDef.explanation)
}
#if LANG_CXX11
inline void TensorTracerReport_TracedTensorDef::set_explanation(::std::string&& value) {
  
  explanation_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.TensorTracerReport.TracedTensorDef.explanation)
}
#endif
inline void TensorTracerReport_TracedTensorDef::set_explanation(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  explanation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.TensorTracerReport.TracedTensorDef.explanation)
}
inline void TensorTracerReport_TracedTensorDef::set_explanation(const char* value, size_t size) {
  
  explanation_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.TensorTracerReport.TracedTensorDef.explanation)
}
inline ::std::string* TensorTracerReport_TracedTensorDef::mutable_explanation() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorTracerReport.TracedTensorDef.explanation)
  return explanation_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TensorTracerReport_TracedTensorDef::release_explanation() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorTracerReport.TracedTensorDef.explanation)
  
  return explanation_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TensorTracerReport_TracedTensorDef::set_allocated_explanation(::std::string* explanation) {
  if (explanation != NULL) {
    
  } else {
    
  }
  explanation_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), explanation);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorTracerReport.TracedTensorDef.explanation)
}

// -------------------------------------------------------------------

// TensorTracerReport

// .tensorflow.TensorTracerReport.TensorTracerConfig config = 1;
inline bool TensorTracerReport::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void TensorTracerReport::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) {
    delete config_;
  }
  config_ = NULL;
}
inline const ::tensorflow::TensorTracerReport_TensorTracerConfig& TensorTracerReport::_internal_config() const {
  return *config_;
}
inline const ::tensorflow::TensorTracerReport_TensorTracerConfig& TensorTracerReport::config() const {
  const ::tensorflow::TensorTracerReport_TensorTracerConfig* p = config_;
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.config)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::TensorTracerReport_TensorTracerConfig*>(
      &::tensorflow::_TensorTracerReport_TensorTracerConfig_default_instance_);
}
inline ::tensorflow::TensorTracerReport_TensorTracerConfig* TensorTracerReport::release_config() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorTracerReport.config)
  
  ::tensorflow::TensorTracerReport_TensorTracerConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::tensorflow::TensorTracerReport_TensorTracerConfig* TensorTracerReport::mutable_config() {
  
  if (config_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::TensorTracerReport_TensorTracerConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorTracerReport.config)
  return config_;
}
inline void TensorTracerReport::set_allocated_config(::tensorflow::TensorTracerReport_TensorTracerConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorTracerReport.config)
}

// .tensorflow.GraphDef graphdef = 2;
inline bool TensorTracerReport::has_graphdef() const {
  return this != internal_default_instance() && graphdef_ != NULL;
}
inline const ::tensorflow::GraphDef& TensorTracerReport::_internal_graphdef() const {
  return *graphdef_;
}
inline const ::tensorflow::GraphDef& TensorTracerReport::graphdef() const {
  const ::tensorflow::GraphDef* p = graphdef_;
  // @@protoc_insertion_point(field_get:tensorflow.TensorTracerReport.graphdef)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::GraphDef*>(
      &::tensorflow::_GraphDef_default_instance_);
}
inline ::tensorflow::GraphDef* TensorTracerReport::release_graphdef() {
  // @@protoc_insertion_point(field_release:tensorflow.TensorTracerReport.graphdef)
  
  ::tensorflow::GraphDef* temp = graphdef_;
  graphdef_ = NULL;
  return temp;
}
inline ::tensorflow::GraphDef* TensorTracerReport::mutable_graphdef() {
  
  if (graphdef_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::GraphDef>(GetArenaNoVirtual());
    graphdef_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.TensorTracerReport.graphdef)
  return graphdef_;
}
inline void TensorTracerReport::set_allocated_graphdef(::tensorflow::GraphDef* graphdef) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(graphdef_);
  }
  if (graphdef) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(graphdef)->GetArena();
    if (message_arena != submessage_arena) {
      graphdef = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, graphdef, submessage_arena);
    }
    
  } else {
    
  }
  graphdef_ = graphdef;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.TensorTracerReport.graphdef)
}

// map<string, .tensorflow.TensorTracerReport.TracedTensorDef> tensordef = 3;
inline int TensorTracerReport::tensordef_size() const {
  return tensordef_.size();
}
inline void TensorTracerReport::clear_tensordef() {
  tensordef_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::tensorflow::TensorTracerReport_TracedTensorDef >&
TensorTracerReport::tensordef() const {
  // @@protoc_insertion_point(field_map:tensorflow.TensorTracerReport.tensordef)
  return tensordef_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::tensorflow::TensorTracerReport_TracedTensorDef >*
TensorTracerReport::mutable_tensordef() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.TensorTracerReport.tensordef)
  return tensordef_.MutableMap();
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fpython_2ftpu_2ftensor_5ftracer_2eproto
