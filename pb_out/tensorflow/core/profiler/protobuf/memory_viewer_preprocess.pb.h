// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/profiler/protobuf/memory_viewer_preprocess.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto 

namespace protobuf_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[6];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto
namespace tensorflow {
namespace profiler {
class BufferAllocation;
class BufferAllocationDefaultTypeInternal;
extern BufferAllocationDefaultTypeInternal _BufferAllocation_default_instance_;
class BufferSpan;
class BufferSpanDefaultTypeInternal;
extern BufferSpanDefaultTypeInternal _BufferSpan_default_instance_;
class HeapObject;
class HeapObjectDefaultTypeInternal;
extern HeapObjectDefaultTypeInternal _HeapObject_default_instance_;
class LogicalBuffer;
class LogicalBufferDefaultTypeInternal;
extern LogicalBufferDefaultTypeInternal _LogicalBuffer_default_instance_;
class PreprocessResult;
class PreprocessResultDefaultTypeInternal;
extern PreprocessResultDefaultTypeInternal _PreprocessResult_default_instance_;
class PreprocessResult_LogicalBufferSpansEntry_DoNotUse;
class PreprocessResult_LogicalBufferSpansEntry_DoNotUseDefaultTypeInternal;
extern PreprocessResult_LogicalBufferSpansEntry_DoNotUseDefaultTypeInternal _PreprocessResult_LogicalBufferSpansEntry_DoNotUse_default_instance_;
}  // namespace profiler
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::profiler::BufferAllocation* Arena::CreateMaybeMessage<::tensorflow::profiler::BufferAllocation>(Arena*);
template<> ::tensorflow::profiler::BufferSpan* Arena::CreateMaybeMessage<::tensorflow::profiler::BufferSpan>(Arena*);
template<> ::tensorflow::profiler::HeapObject* Arena::CreateMaybeMessage<::tensorflow::profiler::HeapObject>(Arena*);
template<> ::tensorflow::profiler::LogicalBuffer* Arena::CreateMaybeMessage<::tensorflow::profiler::LogicalBuffer>(Arena*);
template<> ::tensorflow::profiler::PreprocessResult* Arena::CreateMaybeMessage<::tensorflow::profiler::PreprocessResult>(Arena*);
template<> ::tensorflow::profiler::PreprocessResult_LogicalBufferSpansEntry_DoNotUse* Arena::CreateMaybeMessage<::tensorflow::profiler::PreprocessResult_LogicalBufferSpansEntry_DoNotUse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {
namespace profiler {

// ===================================================================

class HeapObject : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.profiler.HeapObject) */ {
 public:
  HeapObject();
  virtual ~HeapObject();

  HeapObject(const HeapObject& from);

  inline HeapObject& operator=(const HeapObject& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeapObject(HeapObject&& from) noexcept
    : HeapObject() {
    *this = ::std::move(from);
  }

  inline HeapObject& operator=(HeapObject&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeapObject& default_instance();

  enum ColorCase {
    kNumbered = 1,
    kNamed = 2,
    COLOR_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeapObject* internal_default_instance() {
    return reinterpret_cast<const HeapObject*>(
               &_HeapObject_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(HeapObject* other);
  friend void swap(HeapObject& a, HeapObject& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeapObject* New() const final {
    return CreateMaybeMessage<HeapObject>(NULL);
  }

  HeapObject* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeapObject>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeapObject& from);
  void MergeFrom(const HeapObject& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeapObject* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string label = 3;
  void clear_label();
  static const int kLabelFieldNumber = 3;
  const ::std::string& label() const;
  void set_label(const ::std::string& value);
  #if LANG_CXX11
  void set_label(::std::string&& value);
  #endif
  void set_label(const char* value);
  void set_label(const char* value, size_t size);
  ::std::string* mutable_label();
  ::std::string* release_label();
  void set_allocated_label(::std::string* label);

  // string instruction_name = 7;
  void clear_instruction_name();
  static const int kInstructionNameFieldNumber = 7;
  const ::std::string& instruction_name() const;
  void set_instruction_name(const ::std::string& value);
  #if LANG_CXX11
  void set_instruction_name(::std::string&& value);
  #endif
  void set_instruction_name(const char* value);
  void set_instruction_name(const char* value, size_t size);
  ::std::string* mutable_instruction_name();
  ::std::string* release_instruction_name();
  void set_allocated_instruction_name(::std::string* instruction_name);

  // string shape_string = 8;
  void clear_shape_string();
  static const int kShapeStringFieldNumber = 8;
  const ::std::string& shape_string() const;
  void set_shape_string(const ::std::string& value);
  #if LANG_CXX11
  void set_shape_string(::std::string&& value);
  #endif
  void set_shape_string(const char* value);
  void set_shape_string(const char* value, size_t size);
  ::std::string* mutable_shape_string();
  ::std::string* release_shape_string();
  void set_allocated_shape_string(::std::string* shape_string);

  // string tf_op_name = 9;
  void clear_tf_op_name();
  static const int kTfOpNameFieldNumber = 9;
  const ::std::string& tf_op_name() const;
  void set_tf_op_name(const ::std::string& value);
  #if LANG_CXX11
  void set_tf_op_name(::std::string&& value);
  #endif
  void set_tf_op_name(const char* value);
  void set_tf_op_name(const char* value, size_t size);
  ::std::string* mutable_tf_op_name();
  ::std::string* release_tf_op_name();
  void set_allocated_tf_op_name(::std::string* tf_op_name);

  // string group_name = 10;
  void clear_group_name();
  static const int kGroupNameFieldNumber = 10;
  const ::std::string& group_name() const;
  void set_group_name(const ::std::string& value);
  #if LANG_CXX11
  void set_group_name(::std::string&& value);
  #endif
  void set_group_name(const char* value);
  void set_group_name(const char* value, size_t size);
  ::std::string* mutable_group_name();
  ::std::string* release_group_name();
  void set_allocated_group_name(::std::string* group_name);

  // string op_code = 11;
  void clear_op_code();
  static const int kOpCodeFieldNumber = 11;
  const ::std::string& op_code() const;
  void set_op_code(const ::std::string& value);
  #if LANG_CXX11
  void set_op_code(::std::string&& value);
  #endif
  void set_op_code(const char* value);
  void set_op_code(const char* value, size_t size);
  ::std::string* mutable_op_code();
  ::std::string* release_op_code();
  void set_allocated_op_code(::std::string* op_code);

  // double logical_buffer_size_mib = 5;
  void clear_logical_buffer_size_mib();
  static const int kLogicalBufferSizeMibFieldNumber = 5;
  double logical_buffer_size_mib() const;
  void set_logical_buffer_size_mib(double value);

  // double unpadded_shape_mib = 6;
  void clear_unpadded_shape_mib();
  static const int kUnpaddedShapeMibFieldNumber = 6;
  double unpadded_shape_mib() const;
  void set_unpadded_shape_mib(double value);

  // int32 logical_buffer_id = 4;
  void clear_logical_buffer_id();
  static const int kLogicalBufferIdFieldNumber = 4;
  ::google::protobuf::int32 logical_buffer_id() const;
  void set_logical_buffer_id(::google::protobuf::int32 value);

  // int32 numbered = 1;
  private:
  bool has_numbered() const;
  public:
  void clear_numbered();
  static const int kNumberedFieldNumber = 1;
  ::google::protobuf::int32 numbered() const;
  void set_numbered(::google::protobuf::int32 value);

  // string named = 2;
  private:
  bool has_named() const;
  public:
  void clear_named();
  static const int kNamedFieldNumber = 2;
  const ::std::string& named() const;
  void set_named(const ::std::string& value);
  #if LANG_CXX11
  void set_named(::std::string&& value);
  #endif
  void set_named(const char* value);
  void set_named(const char* value, size_t size);
  ::std::string* mutable_named();
  ::std::string* release_named();
  void set_allocated_named(::std::string* named);

  void clear_color();
  ColorCase color_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.profiler.HeapObject)
 private:
  void set_has_numbered();
  void set_has_named();

  inline bool has_color() const;
  inline void clear_has_color();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr label_;
  ::google::protobuf::internal::ArenaStringPtr instruction_name_;
  ::google::protobuf::internal::ArenaStringPtr shape_string_;
  ::google::protobuf::internal::ArenaStringPtr tf_op_name_;
  ::google::protobuf::internal::ArenaStringPtr group_name_;
  ::google::protobuf::internal::ArenaStringPtr op_code_;
  double logical_buffer_size_mib_;
  double unpadded_shape_mib_;
  ::google::protobuf::int32 logical_buffer_id_;
  union ColorUnion {
    ColorUnion() {}
    ::google::protobuf::int32 numbered_;
    ::google::protobuf::internal::ArenaStringPtr named_;
  } color_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BufferSpan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.profiler.BufferSpan) */ {
 public:
  BufferSpan();
  virtual ~BufferSpan();

  BufferSpan(const BufferSpan& from);

  inline BufferSpan& operator=(const BufferSpan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BufferSpan(BufferSpan&& from) noexcept
    : BufferSpan() {
    *this = ::std::move(from);
  }

  inline BufferSpan& operator=(BufferSpan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferSpan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BufferSpan* internal_default_instance() {
    return reinterpret_cast<const BufferSpan*>(
               &_BufferSpan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(BufferSpan* other);
  friend void swap(BufferSpan& a, BufferSpan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BufferSpan* New() const final {
    return CreateMaybeMessage<BufferSpan>(NULL);
  }

  BufferSpan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BufferSpan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BufferSpan& from);
  void MergeFrom(const BufferSpan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferSpan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 start = 1;
  void clear_start();
  static const int kStartFieldNumber = 1;
  ::google::protobuf::int32 start() const;
  void set_start(::google::protobuf::int32 value);

  // int32 limit = 2;
  void clear_limit();
  static const int kLimitFieldNumber = 2;
  ::google::protobuf::int32 limit() const;
  void set_limit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.profiler.BufferSpan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 start_;
  ::google::protobuf::int32 limit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LogicalBuffer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.profiler.LogicalBuffer) */ {
 public:
  LogicalBuffer();
  virtual ~LogicalBuffer();

  LogicalBuffer(const LogicalBuffer& from);

  inline LogicalBuffer& operator=(const LogicalBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogicalBuffer(LogicalBuffer&& from) noexcept
    : LogicalBuffer() {
    *this = ::std::move(from);
  }

  inline LogicalBuffer& operator=(LogicalBuffer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogicalBuffer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogicalBuffer* internal_default_instance() {
    return reinterpret_cast<const LogicalBuffer*>(
               &_LogicalBuffer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LogicalBuffer* other);
  friend void swap(LogicalBuffer& a, LogicalBuffer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogicalBuffer* New() const final {
    return CreateMaybeMessage<LogicalBuffer>(NULL);
  }

  LogicalBuffer* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogicalBuffer>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogicalBuffer& from);
  void MergeFrom(const LogicalBuffer& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogicalBuffer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 shape_index = 5;
  int shape_index_size() const;
  void clear_shape_index();
  static const int kShapeIndexFieldNumber = 5;
  ::google::protobuf::int64 shape_index(int index) const;
  void set_shape_index(int index, ::google::protobuf::int64 value);
  void add_shape_index(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      shape_index() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_shape_index();

  // string shape = 2;
  void clear_shape();
  static const int kShapeFieldNumber = 2;
  const ::std::string& shape() const;
  void set_shape(const ::std::string& value);
  #if LANG_CXX11
  void set_shape(::std::string&& value);
  #endif
  void set_shape(const char* value);
  void set_shape(const char* value, size_t size);
  ::std::string* mutable_shape();
  ::std::string* release_shape();
  void set_allocated_shape(::std::string* shape);

  // string hlo_name = 4;
  void clear_hlo_name();
  static const int kHloNameFieldNumber = 4;
  const ::std::string& hlo_name() const;
  void set_hlo_name(const ::std::string& value);
  #if LANG_CXX11
  void set_hlo_name(::std::string&& value);
  #endif
  void set_hlo_name(const char* value);
  void set_hlo_name(const char* value, size_t size);
  ::std::string* mutable_hlo_name();
  ::std::string* release_hlo_name();
  void set_allocated_hlo_name(::std::string* hlo_name);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // double size_mib = 3;
  void clear_size_mib();
  static const int kSizeMibFieldNumber = 3;
  double size_mib() const;
  void set_size_mib(double value);

  // @@protoc_insertion_point(class_scope:tensorflow.profiler.LogicalBuffer)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > shape_index_;
  mutable int _shape_index_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr shape_;
  ::google::protobuf::internal::ArenaStringPtr hlo_name_;
  ::google::protobuf::int64 id_;
  double size_mib_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BufferAllocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.profiler.BufferAllocation) */ {
 public:
  BufferAllocation();
  virtual ~BufferAllocation();

  BufferAllocation(const BufferAllocation& from);

  inline BufferAllocation& operator=(const BufferAllocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BufferAllocation(BufferAllocation&& from) noexcept
    : BufferAllocation() {
    *this = ::std::move(from);
  }

  inline BufferAllocation& operator=(BufferAllocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BufferAllocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BufferAllocation* internal_default_instance() {
    return reinterpret_cast<const BufferAllocation*>(
               &_BufferAllocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(BufferAllocation* other);
  friend void swap(BufferAllocation& a, BufferAllocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BufferAllocation* New() const final {
    return CreateMaybeMessage<BufferAllocation>(NULL);
  }

  BufferAllocation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BufferAllocation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BufferAllocation& from);
  void MergeFrom(const BufferAllocation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BufferAllocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string attributes = 3;
  int attributes_size() const;
  void clear_attributes();
  static const int kAttributesFieldNumber = 3;
  const ::std::string& attributes(int index) const;
  ::std::string* mutable_attributes(int index);
  void set_attributes(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_attributes(int index, ::std::string&& value);
  #endif
  void set_attributes(int index, const char* value);
  void set_attributes(int index, const char* value, size_t size);
  ::std::string* add_attributes();
  void add_attributes(const ::std::string& value);
  #if LANG_CXX11
  void add_attributes(::std::string&& value);
  #endif
  void add_attributes(const char* value);
  void add_attributes(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& attributes() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_attributes();

  // repeated .tensorflow.profiler.LogicalBuffer logical_buffers = 4;
  int logical_buffers_size() const;
  void clear_logical_buffers();
  static const int kLogicalBuffersFieldNumber = 4;
  ::tensorflow::profiler::LogicalBuffer* mutable_logical_buffers(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::LogicalBuffer >*
      mutable_logical_buffers();
  const ::tensorflow::profiler::LogicalBuffer& logical_buffers(int index) const;
  ::tensorflow::profiler::LogicalBuffer* add_logical_buffers();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::LogicalBuffer >&
      logical_buffers() const;

  // string common_shape = 5;
  void clear_common_shape();
  static const int kCommonShapeFieldNumber = 5;
  const ::std::string& common_shape() const;
  void set_common_shape(const ::std::string& value);
  #if LANG_CXX11
  void set_common_shape(::std::string&& value);
  #endif
  void set_common_shape(const char* value);
  void set_common_shape(const char* value, size_t size);
  ::std::string* mutable_common_shape();
  ::std::string* release_common_shape();
  void set_allocated_common_shape(::std::string* common_shape);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // double size_mib = 2;
  void clear_size_mib();
  static const int kSizeMibFieldNumber = 2;
  double size_mib() const;
  void set_size_mib(double value);

  // @@protoc_insertion_point(class_scope:tensorflow.profiler.BufferAllocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> attributes_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::LogicalBuffer > logical_buffers_;
  ::google::protobuf::internal::ArenaStringPtr common_shape_;
  ::google::protobuf::int64 id_;
  double size_mib_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PreprocessResult_LogicalBufferSpansEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<PreprocessResult_LogicalBufferSpansEntry_DoNotUse, 
    ::google::protobuf::int32, ::tensorflow::profiler::BufferSpan,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<PreprocessResult_LogicalBufferSpansEntry_DoNotUse, 
    ::google::protobuf::int32, ::tensorflow::profiler::BufferSpan,
    ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
    ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
    0 > SuperType;
  PreprocessResult_LogicalBufferSpansEntry_DoNotUse();
  PreprocessResult_LogicalBufferSpansEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const PreprocessResult_LogicalBufferSpansEntry_DoNotUse& other);
  static const PreprocessResult_LogicalBufferSpansEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const PreprocessResult_LogicalBufferSpansEntry_DoNotUse*>(&_PreprocessResult_LogicalBufferSpansEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class PreprocessResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.profiler.PreprocessResult) */ {
 public:
  PreprocessResult();
  virtual ~PreprocessResult();

  PreprocessResult(const PreprocessResult& from);

  inline PreprocessResult& operator=(const PreprocessResult& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PreprocessResult(PreprocessResult&& from) noexcept
    : PreprocessResult() {
    *this = ::std::move(from);
  }

  inline PreprocessResult& operator=(PreprocessResult&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PreprocessResult& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PreprocessResult* internal_default_instance() {
    return reinterpret_cast<const PreprocessResult*>(
               &_PreprocessResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(PreprocessResult* other);
  friend void swap(PreprocessResult& a, PreprocessResult& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PreprocessResult* New() const final {
    return CreateMaybeMessage<PreprocessResult>(NULL);
  }

  PreprocessResult* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PreprocessResult>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PreprocessResult& from);
  void MergeFrom(const PreprocessResult& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PreprocessResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // repeated double heap_sizes = 1;
  int heap_sizes_size() const;
  void clear_heap_sizes();
  static const int kHeapSizesFieldNumber = 1;
  double heap_sizes(int index) const;
  void set_heap_sizes(int index, double value);
  void add_heap_sizes(double value);
  const ::google::protobuf::RepeatedField< double >&
      heap_sizes() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_heap_sizes();

  // repeated double unpadded_heap_sizes = 2;
  int unpadded_heap_sizes_size() const;
  void clear_unpadded_heap_sizes();
  static const int kUnpaddedHeapSizesFieldNumber = 2;
  double unpadded_heap_sizes(int index) const;
  void set_unpadded_heap_sizes(int index, double value);
  void add_unpadded_heap_sizes(double value);
  const ::google::protobuf::RepeatedField< double >&
      unpadded_heap_sizes() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_unpadded_heap_sizes();

  // repeated .tensorflow.profiler.HeapObject max_heap = 3;
  int max_heap_size() const;
  void clear_max_heap();
  static const int kMaxHeapFieldNumber = 3;
  ::tensorflow::profiler::HeapObject* mutable_max_heap(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::HeapObject >*
      mutable_max_heap();
  const ::tensorflow::profiler::HeapObject& max_heap(int index) const;
  ::tensorflow::profiler::HeapObject* add_max_heap();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::HeapObject >&
      max_heap() const;

  // repeated .tensorflow.profiler.HeapObject max_heap_by_size = 4;
  int max_heap_by_size_size() const;
  void clear_max_heap_by_size();
  static const int kMaxHeapBySizeFieldNumber = 4;
  ::tensorflow::profiler::HeapObject* mutable_max_heap_by_size(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::HeapObject >*
      mutable_max_heap_by_size();
  const ::tensorflow::profiler::HeapObject& max_heap_by_size(int index) const;
  ::tensorflow::profiler::HeapObject* add_max_heap_by_size();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::HeapObject >&
      max_heap_by_size() const;

  // map<int32, .tensorflow.profiler.BufferSpan> logical_buffer_spans = 5;
  int logical_buffer_spans_size() const;
  void clear_logical_buffer_spans();
  static const int kLogicalBufferSpansFieldNumber = 5;
  const ::google::protobuf::Map< ::google::protobuf::int32, ::tensorflow::profiler::BufferSpan >&
      logical_buffer_spans() const;
  ::google::protobuf::Map< ::google::protobuf::int32, ::tensorflow::profiler::BufferSpan >*
      mutable_logical_buffer_spans();

  // repeated int32 max_heap_to_by_size = 6;
  int max_heap_to_by_size_size() const;
  void clear_max_heap_to_by_size();
  static const int kMaxHeapToBySizeFieldNumber = 6;
  ::google::protobuf::int32 max_heap_to_by_size(int index) const;
  void set_max_heap_to_by_size(int index, ::google::protobuf::int32 value);
  void add_max_heap_to_by_size(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      max_heap_to_by_size() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_max_heap_to_by_size();

  // repeated int32 by_size_to_max_heap = 7;
  int by_size_to_max_heap_size() const;
  void clear_by_size_to_max_heap();
  static const int kBySizeToMaxHeapFieldNumber = 7;
  ::google::protobuf::int32 by_size_to_max_heap(int index) const;
  void set_by_size_to_max_heap(int index, ::google::protobuf::int32 value);
  void add_by_size_to_max_heap(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      by_size_to_max_heap() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_by_size_to_max_heap();

  // repeated .tensorflow.profiler.BufferAllocation indefinite_lifetimes = 16;
  int indefinite_lifetimes_size() const;
  void clear_indefinite_lifetimes();
  static const int kIndefiniteLifetimesFieldNumber = 16;
  ::tensorflow::profiler::BufferAllocation* mutable_indefinite_lifetimes(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::BufferAllocation >*
      mutable_indefinite_lifetimes();
  const ::tensorflow::profiler::BufferAllocation& indefinite_lifetimes(int index) const;
  ::tensorflow::profiler::BufferAllocation* add_indefinite_lifetimes();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::BufferAllocation >&
      indefinite_lifetimes() const;

  // string module_name = 8;
  void clear_module_name();
  static const int kModuleNameFieldNumber = 8;
  const ::std::string& module_name() const;
  void set_module_name(const ::std::string& value);
  #if LANG_CXX11
  void set_module_name(::std::string&& value);
  #endif
  void set_module_name(const char* value);
  void set_module_name(const char* value, size_t size);
  ::std::string* mutable_module_name();
  ::std::string* release_module_name();
  void set_allocated_module_name(::std::string* module_name);

  // string entry_computation_name = 9;
  void clear_entry_computation_name();
  static const int kEntryComputationNameFieldNumber = 9;
  const ::std::string& entry_computation_name() const;
  void set_entry_computation_name(const ::std::string& value);
  #if LANG_CXX11
  void set_entry_computation_name(::std::string&& value);
  #endif
  void set_entry_computation_name(const char* value);
  void set_entry_computation_name(const char* value, size_t size);
  ::std::string* mutable_entry_computation_name();
  ::std::string* release_entry_computation_name();
  void set_allocated_entry_computation_name(::std::string* entry_computation_name);

  // double peak_heap_mib = 10;
  void clear_peak_heap_mib();
  static const int kPeakHeapMibFieldNumber = 10;
  double peak_heap_mib() const;
  void set_peak_heap_mib(double value);

  // double peak_unpadded_heap_mib = 11;
  void clear_peak_unpadded_heap_mib();
  static const int kPeakUnpaddedHeapMibFieldNumber = 11;
  double peak_unpadded_heap_mib() const;
  void set_peak_unpadded_heap_mib(double value);

  // double entry_computation_parameters_mib = 13;
  void clear_entry_computation_parameters_mib();
  static const int kEntryComputationParametersMibFieldNumber = 13;
  double entry_computation_parameters_mib() const;
  void set_entry_computation_parameters_mib(double value);

  // double non_reusable_mib = 14;
  void clear_non_reusable_mib();
  static const int kNonReusableMibFieldNumber = 14;
  double non_reusable_mib() const;
  void set_non_reusable_mib(double value);

  // double maybe_live_out_mib = 15;
  void clear_maybe_live_out_mib();
  static const int kMaybeLiveOutMibFieldNumber = 15;
  double maybe_live_out_mib() const;
  void set_maybe_live_out_mib(double value);

  // int32 peak_heap_size_position = 12;
  void clear_peak_heap_size_position();
  static const int kPeakHeapSizePositionFieldNumber = 12;
  ::google::protobuf::int32 peak_heap_size_position() const;
  void set_peak_heap_size_position(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.profiler.PreprocessResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< double > heap_sizes_;
  mutable int _heap_sizes_cached_byte_size_;
  ::google::protobuf::RepeatedField< double > unpadded_heap_sizes_;
  mutable int _unpadded_heap_sizes_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::HeapObject > max_heap_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::HeapObject > max_heap_by_size_;
  ::google::protobuf::internal::MapField<
      PreprocessResult_LogicalBufferSpansEntry_DoNotUse,
      ::google::protobuf::int32, ::tensorflow::profiler::BufferSpan,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      ::google::protobuf::internal::WireFormatLite::TYPE_MESSAGE,
      0 > logical_buffer_spans_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > max_heap_to_by_size_;
  mutable int _max_heap_to_by_size_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > by_size_to_max_heap_;
  mutable int _by_size_to_max_heap_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::BufferAllocation > indefinite_lifetimes_;
  ::google::protobuf::internal::ArenaStringPtr module_name_;
  ::google::protobuf::internal::ArenaStringPtr entry_computation_name_;
  double peak_heap_mib_;
  double peak_unpadded_heap_mib_;
  double entry_computation_parameters_mib_;
  double non_reusable_mib_;
  double maybe_live_out_mib_;
  ::google::protobuf::int32 peak_heap_size_position_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// HeapObject

// int32 numbered = 1;
inline bool HeapObject::has_numbered() const {
  return color_case() == kNumbered;
}
inline void HeapObject::set_has_numbered() {
  _oneof_case_[0] = kNumbered;
}
inline void HeapObject::clear_numbered() {
  if (has_numbered()) {
    color_.numbered_ = 0;
    clear_has_color();
  }
}
inline ::google::protobuf::int32 HeapObject::numbered() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.numbered)
  if (has_numbered()) {
    return color_.numbered_;
  }
  return 0;
}
inline void HeapObject::set_numbered(::google::protobuf::int32 value) {
  if (!has_numbered()) {
    clear_color();
    set_has_numbered();
  }
  color_.numbered_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.numbered)
}

// string named = 2;
inline bool HeapObject::has_named() const {
  return color_case() == kNamed;
}
inline void HeapObject::set_has_named() {
  _oneof_case_[0] = kNamed;
}
inline void HeapObject::clear_named() {
  if (has_named()) {
    color_.named_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_color();
  }
}
inline const ::std::string& HeapObject::named() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.named)
  if (has_named()) {
    return color_.named_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void HeapObject::set_named(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.named)
  if (!has_named()) {
    clear_color();
    set_has_named();
    color_.named_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  color_.named_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.named)
}
#if LANG_CXX11
inline void HeapObject::set_named(::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.named)
  if (!has_named()) {
    clear_color();
    set_has_named();
    color_.named_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  color_.named_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.HeapObject.named)
}
#endif
inline void HeapObject::set_named(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_named()) {
    clear_color();
    set_has_named();
    color_.named_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  color_.named_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.HeapObject.named)
}
inline void HeapObject::set_named(const char* value, size_t size) {
  if (!has_named()) {
    clear_color();
    set_has_named();
    color_.named_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  color_.named_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.HeapObject.named)
}
inline ::std::string* HeapObject::mutable_named() {
  if (!has_named()) {
    clear_color();
    set_has_named();
    color_.named_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.HeapObject.named)
  return color_.named_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeapObject::release_named() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.HeapObject.named)
  if (has_named()) {
    clear_has_color();
    return color_.named_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void HeapObject::set_allocated_named(::std::string* named) {
  if (!has_named()) {
    color_.named_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_color();
  if (named != NULL) {
    set_has_named();
    color_.named_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), named);
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.HeapObject.named)
}

// string label = 3;
inline void HeapObject::clear_label() {
  label_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeapObject::label() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.label)
  return label_.GetNoArena();
}
inline void HeapObject::set_label(const ::std::string& value) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.label)
}
#if LANG_CXX11
inline void HeapObject::set_label(::std::string&& value) {
  
  label_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.HeapObject.label)
}
#endif
inline void HeapObject::set_label(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.HeapObject.label)
}
inline void HeapObject::set_label(const char* value, size_t size) {
  
  label_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.HeapObject.label)
}
inline ::std::string* HeapObject::mutable_label() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.HeapObject.label)
  return label_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeapObject::release_label() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.HeapObject.label)
  
  return label_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeapObject::set_allocated_label(::std::string* label) {
  if (label != NULL) {
    
  } else {
    
  }
  label_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), label);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.HeapObject.label)
}

// int32 logical_buffer_id = 4;
inline void HeapObject::clear_logical_buffer_id() {
  logical_buffer_id_ = 0;
}
inline ::google::protobuf::int32 HeapObject::logical_buffer_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.logical_buffer_id)
  return logical_buffer_id_;
}
inline void HeapObject::set_logical_buffer_id(::google::protobuf::int32 value) {
  
  logical_buffer_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.logical_buffer_id)
}

// double logical_buffer_size_mib = 5;
inline void HeapObject::clear_logical_buffer_size_mib() {
  logical_buffer_size_mib_ = 0;
}
inline double HeapObject::logical_buffer_size_mib() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.logical_buffer_size_mib)
  return logical_buffer_size_mib_;
}
inline void HeapObject::set_logical_buffer_size_mib(double value) {
  
  logical_buffer_size_mib_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.logical_buffer_size_mib)
}

// double unpadded_shape_mib = 6;
inline void HeapObject::clear_unpadded_shape_mib() {
  unpadded_shape_mib_ = 0;
}
inline double HeapObject::unpadded_shape_mib() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.unpadded_shape_mib)
  return unpadded_shape_mib_;
}
inline void HeapObject::set_unpadded_shape_mib(double value) {
  
  unpadded_shape_mib_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.unpadded_shape_mib)
}

// string instruction_name = 7;
inline void HeapObject::clear_instruction_name() {
  instruction_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeapObject::instruction_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.instruction_name)
  return instruction_name_.GetNoArena();
}
inline void HeapObject::set_instruction_name(const ::std::string& value) {
  
  instruction_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.instruction_name)
}
#if LANG_CXX11
inline void HeapObject::set_instruction_name(::std::string&& value) {
  
  instruction_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.HeapObject.instruction_name)
}
#endif
inline void HeapObject::set_instruction_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  instruction_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.HeapObject.instruction_name)
}
inline void HeapObject::set_instruction_name(const char* value, size_t size) {
  
  instruction_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.HeapObject.instruction_name)
}
inline ::std::string* HeapObject::mutable_instruction_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.HeapObject.instruction_name)
  return instruction_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeapObject::release_instruction_name() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.HeapObject.instruction_name)
  
  return instruction_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeapObject::set_allocated_instruction_name(::std::string* instruction_name) {
  if (instruction_name != NULL) {
    
  } else {
    
  }
  instruction_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), instruction_name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.HeapObject.instruction_name)
}

// string shape_string = 8;
inline void HeapObject::clear_shape_string() {
  shape_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeapObject::shape_string() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.shape_string)
  return shape_string_.GetNoArena();
}
inline void HeapObject::set_shape_string(const ::std::string& value) {
  
  shape_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.shape_string)
}
#if LANG_CXX11
inline void HeapObject::set_shape_string(::std::string&& value) {
  
  shape_string_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.HeapObject.shape_string)
}
#endif
inline void HeapObject::set_shape_string(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  shape_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.HeapObject.shape_string)
}
inline void HeapObject::set_shape_string(const char* value, size_t size) {
  
  shape_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.HeapObject.shape_string)
}
inline ::std::string* HeapObject::mutable_shape_string() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.HeapObject.shape_string)
  return shape_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeapObject::release_shape_string() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.HeapObject.shape_string)
  
  return shape_string_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeapObject::set_allocated_shape_string(::std::string* shape_string) {
  if (shape_string != NULL) {
    
  } else {
    
  }
  shape_string_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shape_string);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.HeapObject.shape_string)
}

// string tf_op_name = 9;
inline void HeapObject::clear_tf_op_name() {
  tf_op_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeapObject::tf_op_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.tf_op_name)
  return tf_op_name_.GetNoArena();
}
inline void HeapObject::set_tf_op_name(const ::std::string& value) {
  
  tf_op_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.tf_op_name)
}
#if LANG_CXX11
inline void HeapObject::set_tf_op_name(::std::string&& value) {
  
  tf_op_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.HeapObject.tf_op_name)
}
#endif
inline void HeapObject::set_tf_op_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  tf_op_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.HeapObject.tf_op_name)
}
inline void HeapObject::set_tf_op_name(const char* value, size_t size) {
  
  tf_op_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.HeapObject.tf_op_name)
}
inline ::std::string* HeapObject::mutable_tf_op_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.HeapObject.tf_op_name)
  return tf_op_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeapObject::release_tf_op_name() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.HeapObject.tf_op_name)
  
  return tf_op_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeapObject::set_allocated_tf_op_name(::std::string* tf_op_name) {
  if (tf_op_name != NULL) {
    
  } else {
    
  }
  tf_op_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), tf_op_name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.HeapObject.tf_op_name)
}

// string group_name = 10;
inline void HeapObject::clear_group_name() {
  group_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeapObject::group_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.group_name)
  return group_name_.GetNoArena();
}
inline void HeapObject::set_group_name(const ::std::string& value) {
  
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.group_name)
}
#if LANG_CXX11
inline void HeapObject::set_group_name(::std::string&& value) {
  
  group_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.HeapObject.group_name)
}
#endif
inline void HeapObject::set_group_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.HeapObject.group_name)
}
inline void HeapObject::set_group_name(const char* value, size_t size) {
  
  group_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.HeapObject.group_name)
}
inline ::std::string* HeapObject::mutable_group_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.HeapObject.group_name)
  return group_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeapObject::release_group_name() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.HeapObject.group_name)
  
  return group_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeapObject::set_allocated_group_name(::std::string* group_name) {
  if (group_name != NULL) {
    
  } else {
    
  }
  group_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), group_name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.HeapObject.group_name)
}

// string op_code = 11;
inline void HeapObject::clear_op_code() {
  op_code_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeapObject::op_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.HeapObject.op_code)
  return op_code_.GetNoArena();
}
inline void HeapObject::set_op_code(const ::std::string& value) {
  
  op_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.HeapObject.op_code)
}
#if LANG_CXX11
inline void HeapObject::set_op_code(::std::string&& value) {
  
  op_code_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.HeapObject.op_code)
}
#endif
inline void HeapObject::set_op_code(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  op_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.HeapObject.op_code)
}
inline void HeapObject::set_op_code(const char* value, size_t size) {
  
  op_code_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.HeapObject.op_code)
}
inline ::std::string* HeapObject::mutable_op_code() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.HeapObject.op_code)
  return op_code_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeapObject::release_op_code() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.HeapObject.op_code)
  
  return op_code_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeapObject::set_allocated_op_code(::std::string* op_code) {
  if (op_code != NULL) {
    
  } else {
    
  }
  op_code_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), op_code);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.HeapObject.op_code)
}

inline bool HeapObject::has_color() const {
  return color_case() != COLOR_NOT_SET;
}
inline void HeapObject::clear_has_color() {
  _oneof_case_[0] = COLOR_NOT_SET;
}
inline HeapObject::ColorCase HeapObject::color_case() const {
  return HeapObject::ColorCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// BufferSpan

// int32 start = 1;
inline void BufferSpan::clear_start() {
  start_ = 0;
}
inline ::google::protobuf::int32 BufferSpan::start() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.BufferSpan.start)
  return start_;
}
inline void BufferSpan::set_start(::google::protobuf::int32 value) {
  
  start_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.BufferSpan.start)
}

// int32 limit = 2;
inline void BufferSpan::clear_limit() {
  limit_ = 0;
}
inline ::google::protobuf::int32 BufferSpan::limit() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.BufferSpan.limit)
  return limit_;
}
inline void BufferSpan::set_limit(::google::protobuf::int32 value) {
  
  limit_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.BufferSpan.limit)
}

// -------------------------------------------------------------------

// LogicalBuffer

// int64 id = 1;
inline void LogicalBuffer::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LogicalBuffer::id() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.LogicalBuffer.id)
  return id_;
}
inline void LogicalBuffer::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.LogicalBuffer.id)
}

// string shape = 2;
inline void LogicalBuffer::clear_shape() {
  shape_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogicalBuffer::shape() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.LogicalBuffer.shape)
  return shape_.GetNoArena();
}
inline void LogicalBuffer::set_shape(const ::std::string& value) {
  
  shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.LogicalBuffer.shape)
}
#if LANG_CXX11
inline void LogicalBuffer::set_shape(::std::string&& value) {
  
  shape_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.LogicalBuffer.shape)
}
#endif
inline void LogicalBuffer::set_shape(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.LogicalBuffer.shape)
}
inline void LogicalBuffer::set_shape(const char* value, size_t size) {
  
  shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.LogicalBuffer.shape)
}
inline ::std::string* LogicalBuffer::mutable_shape() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.LogicalBuffer.shape)
  return shape_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogicalBuffer::release_shape() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.LogicalBuffer.shape)
  
  return shape_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogicalBuffer::set_allocated_shape(::std::string* shape) {
  if (shape != NULL) {
    
  } else {
    
  }
  shape_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), shape);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.LogicalBuffer.shape)
}

// double size_mib = 3;
inline void LogicalBuffer::clear_size_mib() {
  size_mib_ = 0;
}
inline double LogicalBuffer::size_mib() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.LogicalBuffer.size_mib)
  return size_mib_;
}
inline void LogicalBuffer::set_size_mib(double value) {
  
  size_mib_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.LogicalBuffer.size_mib)
}

// string hlo_name = 4;
inline void LogicalBuffer::clear_hlo_name() {
  hlo_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogicalBuffer::hlo_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.LogicalBuffer.hlo_name)
  return hlo_name_.GetNoArena();
}
inline void LogicalBuffer::set_hlo_name(const ::std::string& value) {
  
  hlo_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.LogicalBuffer.hlo_name)
}
#if LANG_CXX11
inline void LogicalBuffer::set_hlo_name(::std::string&& value) {
  
  hlo_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.LogicalBuffer.hlo_name)
}
#endif
inline void LogicalBuffer::set_hlo_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  hlo_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.LogicalBuffer.hlo_name)
}
inline void LogicalBuffer::set_hlo_name(const char* value, size_t size) {
  
  hlo_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.LogicalBuffer.hlo_name)
}
inline ::std::string* LogicalBuffer::mutable_hlo_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.LogicalBuffer.hlo_name)
  return hlo_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogicalBuffer::release_hlo_name() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.LogicalBuffer.hlo_name)
  
  return hlo_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogicalBuffer::set_allocated_hlo_name(::std::string* hlo_name) {
  if (hlo_name != NULL) {
    
  } else {
    
  }
  hlo_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hlo_name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.LogicalBuffer.hlo_name)
}

// repeated int64 shape_index = 5;
inline int LogicalBuffer::shape_index_size() const {
  return shape_index_.size();
}
inline void LogicalBuffer::clear_shape_index() {
  shape_index_.Clear();
}
inline ::google::protobuf::int64 LogicalBuffer::shape_index(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.LogicalBuffer.shape_index)
  return shape_index_.Get(index);
}
inline void LogicalBuffer::set_shape_index(int index, ::google::protobuf::int64 value) {
  shape_index_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.LogicalBuffer.shape_index)
}
inline void LogicalBuffer::add_shape_index(::google::protobuf::int64 value) {
  shape_index_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.profiler.LogicalBuffer.shape_index)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
LogicalBuffer::shape_index() const {
  // @@protoc_insertion_point(field_list:tensorflow.profiler.LogicalBuffer.shape_index)
  return shape_index_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
LogicalBuffer::mutable_shape_index() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.profiler.LogicalBuffer.shape_index)
  return &shape_index_;
}

// -------------------------------------------------------------------

// BufferAllocation

// int64 id = 1;
inline void BufferAllocation::clear_id() {
  id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BufferAllocation::id() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.BufferAllocation.id)
  return id_;
}
inline void BufferAllocation::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.BufferAllocation.id)
}

// double size_mib = 2;
inline void BufferAllocation::clear_size_mib() {
  size_mib_ = 0;
}
inline double BufferAllocation::size_mib() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.BufferAllocation.size_mib)
  return size_mib_;
}
inline void BufferAllocation::set_size_mib(double value) {
  
  size_mib_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.BufferAllocation.size_mib)
}

// repeated string attributes = 3;
inline int BufferAllocation::attributes_size() const {
  return attributes_.size();
}
inline void BufferAllocation::clear_attributes() {
  attributes_.Clear();
}
inline const ::std::string& BufferAllocation::attributes(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.BufferAllocation.attributes)
  return attributes_.Get(index);
}
inline ::std::string* BufferAllocation::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.BufferAllocation.attributes)
  return attributes_.Mutable(index);
}
inline void BufferAllocation::set_attributes(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.profiler.BufferAllocation.attributes)
  attributes_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void BufferAllocation::set_attributes(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.profiler.BufferAllocation.attributes)
  attributes_.Mutable(index)->assign(std::move(value));
}
#endif
inline void BufferAllocation::set_attributes(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  attributes_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.BufferAllocation.attributes)
}
inline void BufferAllocation::set_attributes(int index, const char* value, size_t size) {
  attributes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.BufferAllocation.attributes)
}
inline ::std::string* BufferAllocation::add_attributes() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.profiler.BufferAllocation.attributes)
  return attributes_.Add();
}
inline void BufferAllocation::add_attributes(const ::std::string& value) {
  attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.profiler.BufferAllocation.attributes)
}
#if LANG_CXX11
inline void BufferAllocation::add_attributes(::std::string&& value) {
  attributes_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.profiler.BufferAllocation.attributes)
}
#endif
inline void BufferAllocation::add_attributes(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  attributes_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.profiler.BufferAllocation.attributes)
}
inline void BufferAllocation::add_attributes(const char* value, size_t size) {
  attributes_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.profiler.BufferAllocation.attributes)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BufferAllocation::attributes() const {
  // @@protoc_insertion_point(field_list:tensorflow.profiler.BufferAllocation.attributes)
  return attributes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BufferAllocation::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.profiler.BufferAllocation.attributes)
  return &attributes_;
}

// repeated .tensorflow.profiler.LogicalBuffer logical_buffers = 4;
inline int BufferAllocation::logical_buffers_size() const {
  return logical_buffers_.size();
}
inline void BufferAllocation::clear_logical_buffers() {
  logical_buffers_.Clear();
}
inline ::tensorflow::profiler::LogicalBuffer* BufferAllocation::mutable_logical_buffers(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.BufferAllocation.logical_buffers)
  return logical_buffers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::LogicalBuffer >*
BufferAllocation::mutable_logical_buffers() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.profiler.BufferAllocation.logical_buffers)
  return &logical_buffers_;
}
inline const ::tensorflow::profiler::LogicalBuffer& BufferAllocation::logical_buffers(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.BufferAllocation.logical_buffers)
  return logical_buffers_.Get(index);
}
inline ::tensorflow::profiler::LogicalBuffer* BufferAllocation::add_logical_buffers() {
  // @@protoc_insertion_point(field_add:tensorflow.profiler.BufferAllocation.logical_buffers)
  return logical_buffers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::LogicalBuffer >&
BufferAllocation::logical_buffers() const {
  // @@protoc_insertion_point(field_list:tensorflow.profiler.BufferAllocation.logical_buffers)
  return logical_buffers_;
}

// string common_shape = 5;
inline void BufferAllocation::clear_common_shape() {
  common_shape_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BufferAllocation::common_shape() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.BufferAllocation.common_shape)
  return common_shape_.GetNoArena();
}
inline void BufferAllocation::set_common_shape(const ::std::string& value) {
  
  common_shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.BufferAllocation.common_shape)
}
#if LANG_CXX11
inline void BufferAllocation::set_common_shape(::std::string&& value) {
  
  common_shape_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.BufferAllocation.common_shape)
}
#endif
inline void BufferAllocation::set_common_shape(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  common_shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.BufferAllocation.common_shape)
}
inline void BufferAllocation::set_common_shape(const char* value, size_t size) {
  
  common_shape_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.BufferAllocation.common_shape)
}
inline ::std::string* BufferAllocation::mutable_common_shape() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.BufferAllocation.common_shape)
  return common_shape_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BufferAllocation::release_common_shape() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.BufferAllocation.common_shape)
  
  return common_shape_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BufferAllocation::set_allocated_common_shape(::std::string* common_shape) {
  if (common_shape != NULL) {
    
  } else {
    
  }
  common_shape_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), common_shape);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.BufferAllocation.common_shape)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// PreprocessResult

// repeated double heap_sizes = 1;
inline int PreprocessResult::heap_sizes_size() const {
  return heap_sizes_.size();
}
inline void PreprocessResult::clear_heap_sizes() {
  heap_sizes_.Clear();
}
inline double PreprocessResult::heap_sizes(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.heap_sizes)
  return heap_sizes_.Get(index);
}
inline void PreprocessResult::set_heap_sizes(int index, double value) {
  heap_sizes_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.heap_sizes)
}
inline void PreprocessResult::add_heap_sizes(double value) {
  heap_sizes_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.profiler.PreprocessResult.heap_sizes)
}
inline const ::google::protobuf::RepeatedField< double >&
PreprocessResult::heap_sizes() const {
  // @@protoc_insertion_point(field_list:tensorflow.profiler.PreprocessResult.heap_sizes)
  return heap_sizes_;
}
inline ::google::protobuf::RepeatedField< double >*
PreprocessResult::mutable_heap_sizes() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.profiler.PreprocessResult.heap_sizes)
  return &heap_sizes_;
}

// repeated double unpadded_heap_sizes = 2;
inline int PreprocessResult::unpadded_heap_sizes_size() const {
  return unpadded_heap_sizes_.size();
}
inline void PreprocessResult::clear_unpadded_heap_sizes() {
  unpadded_heap_sizes_.Clear();
}
inline double PreprocessResult::unpadded_heap_sizes(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.unpadded_heap_sizes)
  return unpadded_heap_sizes_.Get(index);
}
inline void PreprocessResult::set_unpadded_heap_sizes(int index, double value) {
  unpadded_heap_sizes_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.unpadded_heap_sizes)
}
inline void PreprocessResult::add_unpadded_heap_sizes(double value) {
  unpadded_heap_sizes_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.profiler.PreprocessResult.unpadded_heap_sizes)
}
inline const ::google::protobuf::RepeatedField< double >&
PreprocessResult::unpadded_heap_sizes() const {
  // @@protoc_insertion_point(field_list:tensorflow.profiler.PreprocessResult.unpadded_heap_sizes)
  return unpadded_heap_sizes_;
}
inline ::google::protobuf::RepeatedField< double >*
PreprocessResult::mutable_unpadded_heap_sizes() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.profiler.PreprocessResult.unpadded_heap_sizes)
  return &unpadded_heap_sizes_;
}

// repeated .tensorflow.profiler.HeapObject max_heap = 3;
inline int PreprocessResult::max_heap_size() const {
  return max_heap_.size();
}
inline void PreprocessResult::clear_max_heap() {
  max_heap_.Clear();
}
inline ::tensorflow::profiler::HeapObject* PreprocessResult::mutable_max_heap(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.PreprocessResult.max_heap)
  return max_heap_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::HeapObject >*
PreprocessResult::mutable_max_heap() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.profiler.PreprocessResult.max_heap)
  return &max_heap_;
}
inline const ::tensorflow::profiler::HeapObject& PreprocessResult::max_heap(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.max_heap)
  return max_heap_.Get(index);
}
inline ::tensorflow::profiler::HeapObject* PreprocessResult::add_max_heap() {
  // @@protoc_insertion_point(field_add:tensorflow.profiler.PreprocessResult.max_heap)
  return max_heap_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::HeapObject >&
PreprocessResult::max_heap() const {
  // @@protoc_insertion_point(field_list:tensorflow.profiler.PreprocessResult.max_heap)
  return max_heap_;
}

// repeated .tensorflow.profiler.HeapObject max_heap_by_size = 4;
inline int PreprocessResult::max_heap_by_size_size() const {
  return max_heap_by_size_.size();
}
inline void PreprocessResult::clear_max_heap_by_size() {
  max_heap_by_size_.Clear();
}
inline ::tensorflow::profiler::HeapObject* PreprocessResult::mutable_max_heap_by_size(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.PreprocessResult.max_heap_by_size)
  return max_heap_by_size_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::HeapObject >*
PreprocessResult::mutable_max_heap_by_size() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.profiler.PreprocessResult.max_heap_by_size)
  return &max_heap_by_size_;
}
inline const ::tensorflow::profiler::HeapObject& PreprocessResult::max_heap_by_size(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.max_heap_by_size)
  return max_heap_by_size_.Get(index);
}
inline ::tensorflow::profiler::HeapObject* PreprocessResult::add_max_heap_by_size() {
  // @@protoc_insertion_point(field_add:tensorflow.profiler.PreprocessResult.max_heap_by_size)
  return max_heap_by_size_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::HeapObject >&
PreprocessResult::max_heap_by_size() const {
  // @@protoc_insertion_point(field_list:tensorflow.profiler.PreprocessResult.max_heap_by_size)
  return max_heap_by_size_;
}

// map<int32, .tensorflow.profiler.BufferSpan> logical_buffer_spans = 5;
inline int PreprocessResult::logical_buffer_spans_size() const {
  return logical_buffer_spans_.size();
}
inline void PreprocessResult::clear_logical_buffer_spans() {
  logical_buffer_spans_.Clear();
}
inline const ::google::protobuf::Map< ::google::protobuf::int32, ::tensorflow::profiler::BufferSpan >&
PreprocessResult::logical_buffer_spans() const {
  // @@protoc_insertion_point(field_map:tensorflow.profiler.PreprocessResult.logical_buffer_spans)
  return logical_buffer_spans_.GetMap();
}
inline ::google::protobuf::Map< ::google::protobuf::int32, ::tensorflow::profiler::BufferSpan >*
PreprocessResult::mutable_logical_buffer_spans() {
  // @@protoc_insertion_point(field_mutable_map:tensorflow.profiler.PreprocessResult.logical_buffer_spans)
  return logical_buffer_spans_.MutableMap();
}

// repeated int32 max_heap_to_by_size = 6;
inline int PreprocessResult::max_heap_to_by_size_size() const {
  return max_heap_to_by_size_.size();
}
inline void PreprocessResult::clear_max_heap_to_by_size() {
  max_heap_to_by_size_.Clear();
}
inline ::google::protobuf::int32 PreprocessResult::max_heap_to_by_size(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.max_heap_to_by_size)
  return max_heap_to_by_size_.Get(index);
}
inline void PreprocessResult::set_max_heap_to_by_size(int index, ::google::protobuf::int32 value) {
  max_heap_to_by_size_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.max_heap_to_by_size)
}
inline void PreprocessResult::add_max_heap_to_by_size(::google::protobuf::int32 value) {
  max_heap_to_by_size_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.profiler.PreprocessResult.max_heap_to_by_size)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PreprocessResult::max_heap_to_by_size() const {
  // @@protoc_insertion_point(field_list:tensorflow.profiler.PreprocessResult.max_heap_to_by_size)
  return max_heap_to_by_size_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PreprocessResult::mutable_max_heap_to_by_size() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.profiler.PreprocessResult.max_heap_to_by_size)
  return &max_heap_to_by_size_;
}

// repeated int32 by_size_to_max_heap = 7;
inline int PreprocessResult::by_size_to_max_heap_size() const {
  return by_size_to_max_heap_.size();
}
inline void PreprocessResult::clear_by_size_to_max_heap() {
  by_size_to_max_heap_.Clear();
}
inline ::google::protobuf::int32 PreprocessResult::by_size_to_max_heap(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.by_size_to_max_heap)
  return by_size_to_max_heap_.Get(index);
}
inline void PreprocessResult::set_by_size_to_max_heap(int index, ::google::protobuf::int32 value) {
  by_size_to_max_heap_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.by_size_to_max_heap)
}
inline void PreprocessResult::add_by_size_to_max_heap(::google::protobuf::int32 value) {
  by_size_to_max_heap_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.profiler.PreprocessResult.by_size_to_max_heap)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
PreprocessResult::by_size_to_max_heap() const {
  // @@protoc_insertion_point(field_list:tensorflow.profiler.PreprocessResult.by_size_to_max_heap)
  return by_size_to_max_heap_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
PreprocessResult::mutable_by_size_to_max_heap() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.profiler.PreprocessResult.by_size_to_max_heap)
  return &by_size_to_max_heap_;
}

// string module_name = 8;
inline void PreprocessResult::clear_module_name() {
  module_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PreprocessResult::module_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.module_name)
  return module_name_.GetNoArena();
}
inline void PreprocessResult::set_module_name(const ::std::string& value) {
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.module_name)
}
#if LANG_CXX11
inline void PreprocessResult::set_module_name(::std::string&& value) {
  
  module_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.PreprocessResult.module_name)
}
#endif
inline void PreprocessResult::set_module_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.PreprocessResult.module_name)
}
inline void PreprocessResult::set_module_name(const char* value, size_t size) {
  
  module_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.PreprocessResult.module_name)
}
inline ::std::string* PreprocessResult::mutable_module_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.PreprocessResult.module_name)
  return module_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreprocessResult::release_module_name() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.PreprocessResult.module_name)
  
  return module_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreprocessResult::set_allocated_module_name(::std::string* module_name) {
  if (module_name != NULL) {
    
  } else {
    
  }
  module_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), module_name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.PreprocessResult.module_name)
}

// string entry_computation_name = 9;
inline void PreprocessResult::clear_entry_computation_name() {
  entry_computation_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PreprocessResult::entry_computation_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.entry_computation_name)
  return entry_computation_name_.GetNoArena();
}
inline void PreprocessResult::set_entry_computation_name(const ::std::string& value) {
  
  entry_computation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.entry_computation_name)
}
#if LANG_CXX11
inline void PreprocessResult::set_entry_computation_name(::std::string&& value) {
  
  entry_computation_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.profiler.PreprocessResult.entry_computation_name)
}
#endif
inline void PreprocessResult::set_entry_computation_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  entry_computation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.profiler.PreprocessResult.entry_computation_name)
}
inline void PreprocessResult::set_entry_computation_name(const char* value, size_t size) {
  
  entry_computation_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.profiler.PreprocessResult.entry_computation_name)
}
inline ::std::string* PreprocessResult::mutable_entry_computation_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.PreprocessResult.entry_computation_name)
  return entry_computation_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PreprocessResult::release_entry_computation_name() {
  // @@protoc_insertion_point(field_release:tensorflow.profiler.PreprocessResult.entry_computation_name)
  
  return entry_computation_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PreprocessResult::set_allocated_entry_computation_name(::std::string* entry_computation_name) {
  if (entry_computation_name != NULL) {
    
  } else {
    
  }
  entry_computation_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), entry_computation_name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.profiler.PreprocessResult.entry_computation_name)
}

// double peak_heap_mib = 10;
inline void PreprocessResult::clear_peak_heap_mib() {
  peak_heap_mib_ = 0;
}
inline double PreprocessResult::peak_heap_mib() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.peak_heap_mib)
  return peak_heap_mib_;
}
inline void PreprocessResult::set_peak_heap_mib(double value) {
  
  peak_heap_mib_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.peak_heap_mib)
}

// double peak_unpadded_heap_mib = 11;
inline void PreprocessResult::clear_peak_unpadded_heap_mib() {
  peak_unpadded_heap_mib_ = 0;
}
inline double PreprocessResult::peak_unpadded_heap_mib() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.peak_unpadded_heap_mib)
  return peak_unpadded_heap_mib_;
}
inline void PreprocessResult::set_peak_unpadded_heap_mib(double value) {
  
  peak_unpadded_heap_mib_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.peak_unpadded_heap_mib)
}

// int32 peak_heap_size_position = 12;
inline void PreprocessResult::clear_peak_heap_size_position() {
  peak_heap_size_position_ = 0;
}
inline ::google::protobuf::int32 PreprocessResult::peak_heap_size_position() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.peak_heap_size_position)
  return peak_heap_size_position_;
}
inline void PreprocessResult::set_peak_heap_size_position(::google::protobuf::int32 value) {
  
  peak_heap_size_position_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.peak_heap_size_position)
}

// double entry_computation_parameters_mib = 13;
inline void PreprocessResult::clear_entry_computation_parameters_mib() {
  entry_computation_parameters_mib_ = 0;
}
inline double PreprocessResult::entry_computation_parameters_mib() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.entry_computation_parameters_mib)
  return entry_computation_parameters_mib_;
}
inline void PreprocessResult::set_entry_computation_parameters_mib(double value) {
  
  entry_computation_parameters_mib_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.entry_computation_parameters_mib)
}

// double non_reusable_mib = 14;
inline void PreprocessResult::clear_non_reusable_mib() {
  non_reusable_mib_ = 0;
}
inline double PreprocessResult::non_reusable_mib() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.non_reusable_mib)
  return non_reusable_mib_;
}
inline void PreprocessResult::set_non_reusable_mib(double value) {
  
  non_reusable_mib_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.non_reusable_mib)
}

// double maybe_live_out_mib = 15;
inline void PreprocessResult::clear_maybe_live_out_mib() {
  maybe_live_out_mib_ = 0;
}
inline double PreprocessResult::maybe_live_out_mib() const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.maybe_live_out_mib)
  return maybe_live_out_mib_;
}
inline void PreprocessResult::set_maybe_live_out_mib(double value) {
  
  maybe_live_out_mib_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.profiler.PreprocessResult.maybe_live_out_mib)
}

// repeated .tensorflow.profiler.BufferAllocation indefinite_lifetimes = 16;
inline int PreprocessResult::indefinite_lifetimes_size() const {
  return indefinite_lifetimes_.size();
}
inline void PreprocessResult::clear_indefinite_lifetimes() {
  indefinite_lifetimes_.Clear();
}
inline ::tensorflow::profiler::BufferAllocation* PreprocessResult::mutable_indefinite_lifetimes(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.profiler.PreprocessResult.indefinite_lifetimes)
  return indefinite_lifetimes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::BufferAllocation >*
PreprocessResult::mutable_indefinite_lifetimes() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.profiler.PreprocessResult.indefinite_lifetimes)
  return &indefinite_lifetimes_;
}
inline const ::tensorflow::profiler::BufferAllocation& PreprocessResult::indefinite_lifetimes(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.profiler.PreprocessResult.indefinite_lifetimes)
  return indefinite_lifetimes_.Get(index);
}
inline ::tensorflow::profiler::BufferAllocation* PreprocessResult::add_indefinite_lifetimes() {
  // @@protoc_insertion_point(field_add:tensorflow.profiler.PreprocessResult.indefinite_lifetimes)
  return indefinite_lifetimes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::profiler::BufferAllocation >&
PreprocessResult::indefinite_lifetimes() const {
  // @@protoc_insertion_point(field_list:tensorflow.profiler.PreprocessResult.indefinite_lifetimes)
  return indefinite_lifetimes_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace profiler
}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fcore_2fprofiler_2fprotobuf_2fmemory_5fviewer_5fpreprocess_2eproto
