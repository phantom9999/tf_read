// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/data/service/dispatcher.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/data/service/common.pb.h"
#include "tensorflow/core/framework/tensor.pb.h"
#include "tensorflow/core/protobuf/data_service.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto 

namespace protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[28];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto
namespace tensorflow {
namespace data {
class ClientHeartbeatRequest;
class ClientHeartbeatRequestDefaultTypeInternal;
extern ClientHeartbeatRequestDefaultTypeInternal _ClientHeartbeatRequest_default_instance_;
class ClientHeartbeatResponse;
class ClientHeartbeatResponseDefaultTypeInternal;
extern ClientHeartbeatResponseDefaultTypeInternal _ClientHeartbeatResponse_default_instance_;
class GetDataServiceConfigRequest;
class GetDataServiceConfigRequestDefaultTypeInternal;
extern GetDataServiceConfigRequestDefaultTypeInternal _GetDataServiceConfigRequest_default_instance_;
class GetDataServiceConfigResponse;
class GetDataServiceConfigResponseDefaultTypeInternal;
extern GetDataServiceConfigResponseDefaultTypeInternal _GetDataServiceConfigResponse_default_instance_;
class GetDataServiceMetadataRequest;
class GetDataServiceMetadataRequestDefaultTypeInternal;
extern GetDataServiceMetadataRequestDefaultTypeInternal _GetDataServiceMetadataRequest_default_instance_;
class GetDataServiceMetadataResponse;
class GetDataServiceMetadataResponseDefaultTypeInternal;
extern GetDataServiceMetadataResponseDefaultTypeInternal _GetDataServiceMetadataResponse_default_instance_;
class GetDatasetDefRequest;
class GetDatasetDefRequestDefaultTypeInternal;
extern GetDatasetDefRequestDefaultTypeInternal _GetDatasetDefRequest_default_instance_;
class GetDatasetDefResponse;
class GetDatasetDefResponseDefaultTypeInternal;
extern GetDatasetDefResponseDefaultTypeInternal _GetDatasetDefResponse_default_instance_;
class GetOrCreateJobRequest;
class GetOrCreateJobRequestDefaultTypeInternal;
extern GetOrCreateJobRequestDefaultTypeInternal _GetOrCreateJobRequest_default_instance_;
class GetOrCreateJobResponse;
class GetOrCreateJobResponseDefaultTypeInternal;
extern GetOrCreateJobResponseDefaultTypeInternal _GetOrCreateJobResponse_default_instance_;
class GetOrRegisterDatasetRequest;
class GetOrRegisterDatasetRequestDefaultTypeInternal;
extern GetOrRegisterDatasetRequestDefaultTypeInternal _GetOrRegisterDatasetRequest_default_instance_;
class GetOrRegisterDatasetResponse;
class GetOrRegisterDatasetResponseDefaultTypeInternal;
extern GetOrRegisterDatasetResponseDefaultTypeInternal _GetOrRegisterDatasetResponse_default_instance_;
class GetSplitRequest;
class GetSplitRequestDefaultTypeInternal;
extern GetSplitRequestDefaultTypeInternal _GetSplitRequest_default_instance_;
class GetSplitResponse;
class GetSplitResponseDefaultTypeInternal;
extern GetSplitResponseDefaultTypeInternal _GetSplitResponse_default_instance_;
class GetVersionRequest;
class GetVersionRequestDefaultTypeInternal;
extern GetVersionRequestDefaultTypeInternal _GetVersionRequest_default_instance_;
class GetVersionResponse;
class GetVersionResponseDefaultTypeInternal;
extern GetVersionResponseDefaultTypeInternal _GetVersionResponse_default_instance_;
class GetWorkersRequest;
class GetWorkersRequestDefaultTypeInternal;
extern GetWorkersRequestDefaultTypeInternal _GetWorkersRequest_default_instance_;
class GetWorkersResponse;
class GetWorkersResponseDefaultTypeInternal;
extern GetWorkersResponseDefaultTypeInternal _GetWorkersResponse_default_instance_;
class MaybeRemoveTaskRequest;
class MaybeRemoveTaskRequestDefaultTypeInternal;
extern MaybeRemoveTaskRequestDefaultTypeInternal _MaybeRemoveTaskRequest_default_instance_;
class MaybeRemoveTaskResponse;
class MaybeRemoveTaskResponseDefaultTypeInternal;
extern MaybeRemoveTaskResponseDefaultTypeInternal _MaybeRemoveTaskResponse_default_instance_;
class ReleaseJobClientRequest;
class ReleaseJobClientRequestDefaultTypeInternal;
extern ReleaseJobClientRequestDefaultTypeInternal _ReleaseJobClientRequest_default_instance_;
class ReleaseJobClientResponse;
class ReleaseJobClientResponseDefaultTypeInternal;
extern ReleaseJobClientResponseDefaultTypeInternal _ReleaseJobClientResponse_default_instance_;
class TaskProgress;
class TaskProgressDefaultTypeInternal;
extern TaskProgressDefaultTypeInternal _TaskProgress_default_instance_;
class WorkerHeartbeatRequest;
class WorkerHeartbeatRequestDefaultTypeInternal;
extern WorkerHeartbeatRequestDefaultTypeInternal _WorkerHeartbeatRequest_default_instance_;
class WorkerHeartbeatResponse;
class WorkerHeartbeatResponseDefaultTypeInternal;
extern WorkerHeartbeatResponseDefaultTypeInternal _WorkerHeartbeatResponse_default_instance_;
class WorkerInfo;
class WorkerInfoDefaultTypeInternal;
extern WorkerInfoDefaultTypeInternal _WorkerInfo_default_instance_;
class WorkerUpdateRequest;
class WorkerUpdateRequestDefaultTypeInternal;
extern WorkerUpdateRequestDefaultTypeInternal _WorkerUpdateRequest_default_instance_;
class WorkerUpdateResponse;
class WorkerUpdateResponseDefaultTypeInternal;
extern WorkerUpdateResponseDefaultTypeInternal _WorkerUpdateResponse_default_instance_;
}  // namespace data
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::data::ClientHeartbeatRequest* Arena::CreateMaybeMessage<::tensorflow::data::ClientHeartbeatRequest>(Arena*);
template<> ::tensorflow::data::ClientHeartbeatResponse* Arena::CreateMaybeMessage<::tensorflow::data::ClientHeartbeatResponse>(Arena*);
template<> ::tensorflow::data::GetDataServiceConfigRequest* Arena::CreateMaybeMessage<::tensorflow::data::GetDataServiceConfigRequest>(Arena*);
template<> ::tensorflow::data::GetDataServiceConfigResponse* Arena::CreateMaybeMessage<::tensorflow::data::GetDataServiceConfigResponse>(Arena*);
template<> ::tensorflow::data::GetDataServiceMetadataRequest* Arena::CreateMaybeMessage<::tensorflow::data::GetDataServiceMetadataRequest>(Arena*);
template<> ::tensorflow::data::GetDataServiceMetadataResponse* Arena::CreateMaybeMessage<::tensorflow::data::GetDataServiceMetadataResponse>(Arena*);
template<> ::tensorflow::data::GetDatasetDefRequest* Arena::CreateMaybeMessage<::tensorflow::data::GetDatasetDefRequest>(Arena*);
template<> ::tensorflow::data::GetDatasetDefResponse* Arena::CreateMaybeMessage<::tensorflow::data::GetDatasetDefResponse>(Arena*);
template<> ::tensorflow::data::GetOrCreateJobRequest* Arena::CreateMaybeMessage<::tensorflow::data::GetOrCreateJobRequest>(Arena*);
template<> ::tensorflow::data::GetOrCreateJobResponse* Arena::CreateMaybeMessage<::tensorflow::data::GetOrCreateJobResponse>(Arena*);
template<> ::tensorflow::data::GetOrRegisterDatasetRequest* Arena::CreateMaybeMessage<::tensorflow::data::GetOrRegisterDatasetRequest>(Arena*);
template<> ::tensorflow::data::GetOrRegisterDatasetResponse* Arena::CreateMaybeMessage<::tensorflow::data::GetOrRegisterDatasetResponse>(Arena*);
template<> ::tensorflow::data::GetSplitRequest* Arena::CreateMaybeMessage<::tensorflow::data::GetSplitRequest>(Arena*);
template<> ::tensorflow::data::GetSplitResponse* Arena::CreateMaybeMessage<::tensorflow::data::GetSplitResponse>(Arena*);
template<> ::tensorflow::data::GetVersionRequest* Arena::CreateMaybeMessage<::tensorflow::data::GetVersionRequest>(Arena*);
template<> ::tensorflow::data::GetVersionResponse* Arena::CreateMaybeMessage<::tensorflow::data::GetVersionResponse>(Arena*);
template<> ::tensorflow::data::GetWorkersRequest* Arena::CreateMaybeMessage<::tensorflow::data::GetWorkersRequest>(Arena*);
template<> ::tensorflow::data::GetWorkersResponse* Arena::CreateMaybeMessage<::tensorflow::data::GetWorkersResponse>(Arena*);
template<> ::tensorflow::data::MaybeRemoveTaskRequest* Arena::CreateMaybeMessage<::tensorflow::data::MaybeRemoveTaskRequest>(Arena*);
template<> ::tensorflow::data::MaybeRemoveTaskResponse* Arena::CreateMaybeMessage<::tensorflow::data::MaybeRemoveTaskResponse>(Arena*);
template<> ::tensorflow::data::ReleaseJobClientRequest* Arena::CreateMaybeMessage<::tensorflow::data::ReleaseJobClientRequest>(Arena*);
template<> ::tensorflow::data::ReleaseJobClientResponse* Arena::CreateMaybeMessage<::tensorflow::data::ReleaseJobClientResponse>(Arena*);
template<> ::tensorflow::data::TaskProgress* Arena::CreateMaybeMessage<::tensorflow::data::TaskProgress>(Arena*);
template<> ::tensorflow::data::WorkerHeartbeatRequest* Arena::CreateMaybeMessage<::tensorflow::data::WorkerHeartbeatRequest>(Arena*);
template<> ::tensorflow::data::WorkerHeartbeatResponse* Arena::CreateMaybeMessage<::tensorflow::data::WorkerHeartbeatResponse>(Arena*);
template<> ::tensorflow::data::WorkerInfo* Arena::CreateMaybeMessage<::tensorflow::data::WorkerInfo>(Arena*);
template<> ::tensorflow::data::WorkerUpdateRequest* Arena::CreateMaybeMessage<::tensorflow::data::WorkerUpdateRequest>(Arena*);
template<> ::tensorflow::data::WorkerUpdateResponse* Arena::CreateMaybeMessage<::tensorflow::data::WorkerUpdateResponse>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {
namespace data {

// ===================================================================

class TaskProgress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.TaskProgress) */ {
 public:
  TaskProgress();
  virtual ~TaskProgress();

  TaskProgress(const TaskProgress& from);

  inline TaskProgress& operator=(const TaskProgress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskProgress(TaskProgress&& from) noexcept
    : TaskProgress() {
    *this = ::std::move(from);
  }

  inline TaskProgress& operator=(TaskProgress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskProgress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskProgress* internal_default_instance() {
    return reinterpret_cast<const TaskProgress*>(
               &_TaskProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(TaskProgress* other);
  friend void swap(TaskProgress& a, TaskProgress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskProgress* New() const final {
    return CreateMaybeMessage<TaskProgress>(NULL);
  }

  TaskProgress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskProgress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskProgress& from);
  void MergeFrom(const TaskProgress& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskProgress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 task_id = 1;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  ::google::protobuf::int64 task_id() const;
  void set_task_id(::google::protobuf::int64 value);

  // bool completed = 2;
  void clear_completed();
  static const int kCompletedFieldNumber = 2;
  bool completed() const;
  void set_completed(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.TaskProgress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 task_id_;
  bool completed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WorkerHeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.WorkerHeartbeatRequest) */ {
 public:
  WorkerHeartbeatRequest();
  virtual ~WorkerHeartbeatRequest();

  WorkerHeartbeatRequest(const WorkerHeartbeatRequest& from);

  inline WorkerHeartbeatRequest& operator=(const WorkerHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkerHeartbeatRequest(WorkerHeartbeatRequest&& from) noexcept
    : WorkerHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline WorkerHeartbeatRequest& operator=(WorkerHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkerHeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const WorkerHeartbeatRequest*>(
               &_WorkerHeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(WorkerHeartbeatRequest* other);
  friend void swap(WorkerHeartbeatRequest& a, WorkerHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkerHeartbeatRequest* New() const final {
    return CreateMaybeMessage<WorkerHeartbeatRequest>(NULL);
  }

  WorkerHeartbeatRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkerHeartbeatRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkerHeartbeatRequest& from);
  void MergeFrom(const WorkerHeartbeatRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerHeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 current_tasks = 2;
  int current_tasks_size() const;
  void clear_current_tasks();
  static const int kCurrentTasksFieldNumber = 2;
  ::google::protobuf::int64 current_tasks(int index) const;
  void set_current_tasks(int index, ::google::protobuf::int64 value);
  void add_current_tasks(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      current_tasks() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_current_tasks();

  // repeated string worker_tags = 4;
  int worker_tags_size() const;
  void clear_worker_tags();
  static const int kWorkerTagsFieldNumber = 4;
  const ::std::string& worker_tags(int index) const;
  ::std::string* mutable_worker_tags(int index);
  void set_worker_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_worker_tags(int index, ::std::string&& value);
  #endif
  void set_worker_tags(int index, const char* value);
  void set_worker_tags(int index, const char* value, size_t size);
  ::std::string* add_worker_tags();
  void add_worker_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_worker_tags(::std::string&& value);
  #endif
  void add_worker_tags(const char* value);
  void add_worker_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& worker_tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_worker_tags();

  // string worker_address = 1;
  void clear_worker_address();
  static const int kWorkerAddressFieldNumber = 1;
  const ::std::string& worker_address() const;
  void set_worker_address(const ::std::string& value);
  #if LANG_CXX11
  void set_worker_address(::std::string&& value);
  #endif
  void set_worker_address(const char* value);
  void set_worker_address(const char* value, size_t size);
  ::std::string* mutable_worker_address();
  ::std::string* release_worker_address();
  void set_allocated_worker_address(::std::string* worker_address);

  // string transfer_address = 3;
  void clear_transfer_address();
  static const int kTransferAddressFieldNumber = 3;
  const ::std::string& transfer_address() const;
  void set_transfer_address(const ::std::string& value);
  #if LANG_CXX11
  void set_transfer_address(::std::string&& value);
  #endif
  void set_transfer_address(const char* value);
  void set_transfer_address(const char* value, size_t size);
  ::std::string* mutable_transfer_address();
  ::std::string* release_transfer_address();
  void set_allocated_transfer_address(::std::string* transfer_address);

  // int64 worker_uid = 5;
  void clear_worker_uid();
  static const int kWorkerUidFieldNumber = 5;
  ::google::protobuf::int64 worker_uid() const;
  void set_worker_uid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.WorkerHeartbeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > current_tasks_;
  mutable int _current_tasks_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> worker_tags_;
  ::google::protobuf::internal::ArenaStringPtr worker_address_;
  ::google::protobuf::internal::ArenaStringPtr transfer_address_;
  ::google::protobuf::int64 worker_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WorkerHeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.WorkerHeartbeatResponse) */ {
 public:
  WorkerHeartbeatResponse();
  virtual ~WorkerHeartbeatResponse();

  WorkerHeartbeatResponse(const WorkerHeartbeatResponse& from);

  inline WorkerHeartbeatResponse& operator=(const WorkerHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkerHeartbeatResponse(WorkerHeartbeatResponse&& from) noexcept
    : WorkerHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline WorkerHeartbeatResponse& operator=(WorkerHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkerHeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const WorkerHeartbeatResponse*>(
               &_WorkerHeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(WorkerHeartbeatResponse* other);
  friend void swap(WorkerHeartbeatResponse& a, WorkerHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkerHeartbeatResponse* New() const final {
    return CreateMaybeMessage<WorkerHeartbeatResponse>(NULL);
  }

  WorkerHeartbeatResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkerHeartbeatResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkerHeartbeatResponse& from);
  void MergeFrom(const WorkerHeartbeatResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerHeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.data.TaskDef new_tasks = 1;
  int new_tasks_size() const;
  void clear_new_tasks();
  static const int kNewTasksFieldNumber = 1;
  ::tensorflow::data::TaskDef* mutable_new_tasks(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskDef >*
      mutable_new_tasks();
  const ::tensorflow::data::TaskDef& new_tasks(int index) const;
  ::tensorflow::data::TaskDef* add_new_tasks();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskDef >&
      new_tasks() const;

  // repeated int64 tasks_to_delete = 2;
  int tasks_to_delete_size() const;
  void clear_tasks_to_delete();
  static const int kTasksToDeleteFieldNumber = 2;
  ::google::protobuf::int64 tasks_to_delete(int index) const;
  void set_tasks_to_delete(int index, ::google::protobuf::int64 value);
  void add_tasks_to_delete(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      tasks_to_delete() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_tasks_to_delete();

  // @@protoc_insertion_point(class_scope:tensorflow.data.WorkerHeartbeatResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskDef > new_tasks_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > tasks_to_delete_;
  mutable int _tasks_to_delete_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WorkerUpdateRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.WorkerUpdateRequest) */ {
 public:
  WorkerUpdateRequest();
  virtual ~WorkerUpdateRequest();

  WorkerUpdateRequest(const WorkerUpdateRequest& from);

  inline WorkerUpdateRequest& operator=(const WorkerUpdateRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkerUpdateRequest(WorkerUpdateRequest&& from) noexcept
    : WorkerUpdateRequest() {
    *this = ::std::move(from);
  }

  inline WorkerUpdateRequest& operator=(WorkerUpdateRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkerUpdateRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerUpdateRequest* internal_default_instance() {
    return reinterpret_cast<const WorkerUpdateRequest*>(
               &_WorkerUpdateRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(WorkerUpdateRequest* other);
  friend void swap(WorkerUpdateRequest& a, WorkerUpdateRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkerUpdateRequest* New() const final {
    return CreateMaybeMessage<WorkerUpdateRequest>(NULL);
  }

  WorkerUpdateRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkerUpdateRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkerUpdateRequest& from);
  void MergeFrom(const WorkerUpdateRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerUpdateRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.data.TaskProgress updates = 2;
  int updates_size() const;
  void clear_updates();
  static const int kUpdatesFieldNumber = 2;
  ::tensorflow::data::TaskProgress* mutable_updates(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskProgress >*
      mutable_updates();
  const ::tensorflow::data::TaskProgress& updates(int index) const;
  ::tensorflow::data::TaskProgress* add_updates();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskProgress >&
      updates() const;

  // string worker_address = 1;
  void clear_worker_address();
  static const int kWorkerAddressFieldNumber = 1;
  const ::std::string& worker_address() const;
  void set_worker_address(const ::std::string& value);
  #if LANG_CXX11
  void set_worker_address(::std::string&& value);
  #endif
  void set_worker_address(const char* value);
  void set_worker_address(const char* value, size_t size);
  ::std::string* mutable_worker_address();
  ::std::string* release_worker_address();
  void set_allocated_worker_address(::std::string* worker_address);

  // @@protoc_insertion_point(class_scope:tensorflow.data.WorkerUpdateRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskProgress > updates_;
  ::google::protobuf::internal::ArenaStringPtr worker_address_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WorkerUpdateResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.WorkerUpdateResponse) */ {
 public:
  WorkerUpdateResponse();
  virtual ~WorkerUpdateResponse();

  WorkerUpdateResponse(const WorkerUpdateResponse& from);

  inline WorkerUpdateResponse& operator=(const WorkerUpdateResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkerUpdateResponse(WorkerUpdateResponse&& from) noexcept
    : WorkerUpdateResponse() {
    *this = ::std::move(from);
  }

  inline WorkerUpdateResponse& operator=(WorkerUpdateResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkerUpdateResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerUpdateResponse* internal_default_instance() {
    return reinterpret_cast<const WorkerUpdateResponse*>(
               &_WorkerUpdateResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(WorkerUpdateResponse* other);
  friend void swap(WorkerUpdateResponse& a, WorkerUpdateResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkerUpdateResponse* New() const final {
    return CreateMaybeMessage<WorkerUpdateResponse>(NULL);
  }

  WorkerUpdateResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkerUpdateResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkerUpdateResponse& from);
  void MergeFrom(const WorkerUpdateResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerUpdateResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.data.WorkerUpdateResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDatasetDefRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetDatasetDefRequest) */ {
 public:
  GetDatasetDefRequest();
  virtual ~GetDatasetDefRequest();

  GetDatasetDefRequest(const GetDatasetDefRequest& from);

  inline GetDatasetDefRequest& operator=(const GetDatasetDefRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDatasetDefRequest(GetDatasetDefRequest&& from) noexcept
    : GetDatasetDefRequest() {
    *this = ::std::move(from);
  }

  inline GetDatasetDefRequest& operator=(GetDatasetDefRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDatasetDefRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDatasetDefRequest* internal_default_instance() {
    return reinterpret_cast<const GetDatasetDefRequest*>(
               &_GetDatasetDefRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(GetDatasetDefRequest* other);
  friend void swap(GetDatasetDefRequest& a, GetDatasetDefRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDatasetDefRequest* New() const final {
    return CreateMaybeMessage<GetDatasetDefRequest>(NULL);
  }

  GetDatasetDefRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetDatasetDefRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetDatasetDefRequest& from);
  void MergeFrom(const GetDatasetDefRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDatasetDefRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 dataset_id = 1;
  void clear_dataset_id();
  static const int kDatasetIdFieldNumber = 1;
  ::google::protobuf::int64 dataset_id() const;
  void set_dataset_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetDatasetDefRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 dataset_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDatasetDefResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetDatasetDefResponse) */ {
 public:
  GetDatasetDefResponse();
  virtual ~GetDatasetDefResponse();

  GetDatasetDefResponse(const GetDatasetDefResponse& from);

  inline GetDatasetDefResponse& operator=(const GetDatasetDefResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDatasetDefResponse(GetDatasetDefResponse&& from) noexcept
    : GetDatasetDefResponse() {
    *this = ::std::move(from);
  }

  inline GetDatasetDefResponse& operator=(GetDatasetDefResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDatasetDefResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDatasetDefResponse* internal_default_instance() {
    return reinterpret_cast<const GetDatasetDefResponse*>(
               &_GetDatasetDefResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(GetDatasetDefResponse* other);
  friend void swap(GetDatasetDefResponse& a, GetDatasetDefResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDatasetDefResponse* New() const final {
    return CreateMaybeMessage<GetDatasetDefResponse>(NULL);
  }

  GetDatasetDefResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetDatasetDefResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetDatasetDefResponse& from);
  void MergeFrom(const GetDatasetDefResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDatasetDefResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.data.DatasetDef dataset_def = 1;
  bool has_dataset_def() const;
  void clear_dataset_def();
  static const int kDatasetDefFieldNumber = 1;
  private:
  const ::tensorflow::data::DatasetDef& _internal_dataset_def() const;
  public:
  const ::tensorflow::data::DatasetDef& dataset_def() const;
  ::tensorflow::data::DatasetDef* release_dataset_def();
  ::tensorflow::data::DatasetDef* mutable_dataset_def();
  void set_allocated_dataset_def(::tensorflow::data::DatasetDef* dataset_def);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetDatasetDefResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::data::DatasetDef* dataset_def_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSplitRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetSplitRequest) */ {
 public:
  GetSplitRequest();
  virtual ~GetSplitRequest();

  GetSplitRequest(const GetSplitRequest& from);

  inline GetSplitRequest& operator=(const GetSplitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSplitRequest(GetSplitRequest&& from) noexcept
    : GetSplitRequest() {
    *this = ::std::move(from);
  }

  inline GetSplitRequest& operator=(GetSplitRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSplitRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSplitRequest* internal_default_instance() {
    return reinterpret_cast<const GetSplitRequest*>(
               &_GetSplitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GetSplitRequest* other);
  friend void swap(GetSplitRequest& a, GetSplitRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSplitRequest* New() const final {
    return CreateMaybeMessage<GetSplitRequest>(NULL);
  }

  GetSplitRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSplitRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSplitRequest& from);
  void MergeFrom(const GetSplitRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSplitRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // int64 iteration = 2;
  void clear_iteration();
  static const int kIterationFieldNumber = 2;
  ::google::protobuf::int64 iteration() const;
  void set_iteration(::google::protobuf::int64 value);

  // int64 split_provider_index = 3;
  void clear_split_provider_index();
  static const int kSplitProviderIndexFieldNumber = 3;
  ::google::protobuf::int64 split_provider_index() const;
  void set_split_provider_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetSplitRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 job_id_;
  ::google::protobuf::int64 iteration_;
  ::google::protobuf::int64 split_provider_index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSplitResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetSplitResponse) */ {
 public:
  GetSplitResponse();
  virtual ~GetSplitResponse();

  GetSplitResponse(const GetSplitResponse& from);

  inline GetSplitResponse& operator=(const GetSplitResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSplitResponse(GetSplitResponse&& from) noexcept
    : GetSplitResponse() {
    *this = ::std::move(from);
  }

  inline GetSplitResponse& operator=(GetSplitResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSplitResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSplitResponse* internal_default_instance() {
    return reinterpret_cast<const GetSplitResponse*>(
               &_GetSplitResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetSplitResponse* other);
  friend void swap(GetSplitResponse& a, GetSplitResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSplitResponse* New() const final {
    return CreateMaybeMessage<GetSplitResponse>(NULL);
  }

  GetSplitResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSplitResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSplitResponse& from);
  void MergeFrom(const GetSplitResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSplitResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.TensorProto split = 1;
  bool has_split() const;
  void clear_split();
  static const int kSplitFieldNumber = 1;
  private:
  const ::tensorflow::TensorProto& _internal_split() const;
  public:
  const ::tensorflow::TensorProto& split() const;
  ::tensorflow::TensorProto* release_split();
  ::tensorflow::TensorProto* mutable_split();
  void set_allocated_split(::tensorflow::TensorProto* split);

  // bool end_of_splits = 2;
  void clear_end_of_splits();
  static const int kEndOfSplitsFieldNumber = 2;
  bool end_of_splits() const;
  void set_end_of_splits(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetSplitResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::TensorProto* split_;
  bool end_of_splits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetVersionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetVersionRequest) */ {
 public:
  GetVersionRequest();
  virtual ~GetVersionRequest();

  GetVersionRequest(const GetVersionRequest& from);

  inline GetVersionRequest& operator=(const GetVersionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetVersionRequest(GetVersionRequest&& from) noexcept
    : GetVersionRequest() {
    *this = ::std::move(from);
  }

  inline GetVersionRequest& operator=(GetVersionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetVersionRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVersionRequest* internal_default_instance() {
    return reinterpret_cast<const GetVersionRequest*>(
               &_GetVersionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetVersionRequest* other);
  friend void swap(GetVersionRequest& a, GetVersionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVersionRequest* New() const final {
    return CreateMaybeMessage<GetVersionRequest>(NULL);
  }

  GetVersionRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetVersionRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetVersionRequest& from);
  void MergeFrom(const GetVersionRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVersionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetVersionRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetVersionResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetVersionResponse) */ {
 public:
  GetVersionResponse();
  virtual ~GetVersionResponse();

  GetVersionResponse(const GetVersionResponse& from);

  inline GetVersionResponse& operator=(const GetVersionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetVersionResponse(GetVersionResponse&& from) noexcept
    : GetVersionResponse() {
    *this = ::std::move(from);
  }

  inline GetVersionResponse& operator=(GetVersionResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetVersionResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetVersionResponse* internal_default_instance() {
    return reinterpret_cast<const GetVersionResponse*>(
               &_GetVersionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetVersionResponse* other);
  friend void swap(GetVersionResponse& a, GetVersionResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetVersionResponse* New() const final {
    return CreateMaybeMessage<GetVersionResponse>(NULL);
  }

  GetVersionResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetVersionResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetVersionResponse& from);
  void MergeFrom(const GetVersionResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetVersionResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 version = 1;
  void clear_version();
  static const int kVersionFieldNumber = 1;
  ::google::protobuf::int64 version() const;
  void set_version(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetVersionResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 version_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetOrRegisterDatasetRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetOrRegisterDatasetRequest) */ {
 public:
  GetOrRegisterDatasetRequest();
  virtual ~GetOrRegisterDatasetRequest();

  GetOrRegisterDatasetRequest(const GetOrRegisterDatasetRequest& from);

  inline GetOrRegisterDatasetRequest& operator=(const GetOrRegisterDatasetRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetOrRegisterDatasetRequest(GetOrRegisterDatasetRequest&& from) noexcept
    : GetOrRegisterDatasetRequest() {
    *this = ::std::move(from);
  }

  inline GetOrRegisterDatasetRequest& operator=(GetOrRegisterDatasetRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOrRegisterDatasetRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOrRegisterDatasetRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrRegisterDatasetRequest*>(
               &_GetOrRegisterDatasetRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetOrRegisterDatasetRequest* other);
  friend void swap(GetOrRegisterDatasetRequest& a, GetOrRegisterDatasetRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOrRegisterDatasetRequest* New() const final {
    return CreateMaybeMessage<GetOrRegisterDatasetRequest>(NULL);
  }

  GetOrRegisterDatasetRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetOrRegisterDatasetRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetOrRegisterDatasetRequest& from);
  void MergeFrom(const GetOrRegisterDatasetRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrRegisterDatasetRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.data.DatasetDef dataset = 1;
  bool has_dataset() const;
  void clear_dataset();
  static const int kDatasetFieldNumber = 1;
  private:
  const ::tensorflow::data::DatasetDef& _internal_dataset() const;
  public:
  const ::tensorflow::data::DatasetDef& dataset() const;
  ::tensorflow::data::DatasetDef* release_dataset();
  ::tensorflow::data::DatasetDef* mutable_dataset();
  void set_allocated_dataset(::tensorflow::data::DatasetDef* dataset);

  // .tensorflow.data.DataServiceMetadata metadata = 3;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  private:
  const ::tensorflow::data::DataServiceMetadata& _internal_metadata() const;
  public:
  const ::tensorflow::data::DataServiceMetadata& metadata() const;
  ::tensorflow::data::DataServiceMetadata* release_metadata();
  ::tensorflow::data::DataServiceMetadata* mutable_metadata();
  void set_allocated_metadata(::tensorflow::data::DataServiceMetadata* metadata);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetOrRegisterDatasetRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::data::DatasetDef* dataset_;
  ::tensorflow::data::DataServiceMetadata* metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetOrRegisterDatasetResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetOrRegisterDatasetResponse) */ {
 public:
  GetOrRegisterDatasetResponse();
  virtual ~GetOrRegisterDatasetResponse();

  GetOrRegisterDatasetResponse(const GetOrRegisterDatasetResponse& from);

  inline GetOrRegisterDatasetResponse& operator=(const GetOrRegisterDatasetResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetOrRegisterDatasetResponse(GetOrRegisterDatasetResponse&& from) noexcept
    : GetOrRegisterDatasetResponse() {
    *this = ::std::move(from);
  }

  inline GetOrRegisterDatasetResponse& operator=(GetOrRegisterDatasetResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOrRegisterDatasetResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOrRegisterDatasetResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrRegisterDatasetResponse*>(
               &_GetOrRegisterDatasetResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetOrRegisterDatasetResponse* other);
  friend void swap(GetOrRegisterDatasetResponse& a, GetOrRegisterDatasetResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOrRegisterDatasetResponse* New() const final {
    return CreateMaybeMessage<GetOrRegisterDatasetResponse>(NULL);
  }

  GetOrRegisterDatasetResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetOrRegisterDatasetResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetOrRegisterDatasetResponse& from);
  void MergeFrom(const GetOrRegisterDatasetResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrRegisterDatasetResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 dataset_id = 1;
  void clear_dataset_id();
  static const int kDatasetIdFieldNumber = 1;
  ::google::protobuf::int64 dataset_id() const;
  void set_dataset_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetOrRegisterDatasetResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 dataset_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDataServiceMetadataRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetDataServiceMetadataRequest) */ {
 public:
  GetDataServiceMetadataRequest();
  virtual ~GetDataServiceMetadataRequest();

  GetDataServiceMetadataRequest(const GetDataServiceMetadataRequest& from);

  inline GetDataServiceMetadataRequest& operator=(const GetDataServiceMetadataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDataServiceMetadataRequest(GetDataServiceMetadataRequest&& from) noexcept
    : GetDataServiceMetadataRequest() {
    *this = ::std::move(from);
  }

  inline GetDataServiceMetadataRequest& operator=(GetDataServiceMetadataRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDataServiceMetadataRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDataServiceMetadataRequest* internal_default_instance() {
    return reinterpret_cast<const GetDataServiceMetadataRequest*>(
               &_GetDataServiceMetadataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(GetDataServiceMetadataRequest* other);
  friend void swap(GetDataServiceMetadataRequest& a, GetDataServiceMetadataRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDataServiceMetadataRequest* New() const final {
    return CreateMaybeMessage<GetDataServiceMetadataRequest>(NULL);
  }

  GetDataServiceMetadataRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetDataServiceMetadataRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetDataServiceMetadataRequest& from);
  void MergeFrom(const GetDataServiceMetadataRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataServiceMetadataRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 dataset_id = 1;
  void clear_dataset_id();
  static const int kDatasetIdFieldNumber = 1;
  ::google::protobuf::int64 dataset_id() const;
  void set_dataset_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetDataServiceMetadataRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 dataset_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDataServiceMetadataResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetDataServiceMetadataResponse) */ {
 public:
  GetDataServiceMetadataResponse();
  virtual ~GetDataServiceMetadataResponse();

  GetDataServiceMetadataResponse(const GetDataServiceMetadataResponse& from);

  inline GetDataServiceMetadataResponse& operator=(const GetDataServiceMetadataResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDataServiceMetadataResponse(GetDataServiceMetadataResponse&& from) noexcept
    : GetDataServiceMetadataResponse() {
    *this = ::std::move(from);
  }

  inline GetDataServiceMetadataResponse& operator=(GetDataServiceMetadataResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDataServiceMetadataResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDataServiceMetadataResponse* internal_default_instance() {
    return reinterpret_cast<const GetDataServiceMetadataResponse*>(
               &_GetDataServiceMetadataResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(GetDataServiceMetadataResponse* other);
  friend void swap(GetDataServiceMetadataResponse& a, GetDataServiceMetadataResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDataServiceMetadataResponse* New() const final {
    return CreateMaybeMessage<GetDataServiceMetadataResponse>(NULL);
  }

  GetDataServiceMetadataResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetDataServiceMetadataResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetDataServiceMetadataResponse& from);
  void MergeFrom(const GetDataServiceMetadataResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataServiceMetadataResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.data.DataServiceMetadata metadata = 1;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 1;
  private:
  const ::tensorflow::data::DataServiceMetadata& _internal_metadata() const;
  public:
  const ::tensorflow::data::DataServiceMetadata& metadata() const;
  ::tensorflow::data::DataServiceMetadata* release_metadata();
  ::tensorflow::data::DataServiceMetadata* mutable_metadata();
  void set_allocated_metadata(::tensorflow::data::DataServiceMetadata* metadata);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetDataServiceMetadataResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::data::DataServiceMetadata* metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDataServiceConfigRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetDataServiceConfigRequest) */ {
 public:
  GetDataServiceConfigRequest();
  virtual ~GetDataServiceConfigRequest();

  GetDataServiceConfigRequest(const GetDataServiceConfigRequest& from);

  inline GetDataServiceConfigRequest& operator=(const GetDataServiceConfigRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDataServiceConfigRequest(GetDataServiceConfigRequest&& from) noexcept
    : GetDataServiceConfigRequest() {
    *this = ::std::move(from);
  }

  inline GetDataServiceConfigRequest& operator=(GetDataServiceConfigRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDataServiceConfigRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDataServiceConfigRequest* internal_default_instance() {
    return reinterpret_cast<const GetDataServiceConfigRequest*>(
               &_GetDataServiceConfigRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(GetDataServiceConfigRequest* other);
  friend void swap(GetDataServiceConfigRequest& a, GetDataServiceConfigRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDataServiceConfigRequest* New() const final {
    return CreateMaybeMessage<GetDataServiceConfigRequest>(NULL);
  }

  GetDataServiceConfigRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetDataServiceConfigRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetDataServiceConfigRequest& from);
  void MergeFrom(const GetDataServiceConfigRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataServiceConfigRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetDataServiceConfigRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetDataServiceConfigResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetDataServiceConfigResponse) */ {
 public:
  GetDataServiceConfigResponse();
  virtual ~GetDataServiceConfigResponse();

  GetDataServiceConfigResponse(const GetDataServiceConfigResponse& from);

  inline GetDataServiceConfigResponse& operator=(const GetDataServiceConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetDataServiceConfigResponse(GetDataServiceConfigResponse&& from) noexcept
    : GetDataServiceConfigResponse() {
    *this = ::std::move(from);
  }

  inline GetDataServiceConfigResponse& operator=(GetDataServiceConfigResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetDataServiceConfigResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetDataServiceConfigResponse* internal_default_instance() {
    return reinterpret_cast<const GetDataServiceConfigResponse*>(
               &_GetDataServiceConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(GetDataServiceConfigResponse* other);
  friend void swap(GetDataServiceConfigResponse& a, GetDataServiceConfigResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetDataServiceConfigResponse* New() const final {
    return CreateMaybeMessage<GetDataServiceConfigResponse>(NULL);
  }

  GetDataServiceConfigResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetDataServiceConfigResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetDataServiceConfigResponse& from);
  void MergeFrom(const GetDataServiceConfigResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDataServiceConfigResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.data.DataServiceConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  private:
  const ::tensorflow::data::DataServiceConfig& _internal_config() const;
  public:
  const ::tensorflow::data::DataServiceConfig& config() const;
  ::tensorflow::data::DataServiceConfig* release_config();
  ::tensorflow::data::DataServiceConfig* mutable_config();
  void set_allocated_config(::tensorflow::data::DataServiceConfig* config);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetDataServiceConfigResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::data::DataServiceConfig* config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetOrCreateJobRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetOrCreateJobRequest) */ {
 public:
  GetOrCreateJobRequest();
  virtual ~GetOrCreateJobRequest();

  GetOrCreateJobRequest(const GetOrCreateJobRequest& from);

  inline GetOrCreateJobRequest& operator=(const GetOrCreateJobRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetOrCreateJobRequest(GetOrCreateJobRequest&& from) noexcept
    : GetOrCreateJobRequest() {
    *this = ::std::move(from);
  }

  inline GetOrCreateJobRequest& operator=(GetOrCreateJobRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOrCreateJobRequest& default_instance();

  enum OptionalNumConsumersCase {
    kNumConsumers = 7,
    OPTIONAL_NUM_CONSUMERS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOrCreateJobRequest* internal_default_instance() {
    return reinterpret_cast<const GetOrCreateJobRequest*>(
               &_GetOrCreateJobRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(GetOrCreateJobRequest* other);
  friend void swap(GetOrCreateJobRequest& a, GetOrCreateJobRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOrCreateJobRequest* New() const final {
    return CreateMaybeMessage<GetOrCreateJobRequest>(NULL);
  }

  GetOrCreateJobRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetOrCreateJobRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetOrCreateJobRequest& from);
  void MergeFrom(const GetOrCreateJobRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrCreateJobRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.data.JobKeyDef job_key = 5;
  bool has_job_key() const;
  void clear_job_key();
  static const int kJobKeyFieldNumber = 5;
  private:
  const ::tensorflow::data::JobKeyDef& _internal_job_key() const;
  public:
  const ::tensorflow::data::JobKeyDef& job_key() const;
  ::tensorflow::data::JobKeyDef* release_job_key();
  ::tensorflow::data::JobKeyDef* mutable_job_key();
  void set_allocated_job_key(::tensorflow::data::JobKeyDef* job_key);

  // .tensorflow.data.ProcessingModeDef processing_mode_def = 8;
  bool has_processing_mode_def() const;
  void clear_processing_mode_def();
  static const int kProcessingModeDefFieldNumber = 8;
  private:
  const ::tensorflow::data::ProcessingModeDef& _internal_processing_mode_def() const;
  public:
  const ::tensorflow::data::ProcessingModeDef& processing_mode_def() const;
  ::tensorflow::data::ProcessingModeDef* release_processing_mode_def();
  ::tensorflow::data::ProcessingModeDef* mutable_processing_mode_def();
  void set_allocated_processing_mode_def(::tensorflow::data::ProcessingModeDef* processing_mode_def);

  // int64 dataset_id = 1;
  void clear_dataset_id();
  static const int kDatasetIdFieldNumber = 1;
  ::google::protobuf::int64 dataset_id() const;
  void set_dataset_id(::google::protobuf::int64 value);

  // .tensorflow.data.TargetWorkers target_workers = 9;
  void clear_target_workers();
  static const int kTargetWorkersFieldNumber = 9;
  ::tensorflow::data::TargetWorkers target_workers() const;
  void set_target_workers(::tensorflow::data::TargetWorkers value);

  // int64 num_consumers = 7;
  private:
  bool has_num_consumers() const;
  public:
  void clear_num_consumers();
  static const int kNumConsumersFieldNumber = 7;
  ::google::protobuf::int64 num_consumers() const;
  void set_num_consumers(::google::protobuf::int64 value);

  void clear_optional_num_consumers();
  OptionalNumConsumersCase optional_num_consumers_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.GetOrCreateJobRequest)
 private:
  void set_has_num_consumers();

  inline bool has_optional_num_consumers() const;
  inline void clear_has_optional_num_consumers();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::data::JobKeyDef* job_key_;
  ::tensorflow::data::ProcessingModeDef* processing_mode_def_;
  ::google::protobuf::int64 dataset_id_;
  int target_workers_;
  union OptionalNumConsumersUnion {
    OptionalNumConsumersUnion() {}
    ::google::protobuf::int64 num_consumers_;
  } optional_num_consumers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetOrCreateJobResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetOrCreateJobResponse) */ {
 public:
  GetOrCreateJobResponse();
  virtual ~GetOrCreateJobResponse();

  GetOrCreateJobResponse(const GetOrCreateJobResponse& from);

  inline GetOrCreateJobResponse& operator=(const GetOrCreateJobResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetOrCreateJobResponse(GetOrCreateJobResponse&& from) noexcept
    : GetOrCreateJobResponse() {
    *this = ::std::move(from);
  }

  inline GetOrCreateJobResponse& operator=(GetOrCreateJobResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetOrCreateJobResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetOrCreateJobResponse* internal_default_instance() {
    return reinterpret_cast<const GetOrCreateJobResponse*>(
               &_GetOrCreateJobResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(GetOrCreateJobResponse* other);
  friend void swap(GetOrCreateJobResponse& a, GetOrCreateJobResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetOrCreateJobResponse* New() const final {
    return CreateMaybeMessage<GetOrCreateJobResponse>(NULL);
  }

  GetOrCreateJobResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetOrCreateJobResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetOrCreateJobResponse& from);
  void MergeFrom(const GetOrCreateJobResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetOrCreateJobResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 job_client_id = 1;
  void clear_job_client_id();
  static const int kJobClientIdFieldNumber = 1;
  ::google::protobuf::int64 job_client_id() const;
  void set_job_client_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetOrCreateJobResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 job_client_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MaybeRemoveTaskRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.MaybeRemoveTaskRequest) */ {
 public:
  MaybeRemoveTaskRequest();
  virtual ~MaybeRemoveTaskRequest();

  MaybeRemoveTaskRequest(const MaybeRemoveTaskRequest& from);

  inline MaybeRemoveTaskRequest& operator=(const MaybeRemoveTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MaybeRemoveTaskRequest(MaybeRemoveTaskRequest&& from) noexcept
    : MaybeRemoveTaskRequest() {
    *this = ::std::move(from);
  }

  inline MaybeRemoveTaskRequest& operator=(MaybeRemoveTaskRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MaybeRemoveTaskRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MaybeRemoveTaskRequest* internal_default_instance() {
    return reinterpret_cast<const MaybeRemoveTaskRequest*>(
               &_MaybeRemoveTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(MaybeRemoveTaskRequest* other);
  friend void swap(MaybeRemoveTaskRequest& a, MaybeRemoveTaskRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MaybeRemoveTaskRequest* New() const final {
    return CreateMaybeMessage<MaybeRemoveTaskRequest>(NULL);
  }

  MaybeRemoveTaskRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MaybeRemoveTaskRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MaybeRemoveTaskRequest& from);
  void MergeFrom(const MaybeRemoveTaskRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaybeRemoveTaskRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 task_id = 1;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  ::google::protobuf::int64 task_id() const;
  void set_task_id(::google::protobuf::int64 value);

  // int64 consumer_index = 2;
  void clear_consumer_index();
  static const int kConsumerIndexFieldNumber = 2;
  ::google::protobuf::int64 consumer_index() const;
  void set_consumer_index(::google::protobuf::int64 value);

  // int64 round = 3;
  void clear_round();
  static const int kRoundFieldNumber = 3;
  ::google::protobuf::int64 round() const;
  void set_round(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.MaybeRemoveTaskRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 task_id_;
  ::google::protobuf::int64 consumer_index_;
  ::google::protobuf::int64 round_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MaybeRemoveTaskResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.MaybeRemoveTaskResponse) */ {
 public:
  MaybeRemoveTaskResponse();
  virtual ~MaybeRemoveTaskResponse();

  MaybeRemoveTaskResponse(const MaybeRemoveTaskResponse& from);

  inline MaybeRemoveTaskResponse& operator=(const MaybeRemoveTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MaybeRemoveTaskResponse(MaybeRemoveTaskResponse&& from) noexcept
    : MaybeRemoveTaskResponse() {
    *this = ::std::move(from);
  }

  inline MaybeRemoveTaskResponse& operator=(MaybeRemoveTaskResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MaybeRemoveTaskResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MaybeRemoveTaskResponse* internal_default_instance() {
    return reinterpret_cast<const MaybeRemoveTaskResponse*>(
               &_MaybeRemoveTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(MaybeRemoveTaskResponse* other);
  friend void swap(MaybeRemoveTaskResponse& a, MaybeRemoveTaskResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MaybeRemoveTaskResponse* New() const final {
    return CreateMaybeMessage<MaybeRemoveTaskResponse>(NULL);
  }

  MaybeRemoveTaskResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MaybeRemoveTaskResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MaybeRemoveTaskResponse& from);
  void MergeFrom(const MaybeRemoveTaskResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MaybeRemoveTaskResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bool removed = 1;
  void clear_removed();
  static const int kRemovedFieldNumber = 1;
  bool removed() const;
  void set_removed(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.MaybeRemoveTaskResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool removed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReleaseJobClientRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.ReleaseJobClientRequest) */ {
 public:
  ReleaseJobClientRequest();
  virtual ~ReleaseJobClientRequest();

  ReleaseJobClientRequest(const ReleaseJobClientRequest& from);

  inline ReleaseJobClientRequest& operator=(const ReleaseJobClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReleaseJobClientRequest(ReleaseJobClientRequest&& from) noexcept
    : ReleaseJobClientRequest() {
    *this = ::std::move(from);
  }

  inline ReleaseJobClientRequest& operator=(ReleaseJobClientRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseJobClientRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseJobClientRequest* internal_default_instance() {
    return reinterpret_cast<const ReleaseJobClientRequest*>(
               &_ReleaseJobClientRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(ReleaseJobClientRequest* other);
  friend void swap(ReleaseJobClientRequest& a, ReleaseJobClientRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReleaseJobClientRequest* New() const final {
    return CreateMaybeMessage<ReleaseJobClientRequest>(NULL);
  }

  ReleaseJobClientRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseJobClientRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReleaseJobClientRequest& from);
  void MergeFrom(const ReleaseJobClientRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseJobClientRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 job_client_id = 1;
  void clear_job_client_id();
  static const int kJobClientIdFieldNumber = 1;
  ::google::protobuf::int64 job_client_id() const;
  void set_job_client_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.ReleaseJobClientRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 job_client_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReleaseJobClientResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.ReleaseJobClientResponse) */ {
 public:
  ReleaseJobClientResponse();
  virtual ~ReleaseJobClientResponse();

  ReleaseJobClientResponse(const ReleaseJobClientResponse& from);

  inline ReleaseJobClientResponse& operator=(const ReleaseJobClientResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReleaseJobClientResponse(ReleaseJobClientResponse&& from) noexcept
    : ReleaseJobClientResponse() {
    *this = ::std::move(from);
  }

  inline ReleaseJobClientResponse& operator=(ReleaseJobClientResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseJobClientResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseJobClientResponse* internal_default_instance() {
    return reinterpret_cast<const ReleaseJobClientResponse*>(
               &_ReleaseJobClientResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(ReleaseJobClientResponse* other);
  friend void swap(ReleaseJobClientResponse& a, ReleaseJobClientResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReleaseJobClientResponse* New() const final {
    return CreateMaybeMessage<ReleaseJobClientResponse>(NULL);
  }

  ReleaseJobClientResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseJobClientResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReleaseJobClientResponse& from);
  void MergeFrom(const ReleaseJobClientResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseJobClientResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.data.ReleaseJobClientResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientHeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.ClientHeartbeatRequest) */ {
 public:
  ClientHeartbeatRequest();
  virtual ~ClientHeartbeatRequest();

  ClientHeartbeatRequest(const ClientHeartbeatRequest& from);

  inline ClientHeartbeatRequest& operator=(const ClientHeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientHeartbeatRequest(ClientHeartbeatRequest&& from) noexcept
    : ClientHeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline ClientHeartbeatRequest& operator=(ClientHeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientHeartbeatRequest& default_instance();

  enum OptionalCurrentRoundCase {
    kCurrentRound = 2,
    OPTIONAL_CURRENT_ROUND_NOT_SET = 0,
  };

  enum OptionalBlockedRoundCase {
    kBlockedRound = 4,
    OPTIONAL_BLOCKED_ROUND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientHeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const ClientHeartbeatRequest*>(
               &_ClientHeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ClientHeartbeatRequest* other);
  friend void swap(ClientHeartbeatRequest& a, ClientHeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientHeartbeatRequest* New() const final {
    return CreateMaybeMessage<ClientHeartbeatRequest>(NULL);
  }

  ClientHeartbeatRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientHeartbeatRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientHeartbeatRequest& from);
  void MergeFrom(const ClientHeartbeatRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientHeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 job_client_id = 1;
  void clear_job_client_id();
  static const int kJobClientIdFieldNumber = 1;
  ::google::protobuf::int64 job_client_id() const;
  void set_job_client_id(::google::protobuf::int64 value);

  // int64 current_round = 2;
  private:
  bool has_current_round() const;
  public:
  void clear_current_round();
  static const int kCurrentRoundFieldNumber = 2;
  ::google::protobuf::int64 current_round() const;
  void set_current_round(::google::protobuf::int64 value);

  // int64 blocked_round = 4;
  private:
  bool has_blocked_round() const;
  public:
  void clear_blocked_round();
  static const int kBlockedRoundFieldNumber = 4;
  ::google::protobuf::int64 blocked_round() const;
  void set_blocked_round(::google::protobuf::int64 value);

  void clear_optional_current_round();
  OptionalCurrentRoundCase optional_current_round_case() const;
  void clear_optional_blocked_round();
  OptionalBlockedRoundCase optional_blocked_round_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.ClientHeartbeatRequest)
 private:
  void set_has_current_round();
  void set_has_blocked_round();

  inline bool has_optional_current_round() const;
  inline void clear_has_optional_current_round();

  inline bool has_optional_blocked_round() const;
  inline void clear_has_optional_blocked_round();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 job_client_id_;
  union OptionalCurrentRoundUnion {
    OptionalCurrentRoundUnion() {}
    ::google::protobuf::int64 current_round_;
  } optional_current_round_;
  union OptionalBlockedRoundUnion {
    OptionalBlockedRoundUnion() {}
    ::google::protobuf::int64 blocked_round_;
  } optional_blocked_round_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientHeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.ClientHeartbeatResponse) */ {
 public:
  ClientHeartbeatResponse();
  virtual ~ClientHeartbeatResponse();

  ClientHeartbeatResponse(const ClientHeartbeatResponse& from);

  inline ClientHeartbeatResponse& operator=(const ClientHeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientHeartbeatResponse(ClientHeartbeatResponse&& from) noexcept
    : ClientHeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline ClientHeartbeatResponse& operator=(ClientHeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientHeartbeatResponse& default_instance();

  enum OptionalBlockRoundCase {
    kBlockRound = 3,
    OPTIONAL_BLOCK_ROUND_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientHeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const ClientHeartbeatResponse*>(
               &_ClientHeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(ClientHeartbeatResponse* other);
  friend void swap(ClientHeartbeatResponse& a, ClientHeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientHeartbeatResponse* New() const final {
    return CreateMaybeMessage<ClientHeartbeatResponse>(NULL);
  }

  ClientHeartbeatResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientHeartbeatResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientHeartbeatResponse& from);
  void MergeFrom(const ClientHeartbeatResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientHeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.data.TaskInfo task_info = 1;
  int task_info_size() const;
  void clear_task_info();
  static const int kTaskInfoFieldNumber = 1;
  ::tensorflow::data::TaskInfo* mutable_task_info(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskInfo >*
      mutable_task_info();
  const ::tensorflow::data::TaskInfo& task_info(int index) const;
  ::tensorflow::data::TaskInfo* add_task_info();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskInfo >&
      task_info() const;

  // bool job_finished = 2;
  void clear_job_finished();
  static const int kJobFinishedFieldNumber = 2;
  bool job_finished() const;
  void set_job_finished(bool value);

  // .tensorflow.data.DeploymentMode deployment_mode = 4;
  void clear_deployment_mode();
  static const int kDeploymentModeFieldNumber = 4;
  ::tensorflow::data::DeploymentMode deployment_mode() const;
  void set_deployment_mode(::tensorflow::data::DeploymentMode value);

  // int64 block_round = 3;
  private:
  bool has_block_round() const;
  public:
  void clear_block_round();
  static const int kBlockRoundFieldNumber = 3;
  ::google::protobuf::int64 block_round() const;
  void set_block_round(::google::protobuf::int64 value);

  void clear_optional_block_round();
  OptionalBlockRoundCase optional_block_round_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.ClientHeartbeatResponse)
 private:
  void set_has_block_round();

  inline bool has_optional_block_round() const;
  inline void clear_has_optional_block_round();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskInfo > task_info_;
  bool job_finished_;
  int deployment_mode_;
  union OptionalBlockRoundUnion {
    OptionalBlockRoundUnion() {}
    ::google::protobuf::int64 block_round_;
  } optional_block_round_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WorkerInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.WorkerInfo) */ {
 public:
  WorkerInfo();
  virtual ~WorkerInfo();

  WorkerInfo(const WorkerInfo& from);

  inline WorkerInfo& operator=(const WorkerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WorkerInfo(WorkerInfo&& from) noexcept
    : WorkerInfo() {
    *this = ::std::move(from);
  }

  inline WorkerInfo& operator=(WorkerInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WorkerInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WorkerInfo* internal_default_instance() {
    return reinterpret_cast<const WorkerInfo*>(
               &_WorkerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(WorkerInfo* other);
  friend void swap(WorkerInfo& a, WorkerInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WorkerInfo* New() const final {
    return CreateMaybeMessage<WorkerInfo>(NULL);
  }

  WorkerInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WorkerInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WorkerInfo& from);
  void MergeFrom(const WorkerInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WorkerInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string address = 1;
  void clear_address();
  static const int kAddressFieldNumber = 1;
  const ::std::string& address() const;
  void set_address(const ::std::string& value);
  #if LANG_CXX11
  void set_address(::std::string&& value);
  #endif
  void set_address(const char* value);
  void set_address(const char* value, size_t size);
  ::std::string* mutable_address();
  ::std::string* release_address();
  void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:tensorflow.data.WorkerInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr address_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetWorkersRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetWorkersRequest) */ {
 public:
  GetWorkersRequest();
  virtual ~GetWorkersRequest();

  GetWorkersRequest(const GetWorkersRequest& from);

  inline GetWorkersRequest& operator=(const GetWorkersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetWorkersRequest(GetWorkersRequest&& from) noexcept
    : GetWorkersRequest() {
    *this = ::std::move(from);
  }

  inline GetWorkersRequest& operator=(GetWorkersRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWorkersRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetWorkersRequest* internal_default_instance() {
    return reinterpret_cast<const GetWorkersRequest*>(
               &_GetWorkersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(GetWorkersRequest* other);
  friend void swap(GetWorkersRequest& a, GetWorkersRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetWorkersRequest* New() const final {
    return CreateMaybeMessage<GetWorkersRequest>(NULL);
  }

  GetWorkersRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetWorkersRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetWorkersRequest& from);
  void MergeFrom(const GetWorkersRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkersRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetWorkersRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetWorkersResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GetWorkersResponse) */ {
 public:
  GetWorkersResponse();
  virtual ~GetWorkersResponse();

  GetWorkersResponse(const GetWorkersResponse& from);

  inline GetWorkersResponse& operator=(const GetWorkersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetWorkersResponse(GetWorkersResponse&& from) noexcept
    : GetWorkersResponse() {
    *this = ::std::move(from);
  }

  inline GetWorkersResponse& operator=(GetWorkersResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWorkersResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetWorkersResponse* internal_default_instance() {
    return reinterpret_cast<const GetWorkersResponse*>(
               &_GetWorkersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(GetWorkersResponse* other);
  friend void swap(GetWorkersResponse& a, GetWorkersResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetWorkersResponse* New() const final {
    return CreateMaybeMessage<GetWorkersResponse>(NULL);
  }

  GetWorkersResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetWorkersResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetWorkersResponse& from);
  void MergeFrom(const GetWorkersResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWorkersResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.data.WorkerInfo workers = 1;
  int workers_size() const;
  void clear_workers();
  static const int kWorkersFieldNumber = 1;
  ::tensorflow::data::WorkerInfo* mutable_workers(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::data::WorkerInfo >*
      mutable_workers();
  const ::tensorflow::data::WorkerInfo& workers(int index) const;
  ::tensorflow::data::WorkerInfo* add_workers();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::data::WorkerInfo >&
      workers() const;

  // @@protoc_insertion_point(class_scope:tensorflow.data.GetWorkersResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::data::WorkerInfo > workers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// TaskProgress

// int64 task_id = 1;
inline void TaskProgress::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskProgress::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskProgress.task_id)
  return task_id_;
}
inline void TaskProgress::set_task_id(::google::protobuf::int64 value) {
  
  task_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskProgress.task_id)
}

// bool completed = 2;
inline void TaskProgress::clear_completed() {
  completed_ = false;
}
inline bool TaskProgress::completed() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskProgress.completed)
  return completed_;
}
inline void TaskProgress::set_completed(bool value) {
  
  completed_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskProgress.completed)
}

// -------------------------------------------------------------------

// WorkerHeartbeatRequest

// string worker_address = 1;
inline void WorkerHeartbeatRequest::clear_worker_address() {
  worker_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerHeartbeatRequest::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.WorkerHeartbeatRequest.worker_address)
  return worker_address_.GetNoArena();
}
inline void WorkerHeartbeatRequest::set_worker_address(const ::std::string& value) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.WorkerHeartbeatRequest.worker_address)
}
#if LANG_CXX11
inline void WorkerHeartbeatRequest::set_worker_address(::std::string&& value) {
  
  worker_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.WorkerHeartbeatRequest.worker_address)
}
#endif
inline void WorkerHeartbeatRequest::set_worker_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.WorkerHeartbeatRequest.worker_address)
}
inline void WorkerHeartbeatRequest::set_worker_address(const char* value, size_t size) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.WorkerHeartbeatRequest.worker_address)
}
inline ::std::string* WorkerHeartbeatRequest::mutable_worker_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.WorkerHeartbeatRequest.worker_address)
  return worker_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerHeartbeatRequest::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.WorkerHeartbeatRequest.worker_address)
  
  return worker_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerHeartbeatRequest::set_allocated_worker_address(::std::string* worker_address) {
  if (worker_address != NULL) {
    
  } else {
    
  }
  worker_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worker_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.WorkerHeartbeatRequest.worker_address)
}

// string transfer_address = 3;
inline void WorkerHeartbeatRequest::clear_transfer_address() {
  transfer_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerHeartbeatRequest::transfer_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.WorkerHeartbeatRequest.transfer_address)
  return transfer_address_.GetNoArena();
}
inline void WorkerHeartbeatRequest::set_transfer_address(const ::std::string& value) {
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.WorkerHeartbeatRequest.transfer_address)
}
#if LANG_CXX11
inline void WorkerHeartbeatRequest::set_transfer_address(::std::string&& value) {
  
  transfer_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.WorkerHeartbeatRequest.transfer_address)
}
#endif
inline void WorkerHeartbeatRequest::set_transfer_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.WorkerHeartbeatRequest.transfer_address)
}
inline void WorkerHeartbeatRequest::set_transfer_address(const char* value, size_t size) {
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.WorkerHeartbeatRequest.transfer_address)
}
inline ::std::string* WorkerHeartbeatRequest::mutable_transfer_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.WorkerHeartbeatRequest.transfer_address)
  return transfer_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerHeartbeatRequest::release_transfer_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.WorkerHeartbeatRequest.transfer_address)
  
  return transfer_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerHeartbeatRequest::set_allocated_transfer_address(::std::string* transfer_address) {
  if (transfer_address != NULL) {
    
  } else {
    
  }
  transfer_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transfer_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.WorkerHeartbeatRequest.transfer_address)
}

// repeated string worker_tags = 4;
inline int WorkerHeartbeatRequest::worker_tags_size() const {
  return worker_tags_.size();
}
inline void WorkerHeartbeatRequest::clear_worker_tags() {
  worker_tags_.Clear();
}
inline const ::std::string& WorkerHeartbeatRequest::worker_tags(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
  return worker_tags_.Get(index);
}
inline ::std::string* WorkerHeartbeatRequest::mutable_worker_tags(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
  return worker_tags_.Mutable(index);
}
inline void WorkerHeartbeatRequest::set_worker_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
  worker_tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void WorkerHeartbeatRequest::set_worker_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
  worker_tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void WorkerHeartbeatRequest::set_worker_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  worker_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
}
inline void WorkerHeartbeatRequest::set_worker_tags(int index, const char* value, size_t size) {
  worker_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
}
inline ::std::string* WorkerHeartbeatRequest::add_worker_tags() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
  return worker_tags_.Add();
}
inline void WorkerHeartbeatRequest::add_worker_tags(const ::std::string& value) {
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
}
#if LANG_CXX11
inline void WorkerHeartbeatRequest::add_worker_tags(::std::string&& value) {
  worker_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
}
#endif
inline void WorkerHeartbeatRequest::add_worker_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
}
inline void WorkerHeartbeatRequest::add_worker_tags(const char* value, size_t size) {
  worker_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WorkerHeartbeatRequest::worker_tags() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
  return worker_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WorkerHeartbeatRequest::mutable_worker_tags() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.WorkerHeartbeatRequest.worker_tags)
  return &worker_tags_;
}

// int64 worker_uid = 5;
inline void WorkerHeartbeatRequest::clear_worker_uid() {
  worker_uid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WorkerHeartbeatRequest::worker_uid() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.WorkerHeartbeatRequest.worker_uid)
  return worker_uid_;
}
inline void WorkerHeartbeatRequest::set_worker_uid(::google::protobuf::int64 value) {
  
  worker_uid_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.WorkerHeartbeatRequest.worker_uid)
}

// repeated int64 current_tasks = 2;
inline int WorkerHeartbeatRequest::current_tasks_size() const {
  return current_tasks_.size();
}
inline void WorkerHeartbeatRequest::clear_current_tasks() {
  current_tasks_.Clear();
}
inline ::google::protobuf::int64 WorkerHeartbeatRequest::current_tasks(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.WorkerHeartbeatRequest.current_tasks)
  return current_tasks_.Get(index);
}
inline void WorkerHeartbeatRequest::set_current_tasks(int index, ::google::protobuf::int64 value) {
  current_tasks_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.data.WorkerHeartbeatRequest.current_tasks)
}
inline void WorkerHeartbeatRequest::add_current_tasks(::google::protobuf::int64 value) {
  current_tasks_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.data.WorkerHeartbeatRequest.current_tasks)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
WorkerHeartbeatRequest::current_tasks() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.WorkerHeartbeatRequest.current_tasks)
  return current_tasks_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
WorkerHeartbeatRequest::mutable_current_tasks() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.WorkerHeartbeatRequest.current_tasks)
  return &current_tasks_;
}

// -------------------------------------------------------------------

// WorkerHeartbeatResponse

// repeated .tensorflow.data.TaskDef new_tasks = 1;
inline int WorkerHeartbeatResponse::new_tasks_size() const {
  return new_tasks_.size();
}
inline ::tensorflow::data::TaskDef* WorkerHeartbeatResponse::mutable_new_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.WorkerHeartbeatResponse.new_tasks)
  return new_tasks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskDef >*
WorkerHeartbeatResponse::mutable_new_tasks() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.WorkerHeartbeatResponse.new_tasks)
  return &new_tasks_;
}
inline const ::tensorflow::data::TaskDef& WorkerHeartbeatResponse::new_tasks(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.WorkerHeartbeatResponse.new_tasks)
  return new_tasks_.Get(index);
}
inline ::tensorflow::data::TaskDef* WorkerHeartbeatResponse::add_new_tasks() {
  // @@protoc_insertion_point(field_add:tensorflow.data.WorkerHeartbeatResponse.new_tasks)
  return new_tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskDef >&
WorkerHeartbeatResponse::new_tasks() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.WorkerHeartbeatResponse.new_tasks)
  return new_tasks_;
}

// repeated int64 tasks_to_delete = 2;
inline int WorkerHeartbeatResponse::tasks_to_delete_size() const {
  return tasks_to_delete_.size();
}
inline void WorkerHeartbeatResponse::clear_tasks_to_delete() {
  tasks_to_delete_.Clear();
}
inline ::google::protobuf::int64 WorkerHeartbeatResponse::tasks_to_delete(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.WorkerHeartbeatResponse.tasks_to_delete)
  return tasks_to_delete_.Get(index);
}
inline void WorkerHeartbeatResponse::set_tasks_to_delete(int index, ::google::protobuf::int64 value) {
  tasks_to_delete_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.data.WorkerHeartbeatResponse.tasks_to_delete)
}
inline void WorkerHeartbeatResponse::add_tasks_to_delete(::google::protobuf::int64 value) {
  tasks_to_delete_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.data.WorkerHeartbeatResponse.tasks_to_delete)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
WorkerHeartbeatResponse::tasks_to_delete() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.WorkerHeartbeatResponse.tasks_to_delete)
  return tasks_to_delete_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
WorkerHeartbeatResponse::mutable_tasks_to_delete() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.WorkerHeartbeatResponse.tasks_to_delete)
  return &tasks_to_delete_;
}

// -------------------------------------------------------------------

// WorkerUpdateRequest

// string worker_address = 1;
inline void WorkerUpdateRequest::clear_worker_address() {
  worker_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerUpdateRequest::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.WorkerUpdateRequest.worker_address)
  return worker_address_.GetNoArena();
}
inline void WorkerUpdateRequest::set_worker_address(const ::std::string& value) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.WorkerUpdateRequest.worker_address)
}
#if LANG_CXX11
inline void WorkerUpdateRequest::set_worker_address(::std::string&& value) {
  
  worker_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.WorkerUpdateRequest.worker_address)
}
#endif
inline void WorkerUpdateRequest::set_worker_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.WorkerUpdateRequest.worker_address)
}
inline void WorkerUpdateRequest::set_worker_address(const char* value, size_t size) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.WorkerUpdateRequest.worker_address)
}
inline ::std::string* WorkerUpdateRequest::mutable_worker_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.WorkerUpdateRequest.worker_address)
  return worker_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerUpdateRequest::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.WorkerUpdateRequest.worker_address)
  
  return worker_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerUpdateRequest::set_allocated_worker_address(::std::string* worker_address) {
  if (worker_address != NULL) {
    
  } else {
    
  }
  worker_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worker_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.WorkerUpdateRequest.worker_address)
}

// repeated .tensorflow.data.TaskProgress updates = 2;
inline int WorkerUpdateRequest::updates_size() const {
  return updates_.size();
}
inline void WorkerUpdateRequest::clear_updates() {
  updates_.Clear();
}
inline ::tensorflow::data::TaskProgress* WorkerUpdateRequest::mutable_updates(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.WorkerUpdateRequest.updates)
  return updates_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskProgress >*
WorkerUpdateRequest::mutable_updates() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.WorkerUpdateRequest.updates)
  return &updates_;
}
inline const ::tensorflow::data::TaskProgress& WorkerUpdateRequest::updates(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.WorkerUpdateRequest.updates)
  return updates_.Get(index);
}
inline ::tensorflow::data::TaskProgress* WorkerUpdateRequest::add_updates() {
  // @@protoc_insertion_point(field_add:tensorflow.data.WorkerUpdateRequest.updates)
  return updates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskProgress >&
WorkerUpdateRequest::updates() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.WorkerUpdateRequest.updates)
  return updates_;
}

// -------------------------------------------------------------------

// WorkerUpdateResponse

// -------------------------------------------------------------------

// GetDatasetDefRequest

// int64 dataset_id = 1;
inline void GetDatasetDefRequest::clear_dataset_id() {
  dataset_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetDatasetDefRequest::dataset_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetDatasetDefRequest.dataset_id)
  return dataset_id_;
}
inline void GetDatasetDefRequest::set_dataset_id(::google::protobuf::int64 value) {
  
  dataset_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetDatasetDefRequest.dataset_id)
}

// -------------------------------------------------------------------

// GetDatasetDefResponse

// .tensorflow.data.DatasetDef dataset_def = 1;
inline bool GetDatasetDefResponse::has_dataset_def() const {
  return this != internal_default_instance() && dataset_def_ != NULL;
}
inline const ::tensorflow::data::DatasetDef& GetDatasetDefResponse::_internal_dataset_def() const {
  return *dataset_def_;
}
inline const ::tensorflow::data::DatasetDef& GetDatasetDefResponse::dataset_def() const {
  const ::tensorflow::data::DatasetDef* p = dataset_def_;
  // @@protoc_insertion_point(field_get:tensorflow.data.GetDatasetDefResponse.dataset_def)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::DatasetDef*>(
      &::tensorflow::data::_DatasetDef_default_instance_);
}
inline ::tensorflow::data::DatasetDef* GetDatasetDefResponse::release_dataset_def() {
  // @@protoc_insertion_point(field_release:tensorflow.data.GetDatasetDefResponse.dataset_def)
  
  ::tensorflow::data::DatasetDef* temp = dataset_def_;
  dataset_def_ = NULL;
  return temp;
}
inline ::tensorflow::data::DatasetDef* GetDatasetDefResponse::mutable_dataset_def() {
  
  if (dataset_def_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::DatasetDef>(GetArenaNoVirtual());
    dataset_def_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.GetDatasetDefResponse.dataset_def)
  return dataset_def_;
}
inline void GetDatasetDefResponse::set_allocated_dataset_def(::tensorflow::data::DatasetDef* dataset_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dataset_def_);
  }
  if (dataset_def) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dataset_def = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dataset_def, submessage_arena);
    }
    
  } else {
    
  }
  dataset_def_ = dataset_def;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.GetDatasetDefResponse.dataset_def)
}

// -------------------------------------------------------------------

// GetSplitRequest

// int64 job_id = 1;
inline void GetSplitRequest::clear_job_id() {
  job_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetSplitRequest::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetSplitRequest.job_id)
  return job_id_;
}
inline void GetSplitRequest::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetSplitRequest.job_id)
}

// int64 iteration = 2;
inline void GetSplitRequest::clear_iteration() {
  iteration_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetSplitRequest::iteration() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetSplitRequest.iteration)
  return iteration_;
}
inline void GetSplitRequest::set_iteration(::google::protobuf::int64 value) {
  
  iteration_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetSplitRequest.iteration)
}

// int64 split_provider_index = 3;
inline void GetSplitRequest::clear_split_provider_index() {
  split_provider_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetSplitRequest::split_provider_index() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetSplitRequest.split_provider_index)
  return split_provider_index_;
}
inline void GetSplitRequest::set_split_provider_index(::google::protobuf::int64 value) {
  
  split_provider_index_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetSplitRequest.split_provider_index)
}

// -------------------------------------------------------------------

// GetSplitResponse

// .tensorflow.TensorProto split = 1;
inline bool GetSplitResponse::has_split() const {
  return this != internal_default_instance() && split_ != NULL;
}
inline const ::tensorflow::TensorProto& GetSplitResponse::_internal_split() const {
  return *split_;
}
inline const ::tensorflow::TensorProto& GetSplitResponse::split() const {
  const ::tensorflow::TensorProto* p = split_;
  // @@protoc_insertion_point(field_get:tensorflow.data.GetSplitResponse.split)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::TensorProto*>(
      &::tensorflow::_TensorProto_default_instance_);
}
inline ::tensorflow::TensorProto* GetSplitResponse::release_split() {
  // @@protoc_insertion_point(field_release:tensorflow.data.GetSplitResponse.split)
  
  ::tensorflow::TensorProto* temp = split_;
  split_ = NULL;
  return temp;
}
inline ::tensorflow::TensorProto* GetSplitResponse::mutable_split() {
  
  if (split_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::TensorProto>(GetArenaNoVirtual());
    split_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.GetSplitResponse.split)
  return split_;
}
inline void GetSplitResponse::set_allocated_split(::tensorflow::TensorProto* split) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(split_);
  }
  if (split) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(split)->GetArena();
    if (message_arena != submessage_arena) {
      split = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, split, submessage_arena);
    }
    
  } else {
    
  }
  split_ = split;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.GetSplitResponse.split)
}

// bool end_of_splits = 2;
inline void GetSplitResponse::clear_end_of_splits() {
  end_of_splits_ = false;
}
inline bool GetSplitResponse::end_of_splits() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetSplitResponse.end_of_splits)
  return end_of_splits_;
}
inline void GetSplitResponse::set_end_of_splits(bool value) {
  
  end_of_splits_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetSplitResponse.end_of_splits)
}

// -------------------------------------------------------------------

// GetVersionRequest

// -------------------------------------------------------------------

// GetVersionResponse

// int64 version = 1;
inline void GetVersionResponse::clear_version() {
  version_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetVersionResponse::version() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetVersionResponse.version)
  return version_;
}
inline void GetVersionResponse::set_version(::google::protobuf::int64 value) {
  
  version_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetVersionResponse.version)
}

// -------------------------------------------------------------------

// GetOrRegisterDatasetRequest

// .tensorflow.data.DatasetDef dataset = 1;
inline bool GetOrRegisterDatasetRequest::has_dataset() const {
  return this != internal_default_instance() && dataset_ != NULL;
}
inline const ::tensorflow::data::DatasetDef& GetOrRegisterDatasetRequest::_internal_dataset() const {
  return *dataset_;
}
inline const ::tensorflow::data::DatasetDef& GetOrRegisterDatasetRequest::dataset() const {
  const ::tensorflow::data::DatasetDef* p = dataset_;
  // @@protoc_insertion_point(field_get:tensorflow.data.GetOrRegisterDatasetRequest.dataset)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::DatasetDef*>(
      &::tensorflow::data::_DatasetDef_default_instance_);
}
inline ::tensorflow::data::DatasetDef* GetOrRegisterDatasetRequest::release_dataset() {
  // @@protoc_insertion_point(field_release:tensorflow.data.GetOrRegisterDatasetRequest.dataset)
  
  ::tensorflow::data::DatasetDef* temp = dataset_;
  dataset_ = NULL;
  return temp;
}
inline ::tensorflow::data::DatasetDef* GetOrRegisterDatasetRequest::mutable_dataset() {
  
  if (dataset_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::DatasetDef>(GetArenaNoVirtual());
    dataset_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.GetOrRegisterDatasetRequest.dataset)
  return dataset_;
}
inline void GetOrRegisterDatasetRequest::set_allocated_dataset(::tensorflow::data::DatasetDef* dataset) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(dataset_);
  }
  if (dataset) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      dataset = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, dataset, submessage_arena);
    }
    
  } else {
    
  }
  dataset_ = dataset;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.GetOrRegisterDatasetRequest.dataset)
}

// .tensorflow.data.DataServiceMetadata metadata = 3;
inline bool GetOrRegisterDatasetRequest::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline const ::tensorflow::data::DataServiceMetadata& GetOrRegisterDatasetRequest::_internal_metadata() const {
  return *metadata_;
}
inline const ::tensorflow::data::DataServiceMetadata& GetOrRegisterDatasetRequest::metadata() const {
  const ::tensorflow::data::DataServiceMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:tensorflow.data.GetOrRegisterDatasetRequest.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::DataServiceMetadata*>(
      &::tensorflow::data::_DataServiceMetadata_default_instance_);
}
inline ::tensorflow::data::DataServiceMetadata* GetOrRegisterDatasetRequest::release_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.data.GetOrRegisterDatasetRequest.metadata)
  
  ::tensorflow::data::DataServiceMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::tensorflow::data::DataServiceMetadata* GetOrRegisterDatasetRequest::mutable_metadata() {
  
  if (metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::DataServiceMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.GetOrRegisterDatasetRequest.metadata)
  return metadata_;
}
inline void GetOrRegisterDatasetRequest::set_allocated_metadata(::tensorflow::data::DataServiceMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.GetOrRegisterDatasetRequest.metadata)
}

// -------------------------------------------------------------------

// GetOrRegisterDatasetResponse

// int64 dataset_id = 1;
inline void GetOrRegisterDatasetResponse::clear_dataset_id() {
  dataset_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetOrRegisterDatasetResponse::dataset_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetOrRegisterDatasetResponse.dataset_id)
  return dataset_id_;
}
inline void GetOrRegisterDatasetResponse::set_dataset_id(::google::protobuf::int64 value) {
  
  dataset_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetOrRegisterDatasetResponse.dataset_id)
}

// -------------------------------------------------------------------

// GetDataServiceMetadataRequest

// int64 dataset_id = 1;
inline void GetDataServiceMetadataRequest::clear_dataset_id() {
  dataset_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetDataServiceMetadataRequest::dataset_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetDataServiceMetadataRequest.dataset_id)
  return dataset_id_;
}
inline void GetDataServiceMetadataRequest::set_dataset_id(::google::protobuf::int64 value) {
  
  dataset_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetDataServiceMetadataRequest.dataset_id)
}

// -------------------------------------------------------------------

// GetDataServiceMetadataResponse

// .tensorflow.data.DataServiceMetadata metadata = 1;
inline bool GetDataServiceMetadataResponse::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline const ::tensorflow::data::DataServiceMetadata& GetDataServiceMetadataResponse::_internal_metadata() const {
  return *metadata_;
}
inline const ::tensorflow::data::DataServiceMetadata& GetDataServiceMetadataResponse::metadata() const {
  const ::tensorflow::data::DataServiceMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:tensorflow.data.GetDataServiceMetadataResponse.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::DataServiceMetadata*>(
      &::tensorflow::data::_DataServiceMetadata_default_instance_);
}
inline ::tensorflow::data::DataServiceMetadata* GetDataServiceMetadataResponse::release_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.data.GetDataServiceMetadataResponse.metadata)
  
  ::tensorflow::data::DataServiceMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::tensorflow::data::DataServiceMetadata* GetDataServiceMetadataResponse::mutable_metadata() {
  
  if (metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::DataServiceMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.GetDataServiceMetadataResponse.metadata)
  return metadata_;
}
inline void GetDataServiceMetadataResponse::set_allocated_metadata(::tensorflow::data::DataServiceMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.GetDataServiceMetadataResponse.metadata)
}

// -------------------------------------------------------------------

// GetDataServiceConfigRequest

// -------------------------------------------------------------------

// GetDataServiceConfigResponse

// .tensorflow.data.DataServiceConfig config = 1;
inline bool GetDataServiceConfigResponse::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline const ::tensorflow::data::DataServiceConfig& GetDataServiceConfigResponse::_internal_config() const {
  return *config_;
}
inline const ::tensorflow::data::DataServiceConfig& GetDataServiceConfigResponse::config() const {
  const ::tensorflow::data::DataServiceConfig* p = config_;
  // @@protoc_insertion_point(field_get:tensorflow.data.GetDataServiceConfigResponse.config)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::DataServiceConfig*>(
      &::tensorflow::data::_DataServiceConfig_default_instance_);
}
inline ::tensorflow::data::DataServiceConfig* GetDataServiceConfigResponse::release_config() {
  // @@protoc_insertion_point(field_release:tensorflow.data.GetDataServiceConfigResponse.config)
  
  ::tensorflow::data::DataServiceConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::tensorflow::data::DataServiceConfig* GetDataServiceConfigResponse::mutable_config() {
  
  if (config_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::DataServiceConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.GetDataServiceConfigResponse.config)
  return config_;
}
inline void GetDataServiceConfigResponse::set_allocated_config(::tensorflow::data::DataServiceConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(config_);
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.GetDataServiceConfigResponse.config)
}

// -------------------------------------------------------------------

// GetOrCreateJobRequest

// int64 dataset_id = 1;
inline void GetOrCreateJobRequest::clear_dataset_id() {
  dataset_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetOrCreateJobRequest::dataset_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetOrCreateJobRequest.dataset_id)
  return dataset_id_;
}
inline void GetOrCreateJobRequest::set_dataset_id(::google::protobuf::int64 value) {
  
  dataset_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetOrCreateJobRequest.dataset_id)
}

// .tensorflow.data.ProcessingModeDef processing_mode_def = 8;
inline bool GetOrCreateJobRequest::has_processing_mode_def() const {
  return this != internal_default_instance() && processing_mode_def_ != NULL;
}
inline const ::tensorflow::data::ProcessingModeDef& GetOrCreateJobRequest::_internal_processing_mode_def() const {
  return *processing_mode_def_;
}
inline const ::tensorflow::data::ProcessingModeDef& GetOrCreateJobRequest::processing_mode_def() const {
  const ::tensorflow::data::ProcessingModeDef* p = processing_mode_def_;
  // @@protoc_insertion_point(field_get:tensorflow.data.GetOrCreateJobRequest.processing_mode_def)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::ProcessingModeDef*>(
      &::tensorflow::data::_ProcessingModeDef_default_instance_);
}
inline ::tensorflow::data::ProcessingModeDef* GetOrCreateJobRequest::release_processing_mode_def() {
  // @@protoc_insertion_point(field_release:tensorflow.data.GetOrCreateJobRequest.processing_mode_def)
  
  ::tensorflow::data::ProcessingModeDef* temp = processing_mode_def_;
  processing_mode_def_ = NULL;
  return temp;
}
inline ::tensorflow::data::ProcessingModeDef* GetOrCreateJobRequest::mutable_processing_mode_def() {
  
  if (processing_mode_def_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::ProcessingModeDef>(GetArenaNoVirtual());
    processing_mode_def_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.GetOrCreateJobRequest.processing_mode_def)
  return processing_mode_def_;
}
inline void GetOrCreateJobRequest::set_allocated_processing_mode_def(::tensorflow::data::ProcessingModeDef* processing_mode_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(processing_mode_def_);
  }
  if (processing_mode_def) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      processing_mode_def = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, processing_mode_def, submessage_arena);
    }
    
  } else {
    
  }
  processing_mode_def_ = processing_mode_def;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.GetOrCreateJobRequest.processing_mode_def)
}

// .tensorflow.data.JobKeyDef job_key = 5;
inline bool GetOrCreateJobRequest::has_job_key() const {
  return this != internal_default_instance() && job_key_ != NULL;
}
inline const ::tensorflow::data::JobKeyDef& GetOrCreateJobRequest::_internal_job_key() const {
  return *job_key_;
}
inline const ::tensorflow::data::JobKeyDef& GetOrCreateJobRequest::job_key() const {
  const ::tensorflow::data::JobKeyDef* p = job_key_;
  // @@protoc_insertion_point(field_get:tensorflow.data.GetOrCreateJobRequest.job_key)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::JobKeyDef*>(
      &::tensorflow::data::_JobKeyDef_default_instance_);
}
inline ::tensorflow::data::JobKeyDef* GetOrCreateJobRequest::release_job_key() {
  // @@protoc_insertion_point(field_release:tensorflow.data.GetOrCreateJobRequest.job_key)
  
  ::tensorflow::data::JobKeyDef* temp = job_key_;
  job_key_ = NULL;
  return temp;
}
inline ::tensorflow::data::JobKeyDef* GetOrCreateJobRequest::mutable_job_key() {
  
  if (job_key_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::JobKeyDef>(GetArenaNoVirtual());
    job_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.GetOrCreateJobRequest.job_key)
  return job_key_;
}
inline void GetOrCreateJobRequest::set_allocated_job_key(::tensorflow::data::JobKeyDef* job_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(job_key_);
  }
  if (job_key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      job_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, job_key, submessage_arena);
    }
    
  } else {
    
  }
  job_key_ = job_key;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.GetOrCreateJobRequest.job_key)
}

// int64 num_consumers = 7;
inline bool GetOrCreateJobRequest::has_num_consumers() const {
  return optional_num_consumers_case() == kNumConsumers;
}
inline void GetOrCreateJobRequest::set_has_num_consumers() {
  _oneof_case_[0] = kNumConsumers;
}
inline void GetOrCreateJobRequest::clear_num_consumers() {
  if (has_num_consumers()) {
    optional_num_consumers_.num_consumers_ = GOOGLE_LONGLONG(0);
    clear_has_optional_num_consumers();
  }
}
inline ::google::protobuf::int64 GetOrCreateJobRequest::num_consumers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetOrCreateJobRequest.num_consumers)
  if (has_num_consumers()) {
    return optional_num_consumers_.num_consumers_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void GetOrCreateJobRequest::set_num_consumers(::google::protobuf::int64 value) {
  if (!has_num_consumers()) {
    clear_optional_num_consumers();
    set_has_num_consumers();
  }
  optional_num_consumers_.num_consumers_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetOrCreateJobRequest.num_consumers)
}

// .tensorflow.data.TargetWorkers target_workers = 9;
inline void GetOrCreateJobRequest::clear_target_workers() {
  target_workers_ = 0;
}
inline ::tensorflow::data::TargetWorkers GetOrCreateJobRequest::target_workers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetOrCreateJobRequest.target_workers)
  return static_cast< ::tensorflow::data::TargetWorkers >(target_workers_);
}
inline void GetOrCreateJobRequest::set_target_workers(::tensorflow::data::TargetWorkers value) {
  
  target_workers_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetOrCreateJobRequest.target_workers)
}

inline bool GetOrCreateJobRequest::has_optional_num_consumers() const {
  return optional_num_consumers_case() != OPTIONAL_NUM_CONSUMERS_NOT_SET;
}
inline void GetOrCreateJobRequest::clear_has_optional_num_consumers() {
  _oneof_case_[0] = OPTIONAL_NUM_CONSUMERS_NOT_SET;
}
inline GetOrCreateJobRequest::OptionalNumConsumersCase GetOrCreateJobRequest::optional_num_consumers_case() const {
  return GetOrCreateJobRequest::OptionalNumConsumersCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// GetOrCreateJobResponse

// int64 job_client_id = 1;
inline void GetOrCreateJobResponse::clear_job_client_id() {
  job_client_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetOrCreateJobResponse::job_client_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetOrCreateJobResponse.job_client_id)
  return job_client_id_;
}
inline void GetOrCreateJobResponse::set_job_client_id(::google::protobuf::int64 value) {
  
  job_client_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GetOrCreateJobResponse.job_client_id)
}

// -------------------------------------------------------------------

// MaybeRemoveTaskRequest

// int64 task_id = 1;
inline void MaybeRemoveTaskRequest::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MaybeRemoveTaskRequest::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.MaybeRemoveTaskRequest.task_id)
  return task_id_;
}
inline void MaybeRemoveTaskRequest::set_task_id(::google::protobuf::int64 value) {
  
  task_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.MaybeRemoveTaskRequest.task_id)
}

// int64 consumer_index = 2;
inline void MaybeRemoveTaskRequest::clear_consumer_index() {
  consumer_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MaybeRemoveTaskRequest::consumer_index() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.MaybeRemoveTaskRequest.consumer_index)
  return consumer_index_;
}
inline void MaybeRemoveTaskRequest::set_consumer_index(::google::protobuf::int64 value) {
  
  consumer_index_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.MaybeRemoveTaskRequest.consumer_index)
}

// int64 round = 3;
inline void MaybeRemoveTaskRequest::clear_round() {
  round_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MaybeRemoveTaskRequest::round() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.MaybeRemoveTaskRequest.round)
  return round_;
}
inline void MaybeRemoveTaskRequest::set_round(::google::protobuf::int64 value) {
  
  round_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.MaybeRemoveTaskRequest.round)
}

// -------------------------------------------------------------------

// MaybeRemoveTaskResponse

// bool removed = 1;
inline void MaybeRemoveTaskResponse::clear_removed() {
  removed_ = false;
}
inline bool MaybeRemoveTaskResponse::removed() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.MaybeRemoveTaskResponse.removed)
  return removed_;
}
inline void MaybeRemoveTaskResponse::set_removed(bool value) {
  
  removed_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.MaybeRemoveTaskResponse.removed)
}

// -------------------------------------------------------------------

// ReleaseJobClientRequest

// int64 job_client_id = 1;
inline void ReleaseJobClientRequest::clear_job_client_id() {
  job_client_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReleaseJobClientRequest::job_client_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ReleaseJobClientRequest.job_client_id)
  return job_client_id_;
}
inline void ReleaseJobClientRequest::set_job_client_id(::google::protobuf::int64 value) {
  
  job_client_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ReleaseJobClientRequest.job_client_id)
}

// -------------------------------------------------------------------

// ReleaseJobClientResponse

// -------------------------------------------------------------------

// ClientHeartbeatRequest

// int64 job_client_id = 1;
inline void ClientHeartbeatRequest::clear_job_client_id() {
  job_client_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ClientHeartbeatRequest::job_client_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ClientHeartbeatRequest.job_client_id)
  return job_client_id_;
}
inline void ClientHeartbeatRequest::set_job_client_id(::google::protobuf::int64 value) {
  
  job_client_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ClientHeartbeatRequest.job_client_id)
}

// int64 current_round = 2;
inline bool ClientHeartbeatRequest::has_current_round() const {
  return optional_current_round_case() == kCurrentRound;
}
inline void ClientHeartbeatRequest::set_has_current_round() {
  _oneof_case_[0] = kCurrentRound;
}
inline void ClientHeartbeatRequest::clear_current_round() {
  if (has_current_round()) {
    optional_current_round_.current_round_ = GOOGLE_LONGLONG(0);
    clear_has_optional_current_round();
  }
}
inline ::google::protobuf::int64 ClientHeartbeatRequest::current_round() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ClientHeartbeatRequest.current_round)
  if (has_current_round()) {
    return optional_current_round_.current_round_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void ClientHeartbeatRequest::set_current_round(::google::protobuf::int64 value) {
  if (!has_current_round()) {
    clear_optional_current_round();
    set_has_current_round();
  }
  optional_current_round_.current_round_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ClientHeartbeatRequest.current_round)
}

// int64 blocked_round = 4;
inline bool ClientHeartbeatRequest::has_blocked_round() const {
  return optional_blocked_round_case() == kBlockedRound;
}
inline void ClientHeartbeatRequest::set_has_blocked_round() {
  _oneof_case_[1] = kBlockedRound;
}
inline void ClientHeartbeatRequest::clear_blocked_round() {
  if (has_blocked_round()) {
    optional_blocked_round_.blocked_round_ = GOOGLE_LONGLONG(0);
    clear_has_optional_blocked_round();
  }
}
inline ::google::protobuf::int64 ClientHeartbeatRequest::blocked_round() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ClientHeartbeatRequest.blocked_round)
  if (has_blocked_round()) {
    return optional_blocked_round_.blocked_round_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void ClientHeartbeatRequest::set_blocked_round(::google::protobuf::int64 value) {
  if (!has_blocked_round()) {
    clear_optional_blocked_round();
    set_has_blocked_round();
  }
  optional_blocked_round_.blocked_round_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ClientHeartbeatRequest.blocked_round)
}

inline bool ClientHeartbeatRequest::has_optional_current_round() const {
  return optional_current_round_case() != OPTIONAL_CURRENT_ROUND_NOT_SET;
}
inline void ClientHeartbeatRequest::clear_has_optional_current_round() {
  _oneof_case_[0] = OPTIONAL_CURRENT_ROUND_NOT_SET;
}
inline bool ClientHeartbeatRequest::has_optional_blocked_round() const {
  return optional_blocked_round_case() != OPTIONAL_BLOCKED_ROUND_NOT_SET;
}
inline void ClientHeartbeatRequest::clear_has_optional_blocked_round() {
  _oneof_case_[1] = OPTIONAL_BLOCKED_ROUND_NOT_SET;
}
inline ClientHeartbeatRequest::OptionalCurrentRoundCase ClientHeartbeatRequest::optional_current_round_case() const {
  return ClientHeartbeatRequest::OptionalCurrentRoundCase(_oneof_case_[0]);
}
inline ClientHeartbeatRequest::OptionalBlockedRoundCase ClientHeartbeatRequest::optional_blocked_round_case() const {
  return ClientHeartbeatRequest::OptionalBlockedRoundCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// ClientHeartbeatResponse

// repeated .tensorflow.data.TaskInfo task_info = 1;
inline int ClientHeartbeatResponse::task_info_size() const {
  return task_info_.size();
}
inline ::tensorflow::data::TaskInfo* ClientHeartbeatResponse::mutable_task_info(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.ClientHeartbeatResponse.task_info)
  return task_info_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskInfo >*
ClientHeartbeatResponse::mutable_task_info() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.ClientHeartbeatResponse.task_info)
  return &task_info_;
}
inline const ::tensorflow::data::TaskInfo& ClientHeartbeatResponse::task_info(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ClientHeartbeatResponse.task_info)
  return task_info_.Get(index);
}
inline ::tensorflow::data::TaskInfo* ClientHeartbeatResponse::add_task_info() {
  // @@protoc_insertion_point(field_add:tensorflow.data.ClientHeartbeatResponse.task_info)
  return task_info_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::data::TaskInfo >&
ClientHeartbeatResponse::task_info() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.ClientHeartbeatResponse.task_info)
  return task_info_;
}

// int64 block_round = 3;
inline bool ClientHeartbeatResponse::has_block_round() const {
  return optional_block_round_case() == kBlockRound;
}
inline void ClientHeartbeatResponse::set_has_block_round() {
  _oneof_case_[0] = kBlockRound;
}
inline void ClientHeartbeatResponse::clear_block_round() {
  if (has_block_round()) {
    optional_block_round_.block_round_ = GOOGLE_LONGLONG(0);
    clear_has_optional_block_round();
  }
}
inline ::google::protobuf::int64 ClientHeartbeatResponse::block_round() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ClientHeartbeatResponse.block_round)
  if (has_block_round()) {
    return optional_block_round_.block_round_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void ClientHeartbeatResponse::set_block_round(::google::protobuf::int64 value) {
  if (!has_block_round()) {
    clear_optional_block_round();
    set_has_block_round();
  }
  optional_block_round_.block_round_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ClientHeartbeatResponse.block_round)
}

// bool job_finished = 2;
inline void ClientHeartbeatResponse::clear_job_finished() {
  job_finished_ = false;
}
inline bool ClientHeartbeatResponse::job_finished() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ClientHeartbeatResponse.job_finished)
  return job_finished_;
}
inline void ClientHeartbeatResponse::set_job_finished(bool value) {
  
  job_finished_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ClientHeartbeatResponse.job_finished)
}

// .tensorflow.data.DeploymentMode deployment_mode = 4;
inline void ClientHeartbeatResponse::clear_deployment_mode() {
  deployment_mode_ = 0;
}
inline ::tensorflow::data::DeploymentMode ClientHeartbeatResponse::deployment_mode() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ClientHeartbeatResponse.deployment_mode)
  return static_cast< ::tensorflow::data::DeploymentMode >(deployment_mode_);
}
inline void ClientHeartbeatResponse::set_deployment_mode(::tensorflow::data::DeploymentMode value) {
  
  deployment_mode_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ClientHeartbeatResponse.deployment_mode)
}

inline bool ClientHeartbeatResponse::has_optional_block_round() const {
  return optional_block_round_case() != OPTIONAL_BLOCK_ROUND_NOT_SET;
}
inline void ClientHeartbeatResponse::clear_has_optional_block_round() {
  _oneof_case_[0] = OPTIONAL_BLOCK_ROUND_NOT_SET;
}
inline ClientHeartbeatResponse::OptionalBlockRoundCase ClientHeartbeatResponse::optional_block_round_case() const {
  return ClientHeartbeatResponse::OptionalBlockRoundCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// WorkerInfo

// string address = 1;
inline void WorkerInfo::clear_address() {
  address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WorkerInfo::address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.WorkerInfo.address)
  return address_.GetNoArena();
}
inline void WorkerInfo::set_address(const ::std::string& value) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.WorkerInfo.address)
}
#if LANG_CXX11
inline void WorkerInfo::set_address(::std::string&& value) {
  
  address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.WorkerInfo.address)
}
#endif
inline void WorkerInfo::set_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.WorkerInfo.address)
}
inline void WorkerInfo::set_address(const char* value, size_t size) {
  
  address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.WorkerInfo.address)
}
inline ::std::string* WorkerInfo::mutable_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.WorkerInfo.address)
  return address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WorkerInfo::release_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.WorkerInfo.address)
  
  return address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WorkerInfo::set_allocated_address(::std::string* address) {
  if (address != NULL) {
    
  } else {
    
  }
  address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.WorkerInfo.address)
}

// -------------------------------------------------------------------

// GetWorkersRequest

// -------------------------------------------------------------------

// GetWorkersResponse

// repeated .tensorflow.data.WorkerInfo workers = 1;
inline int GetWorkersResponse::workers_size() const {
  return workers_.size();
}
inline void GetWorkersResponse::clear_workers() {
  workers_.Clear();
}
inline ::tensorflow::data::WorkerInfo* GetWorkersResponse::mutable_workers(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.GetWorkersResponse.workers)
  return workers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::data::WorkerInfo >*
GetWorkersResponse::mutable_workers() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.GetWorkersResponse.workers)
  return &workers_;
}
inline const ::tensorflow::data::WorkerInfo& GetWorkersResponse::workers(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GetWorkersResponse.workers)
  return workers_.Get(index);
}
inline ::tensorflow::data::WorkerInfo* GetWorkersResponse::add_workers() {
  // @@protoc_insertion_point(field_add:tensorflow.data.GetWorkersResponse.workers)
  return workers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::data::WorkerInfo >&
GetWorkersResponse::workers() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.GetWorkersResponse.workers)
  return workers_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace data
}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto
