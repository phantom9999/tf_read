// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: tensorflow/core/data/service/dispatcher.proto
#ifndef GRPC_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto__INCLUDED
#define GRPC_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto__INCLUDED

#include "tensorflow/core/data/service/dispatcher.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace tensorflow {
namespace data {

class DispatcherService final {
 public:
  static constexpr char const* service_full_name() {
    return "tensorflow.data.DispatcherService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Performs a periodic worker heartbeat.
    virtual ::grpc::Status WorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::tensorflow::data::WorkerHeartbeatResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>> AsyncWorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>>(AsyncWorkerHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>> PrepareAsyncWorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>>(PrepareAsyncWorkerHeartbeatRaw(context, request, cq));
    }
    // Updates the dispatcher with information about the worker's state.
    virtual ::grpc::Status WorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::tensorflow::data::WorkerUpdateResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>> AsyncWorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>>(AsyncWorkerUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>> PrepareAsyncWorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>>(PrepareAsyncWorkerUpdateRaw(context, request, cq));
    }
    // Gets a dataset defintion.
    virtual ::grpc::Status GetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::tensorflow::data::GetDatasetDefResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>> AsyncGetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>>(AsyncGetDatasetDefRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>> PrepareAsyncGetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>>(PrepareAsyncGetDatasetDefRaw(context, request, cq));
    }
    // Gets the next split for a given job.
    virtual ::grpc::Status GetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::tensorflow::data::GetSplitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>> AsyncGetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>>(AsyncGetSplitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>> PrepareAsyncGetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>>(PrepareAsyncGetSplitRaw(context, request, cq));
    }
    // Returns the API version of the server.
    virtual ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::tensorflow::data::GetVersionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    // Registers a dataset with the server, or returns its id if it is already
    // registered.
    //
    // The dataset is constructed in a new graph, so it must not refer to
    // external resources or variables.
    virtual ::grpc::Status GetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::tensorflow::data::GetOrRegisterDatasetResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>> AsyncGetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>>(AsyncGetOrRegisterDatasetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>> PrepareAsyncGetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>>(PrepareAsyncGetOrRegisterDatasetRaw(context, request, cq));
    }
    // Gets a job if it already exists, otherwise creates it.
    virtual ::grpc::Status GetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::tensorflow::data::GetOrCreateJobResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>> AsyncGetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>>(AsyncGetOrCreateJobRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>> PrepareAsyncGetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>>(PrepareAsyncGetOrCreateJobRaw(context, request, cq));
    }
    // Attempts to remove a task from a round-robin read job.
    virtual ::grpc::Status MaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::tensorflow::data::MaybeRemoveTaskResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>> AsyncMaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>>(AsyncMaybeRemoveTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>> PrepareAsyncMaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>>(PrepareAsyncMaybeRemoveTaskRaw(context, request, cq));
    }
    // Releases a job client so that a job may eventually be cleaned up.
    virtual ::grpc::Status ReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::tensorflow::data::ReleaseJobClientResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>> AsyncReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>>(AsyncReleaseJobClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>> PrepareAsyncReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>>(PrepareAsyncReleaseJobClientRaw(context, request, cq));
    }
    // Heartbeats from the client. This lets the dispatcher know that the client
    // is still active, and gives the dispatcher a chance to notify the client
    // of new tasks.
    virtual ::grpc::Status ClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::tensorflow::data::ClientHeartbeatResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>> AsyncClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>>(AsyncClientHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>> PrepareAsyncClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>>(PrepareAsyncClientHeartbeatRaw(context, request, cq));
    }
    // Reports a list of all workers registered with the dispatcher.
    virtual ::grpc::Status GetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::tensorflow::data::GetWorkersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>> AsyncGetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>>(AsyncGetWorkersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>> PrepareAsyncGetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>>(PrepareAsyncGetWorkersRaw(context, request, cq));
    }
    // Returns the data service metadata for the registered dataset.
    virtual ::grpc::Status GetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::tensorflow::data::GetDataServiceMetadataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>> AsyncGetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>>(AsyncGetDataServiceMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>> PrepareAsyncGetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>>(PrepareAsyncGetDataServiceMetadataRaw(context, request, cq));
    }
    // Returns the config of a data service cluster.
    virtual ::grpc::Status GetDataServiceConfig(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest& request, ::tensorflow::data::GetDataServiceConfigResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceConfigResponse>> AsyncGetDataServiceConfig(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceConfigResponse>>(AsyncGetDataServiceConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceConfigResponse>> PrepareAsyncGetDataServiceConfig(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceConfigResponse>>(PrepareAsyncGetDataServiceConfigRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Performs a periodic worker heartbeat.
      virtual void WorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Updates the dispatcher with information about the worker's state.
      virtual void WorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Gets a dataset defintion.
      virtual void GetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Gets the next split for a given job.
      virtual void GetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Returns the API version of the server.
      virtual void GetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Registers a dataset with the server, or returns its id if it is already
      // registered.
      //
      // The dataset is constructed in a new graph, so it must not refer to
      // external resources or variables.
      virtual void GetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Gets a job if it already exists, otherwise creates it.
      virtual void GetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Attempts to remove a task from a round-robin read job.
      virtual void MaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Releases a job client so that a job may eventually be cleaned up.
      virtual void ReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Heartbeats from the client. This lets the dispatcher know that the client
      // is still active, and gives the dispatcher a chance to notify the client
      // of new tasks.
      virtual void ClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Reports a list of all workers registered with the dispatcher.
      virtual void GetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Returns the data service metadata for the registered dataset.
      virtual void GetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Returns the config of a data service cluster.
      virtual void GetDataServiceConfig(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest* request, ::tensorflow::data::GetDataServiceConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>* AsyncWorkerHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerHeartbeatResponse>* PrepareAsyncWorkerHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>* AsyncWorkerUpdateRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::WorkerUpdateResponse>* PrepareAsyncWorkerUpdateRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>* AsyncGetDatasetDefRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDatasetDefResponse>* PrepareAsyncGetDatasetDefRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>* AsyncGetSplitRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetSplitResponse>* PrepareAsyncGetSplitRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>* AsyncGetOrRegisterDatasetRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrRegisterDatasetResponse>* PrepareAsyncGetOrRegisterDatasetRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>* AsyncGetOrCreateJobRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetOrCreateJobResponse>* PrepareAsyncGetOrCreateJobRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>* AsyncMaybeRemoveTaskRaw(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::MaybeRemoveTaskResponse>* PrepareAsyncMaybeRemoveTaskRaw(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>* AsyncReleaseJobClientRaw(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ReleaseJobClientResponse>* PrepareAsyncReleaseJobClientRaw(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>* AsyncClientHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::ClientHeartbeatResponse>* PrepareAsyncClientHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>* AsyncGetWorkersRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetWorkersResponse>* PrepareAsyncGetWorkersRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>* AsyncGetDataServiceMetadataRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceMetadataResponse>* PrepareAsyncGetDataServiceMetadataRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceConfigResponse>* AsyncGetDataServiceConfigRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::tensorflow::data::GetDataServiceConfigResponse>* PrepareAsyncGetDataServiceConfigRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status WorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::tensorflow::data::WorkerHeartbeatResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>> AsyncWorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>>(AsyncWorkerHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>> PrepareAsyncWorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>>(PrepareAsyncWorkerHeartbeatRaw(context, request, cq));
    }
    ::grpc::Status WorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::tensorflow::data::WorkerUpdateResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>> AsyncWorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>>(AsyncWorkerUpdateRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>> PrepareAsyncWorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>>(PrepareAsyncWorkerUpdateRaw(context, request, cq));
    }
    ::grpc::Status GetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::tensorflow::data::GetDatasetDefResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>> AsyncGetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>>(AsyncGetDatasetDefRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>> PrepareAsyncGetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>>(PrepareAsyncGetDatasetDefRaw(context, request, cq));
    }
    ::grpc::Status GetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::tensorflow::data::GetSplitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>> AsyncGetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>>(AsyncGetSplitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>> PrepareAsyncGetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>>(PrepareAsyncGetSplitRaw(context, request, cq));
    }
    ::grpc::Status GetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::tensorflow::data::GetVersionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>> AsyncGetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>>(AsyncGetVersionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>> PrepareAsyncGetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>>(PrepareAsyncGetVersionRaw(context, request, cq));
    }
    ::grpc::Status GetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::tensorflow::data::GetOrRegisterDatasetResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>> AsyncGetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>>(AsyncGetOrRegisterDatasetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>> PrepareAsyncGetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>>(PrepareAsyncGetOrRegisterDatasetRaw(context, request, cq));
    }
    ::grpc::Status GetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::tensorflow::data::GetOrCreateJobResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>> AsyncGetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>>(AsyncGetOrCreateJobRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>> PrepareAsyncGetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>>(PrepareAsyncGetOrCreateJobRaw(context, request, cq));
    }
    ::grpc::Status MaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::tensorflow::data::MaybeRemoveTaskResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>> AsyncMaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>>(AsyncMaybeRemoveTaskRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>> PrepareAsyncMaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>>(PrepareAsyncMaybeRemoveTaskRaw(context, request, cq));
    }
    ::grpc::Status ReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::tensorflow::data::ReleaseJobClientResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>> AsyncReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>>(AsyncReleaseJobClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>> PrepareAsyncReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>>(PrepareAsyncReleaseJobClientRaw(context, request, cq));
    }
    ::grpc::Status ClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::tensorflow::data::ClientHeartbeatResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>> AsyncClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>>(AsyncClientHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>> PrepareAsyncClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>>(PrepareAsyncClientHeartbeatRaw(context, request, cq));
    }
    ::grpc::Status GetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::tensorflow::data::GetWorkersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>> AsyncGetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>>(AsyncGetWorkersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>> PrepareAsyncGetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>>(PrepareAsyncGetWorkersRaw(context, request, cq));
    }
    ::grpc::Status GetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::tensorflow::data::GetDataServiceMetadataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>> AsyncGetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>>(AsyncGetDataServiceMetadataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>> PrepareAsyncGetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>>(PrepareAsyncGetDataServiceMetadataRaw(context, request, cq));
    }
    ::grpc::Status GetDataServiceConfig(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest& request, ::tensorflow::data::GetDataServiceConfigResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceConfigResponse>> AsyncGetDataServiceConfig(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceConfigResponse>>(AsyncGetDataServiceConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceConfigResponse>> PrepareAsyncGetDataServiceConfig(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceConfigResponse>>(PrepareAsyncGetDataServiceConfigRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void WorkerHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response, std::function<void(::grpc::Status)>) override;
      void WorkerUpdate(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDatasetDef(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response, std::function<void(::grpc::Status)>) override;
      void GetSplit(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response, std::function<void(::grpc::Status)>) override;
      void GetVersion(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOrRegisterDataset(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOrCreateJob(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response, std::function<void(::grpc::Status)>) override;
      void MaybeRemoveTask(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response, std::function<void(::grpc::Status)>) override;
      void ReleaseJobClient(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response, std::function<void(::grpc::Status)>) override;
      void ClientHeartbeat(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response, std::function<void(::grpc::Status)>) override;
      void GetWorkers(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDataServiceMetadata(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDataServiceConfig(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest* request, ::tensorflow::data::GetDataServiceConfigResponse* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>* AsyncWorkerHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerHeartbeatResponse>* PrepareAsyncWorkerHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>* AsyncWorkerUpdateRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::WorkerUpdateResponse>* PrepareAsyncWorkerUpdateRaw(::grpc::ClientContext* context, const ::tensorflow::data::WorkerUpdateRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>* AsyncGetDatasetDefRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDatasetDefResponse>* PrepareAsyncGetDatasetDefRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDatasetDefRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>* AsyncGetSplitRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetSplitResponse>* PrepareAsyncGetSplitRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetSplitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>* AsyncGetVersionRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetVersionResponse>* PrepareAsyncGetVersionRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetVersionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>* AsyncGetOrRegisterDatasetRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrRegisterDatasetResponse>* PrepareAsyncGetOrRegisterDatasetRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>* AsyncGetOrCreateJobRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetOrCreateJobResponse>* PrepareAsyncGetOrCreateJobRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetOrCreateJobRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>* AsyncMaybeRemoveTaskRaw(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::MaybeRemoveTaskResponse>* PrepareAsyncMaybeRemoveTaskRaw(::grpc::ClientContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>* AsyncReleaseJobClientRaw(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ReleaseJobClientResponse>* PrepareAsyncReleaseJobClientRaw(::grpc::ClientContext* context, const ::tensorflow::data::ReleaseJobClientRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>* AsyncClientHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::ClientHeartbeatResponse>* PrepareAsyncClientHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::data::ClientHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>* AsyncGetWorkersRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetWorkersResponse>* PrepareAsyncGetWorkersRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetWorkersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>* AsyncGetDataServiceMetadataRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceMetadataResponse>* PrepareAsyncGetDataServiceMetadataRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceConfigResponse>* AsyncGetDataServiceConfigRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::tensorflow::data::GetDataServiceConfigResponse>* PrepareAsyncGetDataServiceConfigRaw(::grpc::ClientContext* context, const ::tensorflow::data::GetDataServiceConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_WorkerHeartbeat_;
    const ::grpc::internal::RpcMethod rpcmethod_WorkerUpdate_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDatasetDef_;
    const ::grpc::internal::RpcMethod rpcmethod_GetSplit_;
    const ::grpc::internal::RpcMethod rpcmethod_GetVersion_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOrRegisterDataset_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOrCreateJob_;
    const ::grpc::internal::RpcMethod rpcmethod_MaybeRemoveTask_;
    const ::grpc::internal::RpcMethod rpcmethod_ReleaseJobClient_;
    const ::grpc::internal::RpcMethod rpcmethod_ClientHeartbeat_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWorkers_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDataServiceMetadata_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDataServiceConfig_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Performs a periodic worker heartbeat.
    virtual ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response);
    // Updates the dispatcher with information about the worker's state.
    virtual ::grpc::Status WorkerUpdate(::grpc::ServerContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response);
    // Gets a dataset defintion.
    virtual ::grpc::Status GetDatasetDef(::grpc::ServerContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response);
    // Gets the next split for a given job.
    virtual ::grpc::Status GetSplit(::grpc::ServerContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response);
    // Returns the API version of the server.
    virtual ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response);
    // Registers a dataset with the server, or returns its id if it is already
    // registered.
    //
    // The dataset is constructed in a new graph, so it must not refer to
    // external resources or variables.
    virtual ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response);
    // Gets a job if it already exists, otherwise creates it.
    virtual ::grpc::Status GetOrCreateJob(::grpc::ServerContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response);
    // Attempts to remove a task from a round-robin read job.
    virtual ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response);
    // Releases a job client so that a job may eventually be cleaned up.
    virtual ::grpc::Status ReleaseJobClient(::grpc::ServerContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response);
    // Heartbeats from the client. This lets the dispatcher know that the client
    // is still active, and gives the dispatcher a chance to notify the client
    // of new tasks.
    virtual ::grpc::Status ClientHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response);
    // Reports a list of all workers registered with the dispatcher.
    virtual ::grpc::Status GetWorkers(::grpc::ServerContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response);
    // Returns the data service metadata for the registered dataset.
    virtual ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response);
    // Returns the config of a data service cluster.
    virtual ::grpc::Status GetDataServiceConfig(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceConfigRequest* request, ::tensorflow::data::GetDataServiceConfigResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_WorkerHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_WorkerHeartbeat() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_WorkerHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWorkerHeartbeat(::grpc::ServerContext* context, ::tensorflow::data::WorkerHeartbeatRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::WorkerHeartbeatResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WorkerUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_WorkerUpdate() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_WorkerUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerUpdate(::grpc::ServerContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWorkerUpdate(::grpc::ServerContext* context, ::tensorflow::data::WorkerUpdateRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::WorkerUpdateResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDatasetDef : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetDatasetDef() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetDatasetDef() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatasetDef(::grpc::ServerContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDatasetDef(::grpc::ServerContext* context, ::tensorflow::data::GetDatasetDefRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetDatasetDefResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetSplit() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSplit(::grpc::ServerContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSplit(::grpc::ServerContext* context, ::tensorflow::data::GetSplitRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetSplitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetVersion() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::tensorflow::data::GetVersionRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetVersionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOrRegisterDataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetOrRegisterDataset() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetOrRegisterDataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOrRegisterDataset(::grpc::ServerContext* context, ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetOrRegisterDatasetResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOrCreateJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetOrCreateJob() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetOrCreateJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrCreateJob(::grpc::ServerContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOrCreateJob(::grpc::ServerContext* context, ::tensorflow::data::GetOrCreateJobRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetOrCreateJobResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MaybeRemoveTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_MaybeRemoveTask() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_MaybeRemoveTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMaybeRemoveTask(::grpc::ServerContext* context, ::tensorflow::data::MaybeRemoveTaskRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::MaybeRemoveTaskResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReleaseJobClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ReleaseJobClient() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_ReleaseJobClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleaseJobClient(::grpc::ServerContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReleaseJobClient(::grpc::ServerContext* context, ::tensorflow::data::ReleaseJobClientRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::ReleaseJobClientResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ClientHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ClientHeartbeat() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_ClientHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClientHeartbeat(::grpc::ServerContext* context, ::tensorflow::data::ClientHeartbeatRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::ClientHeartbeatResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetWorkers() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkers(::grpc::ServerContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkers(::grpc::ServerContext* context, ::tensorflow::data::GetWorkersRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetWorkersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDataServiceMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetDataServiceMetadata() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetDataServiceMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDataServiceMetadata(::grpc::ServerContext* context, ::tensorflow::data::GetDataServiceMetadataRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetDataServiceMetadataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDataServiceConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetDataServiceConfig() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetDataServiceConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceConfig(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceConfigRequest* request, ::tensorflow::data::GetDataServiceConfigResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDataServiceConfig(::grpc::ServerContext* context, ::tensorflow::data::GetDataServiceConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::tensorflow::data::GetDataServiceConfigResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_WorkerHeartbeat<WithAsyncMethod_WorkerUpdate<WithAsyncMethod_GetDatasetDef<WithAsyncMethod_GetSplit<WithAsyncMethod_GetVersion<WithAsyncMethod_GetOrRegisterDataset<WithAsyncMethod_GetOrCreateJob<WithAsyncMethod_MaybeRemoveTask<WithAsyncMethod_ReleaseJobClient<WithAsyncMethod_ClientHeartbeat<WithAsyncMethod_GetWorkers<WithAsyncMethod_GetDataServiceMetadata<WithAsyncMethod_GetDataServiceConfig<Service > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_WorkerHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_WorkerHeartbeat() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_WorkerHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WorkerUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_WorkerUpdate() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_WorkerUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerUpdate(::grpc::ServerContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDatasetDef : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetDatasetDef() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetDatasetDef() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatasetDef(::grpc::ServerContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetSplit() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSplit(::grpc::ServerContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetVersion() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOrRegisterDataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetOrRegisterDataset() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetOrRegisterDataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOrCreateJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetOrCreateJob() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetOrCreateJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrCreateJob(::grpc::ServerContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MaybeRemoveTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_MaybeRemoveTask() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_MaybeRemoveTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReleaseJobClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ReleaseJobClient() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_ReleaseJobClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleaseJobClient(::grpc::ServerContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ClientHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ClientHeartbeat() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_ClientHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetWorkers() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkers(::grpc::ServerContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDataServiceMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetDataServiceMetadata() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetDataServiceMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDataServiceConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetDataServiceConfig() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetDataServiceConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceConfig(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceConfigRequest* request, ::tensorflow::data::GetDataServiceConfigResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_WorkerHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_WorkerHeartbeat() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_WorkerHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWorkerHeartbeat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WorkerUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_WorkerUpdate() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_WorkerUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WorkerUpdate(::grpc::ServerContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWorkerUpdate(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDatasetDef : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetDatasetDef() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetDatasetDef() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDatasetDef(::grpc::ServerContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDatasetDef(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetSplit() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetSplit(::grpc::ServerContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetSplit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetVersion() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetVersion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOrRegisterDataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetOrRegisterDataset() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetOrRegisterDataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOrRegisterDataset(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOrCreateJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetOrCreateJob() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetOrCreateJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOrCreateJob(::grpc::ServerContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOrCreateJob(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_MaybeRemoveTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_MaybeRemoveTask() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_MaybeRemoveTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMaybeRemoveTask(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReleaseJobClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ReleaseJobClient() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_ReleaseJobClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReleaseJobClient(::grpc::ServerContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReleaseJobClient(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ClientHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ClientHeartbeat() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_ClientHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ClientHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestClientHeartbeat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetWorkers() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWorkers(::grpc::ServerContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWorkers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDataServiceMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetDataServiceMetadata() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetDataServiceMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDataServiceMetadata(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDataServiceConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetDataServiceConfig() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetDataServiceConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDataServiceConfig(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceConfigRequest* request, ::tensorflow::data::GetDataServiceConfigResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDataServiceConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WorkerHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_WorkerHeartbeat() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::WorkerHeartbeatRequest, ::tensorflow::data::WorkerHeartbeatResponse>(std::bind(&WithStreamedUnaryMethod_WorkerHeartbeat<BaseClass>::StreamedWorkerHeartbeat, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_WorkerHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WorkerHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::WorkerHeartbeatRequest* request, ::tensorflow::data::WorkerHeartbeatResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWorkerHeartbeat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::WorkerHeartbeatRequest,::tensorflow::data::WorkerHeartbeatResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WorkerUpdate : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_WorkerUpdate() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::WorkerUpdateRequest, ::tensorflow::data::WorkerUpdateResponse>(std::bind(&WithStreamedUnaryMethod_WorkerUpdate<BaseClass>::StreamedWorkerUpdate, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_WorkerUpdate() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WorkerUpdate(::grpc::ServerContext* context, const ::tensorflow::data::WorkerUpdateRequest* request, ::tensorflow::data::WorkerUpdateResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWorkerUpdate(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::WorkerUpdateRequest,::tensorflow::data::WorkerUpdateResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDatasetDef : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetDatasetDef() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::GetDatasetDefRequest, ::tensorflow::data::GetDatasetDefResponse>(std::bind(&WithStreamedUnaryMethod_GetDatasetDef<BaseClass>::StreamedGetDatasetDef, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetDatasetDef() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDatasetDef(::grpc::ServerContext* context, const ::tensorflow::data::GetDatasetDefRequest* request, ::tensorflow::data::GetDatasetDefResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDatasetDef(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetDatasetDefRequest,::tensorflow::data::GetDatasetDefResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetSplit() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::GetSplitRequest, ::tensorflow::data::GetSplitResponse>(std::bind(&WithStreamedUnaryMethod_GetSplit<BaseClass>::StreamedGetSplit, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetSplit(::grpc::ServerContext* context, const ::tensorflow::data::GetSplitRequest* request, ::tensorflow::data::GetSplitResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetSplit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetSplitRequest,::tensorflow::data::GetSplitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetVersion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetVersion() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::GetVersionRequest, ::tensorflow::data::GetVersionResponse>(std::bind(&WithStreamedUnaryMethod_GetVersion<BaseClass>::StreamedGetVersion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetVersion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetVersion(::grpc::ServerContext* context, const ::tensorflow::data::GetVersionRequest* request, ::tensorflow::data::GetVersionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetVersion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetVersionRequest,::tensorflow::data::GetVersionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOrRegisterDataset : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetOrRegisterDataset() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::GetOrRegisterDatasetRequest, ::tensorflow::data::GetOrRegisterDatasetResponse>(std::bind(&WithStreamedUnaryMethod_GetOrRegisterDataset<BaseClass>::StreamedGetOrRegisterDataset, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetOrRegisterDataset() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOrRegisterDataset(::grpc::ServerContext* context, const ::tensorflow::data::GetOrRegisterDatasetRequest* request, ::tensorflow::data::GetOrRegisterDatasetResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOrRegisterDataset(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetOrRegisterDatasetRequest,::tensorflow::data::GetOrRegisterDatasetResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOrCreateJob : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetOrCreateJob() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::GetOrCreateJobRequest, ::tensorflow::data::GetOrCreateJobResponse>(std::bind(&WithStreamedUnaryMethod_GetOrCreateJob<BaseClass>::StreamedGetOrCreateJob, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetOrCreateJob() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOrCreateJob(::grpc::ServerContext* context, const ::tensorflow::data::GetOrCreateJobRequest* request, ::tensorflow::data::GetOrCreateJobResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOrCreateJob(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetOrCreateJobRequest,::tensorflow::data::GetOrCreateJobResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MaybeRemoveTask : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_MaybeRemoveTask() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::MaybeRemoveTaskRequest, ::tensorflow::data::MaybeRemoveTaskResponse>(std::bind(&WithStreamedUnaryMethod_MaybeRemoveTask<BaseClass>::StreamedMaybeRemoveTask, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MaybeRemoveTask() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MaybeRemoveTask(::grpc::ServerContext* context, const ::tensorflow::data::MaybeRemoveTaskRequest* request, ::tensorflow::data::MaybeRemoveTaskResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMaybeRemoveTask(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::MaybeRemoveTaskRequest,::tensorflow::data::MaybeRemoveTaskResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReleaseJobClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ReleaseJobClient() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::ReleaseJobClientRequest, ::tensorflow::data::ReleaseJobClientResponse>(std::bind(&WithStreamedUnaryMethod_ReleaseJobClient<BaseClass>::StreamedReleaseJobClient, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ReleaseJobClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReleaseJobClient(::grpc::ServerContext* context, const ::tensorflow::data::ReleaseJobClientRequest* request, ::tensorflow::data::ReleaseJobClientResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReleaseJobClient(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::ReleaseJobClientRequest,::tensorflow::data::ReleaseJobClientResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ClientHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ClientHeartbeat() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::ClientHeartbeatRequest, ::tensorflow::data::ClientHeartbeatResponse>(std::bind(&WithStreamedUnaryMethod_ClientHeartbeat<BaseClass>::StreamedClientHeartbeat, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ClientHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ClientHeartbeat(::grpc::ServerContext* context, const ::tensorflow::data::ClientHeartbeatRequest* request, ::tensorflow::data::ClientHeartbeatResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedClientHeartbeat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::ClientHeartbeatRequest,::tensorflow::data::ClientHeartbeatResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWorkers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetWorkers() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::GetWorkersRequest, ::tensorflow::data::GetWorkersResponse>(std::bind(&WithStreamedUnaryMethod_GetWorkers<BaseClass>::StreamedGetWorkers, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetWorkers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWorkers(::grpc::ServerContext* context, const ::tensorflow::data::GetWorkersRequest* request, ::tensorflow::data::GetWorkersResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWorkers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetWorkersRequest,::tensorflow::data::GetWorkersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDataServiceMetadata : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetDataServiceMetadata() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::GetDataServiceMetadataRequest, ::tensorflow::data::GetDataServiceMetadataResponse>(std::bind(&WithStreamedUnaryMethod_GetDataServiceMetadata<BaseClass>::StreamedGetDataServiceMetadata, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetDataServiceMetadata() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDataServiceMetadata(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceMetadataRequest* request, ::tensorflow::data::GetDataServiceMetadataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDataServiceMetadata(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetDataServiceMetadataRequest,::tensorflow::data::GetDataServiceMetadataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDataServiceConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetDataServiceConfig() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::tensorflow::data::GetDataServiceConfigRequest, ::tensorflow::data::GetDataServiceConfigResponse>(std::bind(&WithStreamedUnaryMethod_GetDataServiceConfig<BaseClass>::StreamedGetDataServiceConfig, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetDataServiceConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDataServiceConfig(::grpc::ServerContext* context, const ::tensorflow::data::GetDataServiceConfigRequest* request, ::tensorflow::data::GetDataServiceConfigResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDataServiceConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::tensorflow::data::GetDataServiceConfigRequest,::tensorflow::data::GetDataServiceConfigResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_WorkerHeartbeat<WithStreamedUnaryMethod_WorkerUpdate<WithStreamedUnaryMethod_GetDatasetDef<WithStreamedUnaryMethod_GetSplit<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_GetOrRegisterDataset<WithStreamedUnaryMethod_GetOrCreateJob<WithStreamedUnaryMethod_MaybeRemoveTask<WithStreamedUnaryMethod_ReleaseJobClient<WithStreamedUnaryMethod_ClientHeartbeat<WithStreamedUnaryMethod_GetWorkers<WithStreamedUnaryMethod_GetDataServiceMetadata<WithStreamedUnaryMethod_GetDataServiceConfig<Service > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_WorkerHeartbeat<WithStreamedUnaryMethod_WorkerUpdate<WithStreamedUnaryMethod_GetDatasetDef<WithStreamedUnaryMethod_GetSplit<WithStreamedUnaryMethod_GetVersion<WithStreamedUnaryMethod_GetOrRegisterDataset<WithStreamedUnaryMethod_GetOrCreateJob<WithStreamedUnaryMethod_MaybeRemoveTask<WithStreamedUnaryMethod_ReleaseJobClient<WithStreamedUnaryMethod_ClientHeartbeat<WithStreamedUnaryMethod_GetWorkers<WithStreamedUnaryMethod_GetDataServiceMetadata<WithStreamedUnaryMethod_GetDataServiceConfig<Service > > > > > > > > > > > > > StreamedService;
};

}  // namespace data
}  // namespace tensorflow


#endif  // GRPC_tensorflow_2fcore_2fdata_2fservice_2fdispatcher_2eproto__INCLUDED
