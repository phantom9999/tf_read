// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/data/service/journal.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/data/service/common.pb.h"
#include "tensorflow/core/protobuf/data_service.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto 

namespace protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[14];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto
namespace tensorflow {
namespace data {
class AcquireJobClientUpdate;
class AcquireJobClientUpdateDefaultTypeInternal;
extern AcquireJobClientUpdateDefaultTypeInternal _AcquireJobClientUpdate_default_instance_;
class ClientHeartbeatUpdate;
class ClientHeartbeatUpdateDefaultTypeInternal;
extern ClientHeartbeatUpdateDefaultTypeInternal _ClientHeartbeatUpdate_default_instance_;
class CreateJobUpdate;
class CreateJobUpdateDefaultTypeInternal;
extern CreateJobUpdateDefaultTypeInternal _CreateJobUpdate_default_instance_;
class CreatePendingTaskUpdate;
class CreatePendingTaskUpdateDefaultTypeInternal;
extern CreatePendingTaskUpdateDefaultTypeInternal _CreatePendingTaskUpdate_default_instance_;
class CreateTaskUpdate;
class CreateTaskUpdateDefaultTypeInternal;
extern CreateTaskUpdateDefaultTypeInternal _CreateTaskUpdate_default_instance_;
class FinishTaskUpdate;
class FinishTaskUpdateDefaultTypeInternal;
extern FinishTaskUpdateDefaultTypeInternal _FinishTaskUpdate_default_instance_;
class GarbageCollectJobUpdate;
class GarbageCollectJobUpdateDefaultTypeInternal;
extern GarbageCollectJobUpdateDefaultTypeInternal _GarbageCollectJobUpdate_default_instance_;
class ProduceSplitUpdate;
class ProduceSplitUpdateDefaultTypeInternal;
extern ProduceSplitUpdateDefaultTypeInternal _ProduceSplitUpdate_default_instance_;
class RegisterDatasetUpdate;
class RegisterDatasetUpdateDefaultTypeInternal;
extern RegisterDatasetUpdateDefaultTypeInternal _RegisterDatasetUpdate_default_instance_;
class RegisterWorkerUpdate;
class RegisterWorkerUpdateDefaultTypeInternal;
extern RegisterWorkerUpdateDefaultTypeInternal _RegisterWorkerUpdate_default_instance_;
class ReleaseJobClientUpdate;
class ReleaseJobClientUpdateDefaultTypeInternal;
extern ReleaseJobClientUpdateDefaultTypeInternal _ReleaseJobClientUpdate_default_instance_;
class RemoveTaskUpdate;
class RemoveTaskUpdateDefaultTypeInternal;
extern RemoveTaskUpdateDefaultTypeInternal _RemoveTaskUpdate_default_instance_;
class TaskRejected;
class TaskRejectedDefaultTypeInternal;
extern TaskRejectedDefaultTypeInternal _TaskRejected_default_instance_;
class Update;
class UpdateDefaultTypeInternal;
extern UpdateDefaultTypeInternal _Update_default_instance_;
}  // namespace data
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::data::AcquireJobClientUpdate* Arena::CreateMaybeMessage<::tensorflow::data::AcquireJobClientUpdate>(Arena*);
template<> ::tensorflow::data::ClientHeartbeatUpdate* Arena::CreateMaybeMessage<::tensorflow::data::ClientHeartbeatUpdate>(Arena*);
template<> ::tensorflow::data::CreateJobUpdate* Arena::CreateMaybeMessage<::tensorflow::data::CreateJobUpdate>(Arena*);
template<> ::tensorflow::data::CreatePendingTaskUpdate* Arena::CreateMaybeMessage<::tensorflow::data::CreatePendingTaskUpdate>(Arena*);
template<> ::tensorflow::data::CreateTaskUpdate* Arena::CreateMaybeMessage<::tensorflow::data::CreateTaskUpdate>(Arena*);
template<> ::tensorflow::data::FinishTaskUpdate* Arena::CreateMaybeMessage<::tensorflow::data::FinishTaskUpdate>(Arena*);
template<> ::tensorflow::data::GarbageCollectJobUpdate* Arena::CreateMaybeMessage<::tensorflow::data::GarbageCollectJobUpdate>(Arena*);
template<> ::tensorflow::data::ProduceSplitUpdate* Arena::CreateMaybeMessage<::tensorflow::data::ProduceSplitUpdate>(Arena*);
template<> ::tensorflow::data::RegisterDatasetUpdate* Arena::CreateMaybeMessage<::tensorflow::data::RegisterDatasetUpdate>(Arena*);
template<> ::tensorflow::data::RegisterWorkerUpdate* Arena::CreateMaybeMessage<::tensorflow::data::RegisterWorkerUpdate>(Arena*);
template<> ::tensorflow::data::ReleaseJobClientUpdate* Arena::CreateMaybeMessage<::tensorflow::data::ReleaseJobClientUpdate>(Arena*);
template<> ::tensorflow::data::RemoveTaskUpdate* Arena::CreateMaybeMessage<::tensorflow::data::RemoveTaskUpdate>(Arena*);
template<> ::tensorflow::data::TaskRejected* Arena::CreateMaybeMessage<::tensorflow::data::TaskRejected>(Arena*);
template<> ::tensorflow::data::Update* Arena::CreateMaybeMessage<::tensorflow::data::Update>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {
namespace data {

// ===================================================================

class Update : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.Update) */ {
 public:
  Update();
  virtual ~Update();

  Update(const Update& from);

  inline Update& operator=(const Update& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Update(Update&& from) noexcept
    : Update() {
    *this = ::std::move(from);
  }

  inline Update& operator=(Update&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Update& default_instance();

  enum UpdateTypeCase {
    kRegisterDataset = 1,
    kRegisterWorker = 5,
    kCreateJob = 2,
    kProduceSplit = 8,
    kAcquireJobClient = 6,
    kReleaseJobClient = 7,
    kGarbageCollectJob = 12,
    kRemoveTask = 11,
    kCreatePendingTask = 9,
    kClientHeartbeat = 10,
    kCreateTask = 3,
    kFinishTask = 4,
    UPDATE_TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Update* internal_default_instance() {
    return reinterpret_cast<const Update*>(
               &_Update_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Update* other);
  friend void swap(Update& a, Update& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Update* New() const final {
    return CreateMaybeMessage<Update>(NULL);
  }

  Update* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Update>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Update& from);
  void MergeFrom(const Update& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Update* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.data.RegisterDatasetUpdate register_dataset = 1;
  bool has_register_dataset() const;
  void clear_register_dataset();
  static const int kRegisterDatasetFieldNumber = 1;
  private:
  const ::tensorflow::data::RegisterDatasetUpdate& _internal_register_dataset() const;
  public:
  const ::tensorflow::data::RegisterDatasetUpdate& register_dataset() const;
  ::tensorflow::data::RegisterDatasetUpdate* release_register_dataset();
  ::tensorflow::data::RegisterDatasetUpdate* mutable_register_dataset();
  void set_allocated_register_dataset(::tensorflow::data::RegisterDatasetUpdate* register_dataset);

  // .tensorflow.data.RegisterWorkerUpdate register_worker = 5;
  bool has_register_worker() const;
  void clear_register_worker();
  static const int kRegisterWorkerFieldNumber = 5;
  private:
  const ::tensorflow::data::RegisterWorkerUpdate& _internal_register_worker() const;
  public:
  const ::tensorflow::data::RegisterWorkerUpdate& register_worker() const;
  ::tensorflow::data::RegisterWorkerUpdate* release_register_worker();
  ::tensorflow::data::RegisterWorkerUpdate* mutable_register_worker();
  void set_allocated_register_worker(::tensorflow::data::RegisterWorkerUpdate* register_worker);

  // .tensorflow.data.CreateJobUpdate create_job = 2;
  bool has_create_job() const;
  void clear_create_job();
  static const int kCreateJobFieldNumber = 2;
  private:
  const ::tensorflow::data::CreateJobUpdate& _internal_create_job() const;
  public:
  const ::tensorflow::data::CreateJobUpdate& create_job() const;
  ::tensorflow::data::CreateJobUpdate* release_create_job();
  ::tensorflow::data::CreateJobUpdate* mutable_create_job();
  void set_allocated_create_job(::tensorflow::data::CreateJobUpdate* create_job);

  // .tensorflow.data.ProduceSplitUpdate produce_split = 8;
  bool has_produce_split() const;
  void clear_produce_split();
  static const int kProduceSplitFieldNumber = 8;
  private:
  const ::tensorflow::data::ProduceSplitUpdate& _internal_produce_split() const;
  public:
  const ::tensorflow::data::ProduceSplitUpdate& produce_split() const;
  ::tensorflow::data::ProduceSplitUpdate* release_produce_split();
  ::tensorflow::data::ProduceSplitUpdate* mutable_produce_split();
  void set_allocated_produce_split(::tensorflow::data::ProduceSplitUpdate* produce_split);

  // .tensorflow.data.AcquireJobClientUpdate acquire_job_client = 6;
  bool has_acquire_job_client() const;
  void clear_acquire_job_client();
  static const int kAcquireJobClientFieldNumber = 6;
  private:
  const ::tensorflow::data::AcquireJobClientUpdate& _internal_acquire_job_client() const;
  public:
  const ::tensorflow::data::AcquireJobClientUpdate& acquire_job_client() const;
  ::tensorflow::data::AcquireJobClientUpdate* release_acquire_job_client();
  ::tensorflow::data::AcquireJobClientUpdate* mutable_acquire_job_client();
  void set_allocated_acquire_job_client(::tensorflow::data::AcquireJobClientUpdate* acquire_job_client);

  // .tensorflow.data.ReleaseJobClientUpdate release_job_client = 7;
  bool has_release_job_client() const;
  void clear_release_job_client();
  static const int kReleaseJobClientFieldNumber = 7;
  private:
  const ::tensorflow::data::ReleaseJobClientUpdate& _internal_release_job_client() const;
  public:
  const ::tensorflow::data::ReleaseJobClientUpdate& release_job_client() const;
  ::tensorflow::data::ReleaseJobClientUpdate* release_release_job_client();
  ::tensorflow::data::ReleaseJobClientUpdate* mutable_release_job_client();
  void set_allocated_release_job_client(::tensorflow::data::ReleaseJobClientUpdate* release_job_client);

  // .tensorflow.data.GarbageCollectJobUpdate garbage_collect_job = 12;
  bool has_garbage_collect_job() const;
  void clear_garbage_collect_job();
  static const int kGarbageCollectJobFieldNumber = 12;
  private:
  const ::tensorflow::data::GarbageCollectJobUpdate& _internal_garbage_collect_job() const;
  public:
  const ::tensorflow::data::GarbageCollectJobUpdate& garbage_collect_job() const;
  ::tensorflow::data::GarbageCollectJobUpdate* release_garbage_collect_job();
  ::tensorflow::data::GarbageCollectJobUpdate* mutable_garbage_collect_job();
  void set_allocated_garbage_collect_job(::tensorflow::data::GarbageCollectJobUpdate* garbage_collect_job);

  // .tensorflow.data.RemoveTaskUpdate remove_task = 11;
  bool has_remove_task() const;
  void clear_remove_task();
  static const int kRemoveTaskFieldNumber = 11;
  private:
  const ::tensorflow::data::RemoveTaskUpdate& _internal_remove_task() const;
  public:
  const ::tensorflow::data::RemoveTaskUpdate& remove_task() const;
  ::tensorflow::data::RemoveTaskUpdate* release_remove_task();
  ::tensorflow::data::RemoveTaskUpdate* mutable_remove_task();
  void set_allocated_remove_task(::tensorflow::data::RemoveTaskUpdate* remove_task);

  // .tensorflow.data.CreatePendingTaskUpdate create_pending_task = 9;
  bool has_create_pending_task() const;
  void clear_create_pending_task();
  static const int kCreatePendingTaskFieldNumber = 9;
  private:
  const ::tensorflow::data::CreatePendingTaskUpdate& _internal_create_pending_task() const;
  public:
  const ::tensorflow::data::CreatePendingTaskUpdate& create_pending_task() const;
  ::tensorflow::data::CreatePendingTaskUpdate* release_create_pending_task();
  ::tensorflow::data::CreatePendingTaskUpdate* mutable_create_pending_task();
  void set_allocated_create_pending_task(::tensorflow::data::CreatePendingTaskUpdate* create_pending_task);

  // .tensorflow.data.ClientHeartbeatUpdate client_heartbeat = 10;
  bool has_client_heartbeat() const;
  void clear_client_heartbeat();
  static const int kClientHeartbeatFieldNumber = 10;
  private:
  const ::tensorflow::data::ClientHeartbeatUpdate& _internal_client_heartbeat() const;
  public:
  const ::tensorflow::data::ClientHeartbeatUpdate& client_heartbeat() const;
  ::tensorflow::data::ClientHeartbeatUpdate* release_client_heartbeat();
  ::tensorflow::data::ClientHeartbeatUpdate* mutable_client_heartbeat();
  void set_allocated_client_heartbeat(::tensorflow::data::ClientHeartbeatUpdate* client_heartbeat);

  // .tensorflow.data.CreateTaskUpdate create_task = 3;
  bool has_create_task() const;
  void clear_create_task();
  static const int kCreateTaskFieldNumber = 3;
  private:
  const ::tensorflow::data::CreateTaskUpdate& _internal_create_task() const;
  public:
  const ::tensorflow::data::CreateTaskUpdate& create_task() const;
  ::tensorflow::data::CreateTaskUpdate* release_create_task();
  ::tensorflow::data::CreateTaskUpdate* mutable_create_task();
  void set_allocated_create_task(::tensorflow::data::CreateTaskUpdate* create_task);

  // .tensorflow.data.FinishTaskUpdate finish_task = 4;
  bool has_finish_task() const;
  void clear_finish_task();
  static const int kFinishTaskFieldNumber = 4;
  private:
  const ::tensorflow::data::FinishTaskUpdate& _internal_finish_task() const;
  public:
  const ::tensorflow::data::FinishTaskUpdate& finish_task() const;
  ::tensorflow::data::FinishTaskUpdate* release_finish_task();
  ::tensorflow::data::FinishTaskUpdate* mutable_finish_task();
  void set_allocated_finish_task(::tensorflow::data::FinishTaskUpdate* finish_task);

  void clear_update_type();
  UpdateTypeCase update_type_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.Update)
 private:
  void set_has_register_dataset();
  void set_has_register_worker();
  void set_has_create_job();
  void set_has_produce_split();
  void set_has_acquire_job_client();
  void set_has_release_job_client();
  void set_has_garbage_collect_job();
  void set_has_remove_task();
  void set_has_create_pending_task();
  void set_has_client_heartbeat();
  void set_has_create_task();
  void set_has_finish_task();

  inline bool has_update_type() const;
  inline void clear_has_update_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union UpdateTypeUnion {
    UpdateTypeUnion() {}
    ::tensorflow::data::RegisterDatasetUpdate* register_dataset_;
    ::tensorflow::data::RegisterWorkerUpdate* register_worker_;
    ::tensorflow::data::CreateJobUpdate* create_job_;
    ::tensorflow::data::ProduceSplitUpdate* produce_split_;
    ::tensorflow::data::AcquireJobClientUpdate* acquire_job_client_;
    ::tensorflow::data::ReleaseJobClientUpdate* release_job_client_;
    ::tensorflow::data::GarbageCollectJobUpdate* garbage_collect_job_;
    ::tensorflow::data::RemoveTaskUpdate* remove_task_;
    ::tensorflow::data::CreatePendingTaskUpdate* create_pending_task_;
    ::tensorflow::data::ClientHeartbeatUpdate* client_heartbeat_;
    ::tensorflow::data::CreateTaskUpdate* create_task_;
    ::tensorflow::data::FinishTaskUpdate* finish_task_;
  } update_type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterDatasetUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.RegisterDatasetUpdate) */ {
 public:
  RegisterDatasetUpdate();
  virtual ~RegisterDatasetUpdate();

  RegisterDatasetUpdate(const RegisterDatasetUpdate& from);

  inline RegisterDatasetUpdate& operator=(const RegisterDatasetUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterDatasetUpdate(RegisterDatasetUpdate&& from) noexcept
    : RegisterDatasetUpdate() {
    *this = ::std::move(from);
  }

  inline RegisterDatasetUpdate& operator=(RegisterDatasetUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterDatasetUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterDatasetUpdate* internal_default_instance() {
    return reinterpret_cast<const RegisterDatasetUpdate*>(
               &_RegisterDatasetUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RegisterDatasetUpdate* other);
  friend void swap(RegisterDatasetUpdate& a, RegisterDatasetUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterDatasetUpdate* New() const final {
    return CreateMaybeMessage<RegisterDatasetUpdate>(NULL);
  }

  RegisterDatasetUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterDatasetUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterDatasetUpdate& from);
  void MergeFrom(const RegisterDatasetUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterDatasetUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.data.DataServiceMetadata metadata = 3;
  bool has_metadata() const;
  void clear_metadata();
  static const int kMetadataFieldNumber = 3;
  private:
  const ::tensorflow::data::DataServiceMetadata& _internal_metadata() const;
  public:
  const ::tensorflow::data::DataServiceMetadata& metadata() const;
  ::tensorflow::data::DataServiceMetadata* release_metadata();
  ::tensorflow::data::DataServiceMetadata* mutable_metadata();
  void set_allocated_metadata(::tensorflow::data::DataServiceMetadata* metadata);

  // int64 dataset_id = 1;
  void clear_dataset_id();
  static const int kDatasetIdFieldNumber = 1;
  ::google::protobuf::int64 dataset_id() const;
  void set_dataset_id(::google::protobuf::int64 value);

  // uint64 fingerprint = 2;
  void clear_fingerprint();
  static const int kFingerprintFieldNumber = 2;
  ::google::protobuf::uint64 fingerprint() const;
  void set_fingerprint(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.RegisterDatasetUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::data::DataServiceMetadata* metadata_;
  ::google::protobuf::int64 dataset_id_;
  ::google::protobuf::uint64 fingerprint_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterWorkerUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.RegisterWorkerUpdate) */ {
 public:
  RegisterWorkerUpdate();
  virtual ~RegisterWorkerUpdate();

  RegisterWorkerUpdate(const RegisterWorkerUpdate& from);

  inline RegisterWorkerUpdate& operator=(const RegisterWorkerUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterWorkerUpdate(RegisterWorkerUpdate&& from) noexcept
    : RegisterWorkerUpdate() {
    *this = ::std::move(from);
  }

  inline RegisterWorkerUpdate& operator=(RegisterWorkerUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterWorkerUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterWorkerUpdate* internal_default_instance() {
    return reinterpret_cast<const RegisterWorkerUpdate*>(
               &_RegisterWorkerUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(RegisterWorkerUpdate* other);
  friend void swap(RegisterWorkerUpdate& a, RegisterWorkerUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterWorkerUpdate* New() const final {
    return CreateMaybeMessage<RegisterWorkerUpdate>(NULL);
  }

  RegisterWorkerUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterWorkerUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterWorkerUpdate& from);
  void MergeFrom(const RegisterWorkerUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterWorkerUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string worker_tags = 3;
  int worker_tags_size() const;
  void clear_worker_tags();
  static const int kWorkerTagsFieldNumber = 3;
  const ::std::string& worker_tags(int index) const;
  ::std::string* mutable_worker_tags(int index);
  void set_worker_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_worker_tags(int index, ::std::string&& value);
  #endif
  void set_worker_tags(int index, const char* value);
  void set_worker_tags(int index, const char* value, size_t size);
  ::std::string* add_worker_tags();
  void add_worker_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_worker_tags(::std::string&& value);
  #endif
  void add_worker_tags(const char* value);
  void add_worker_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& worker_tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_worker_tags();

  // string worker_address = 1;
  void clear_worker_address();
  static const int kWorkerAddressFieldNumber = 1;
  const ::std::string& worker_address() const;
  void set_worker_address(const ::std::string& value);
  #if LANG_CXX11
  void set_worker_address(::std::string&& value);
  #endif
  void set_worker_address(const char* value);
  void set_worker_address(const char* value, size_t size);
  ::std::string* mutable_worker_address();
  ::std::string* release_worker_address();
  void set_allocated_worker_address(::std::string* worker_address);

  // string transfer_address = 2;
  void clear_transfer_address();
  static const int kTransferAddressFieldNumber = 2;
  const ::std::string& transfer_address() const;
  void set_transfer_address(const ::std::string& value);
  #if LANG_CXX11
  void set_transfer_address(::std::string&& value);
  #endif
  void set_transfer_address(const char* value);
  void set_transfer_address(const char* value, size_t size);
  ::std::string* mutable_transfer_address();
  ::std::string* release_transfer_address();
  void set_allocated_transfer_address(::std::string* transfer_address);

  // int64 worker_uid = 4;
  void clear_worker_uid();
  static const int kWorkerUidFieldNumber = 4;
  ::google::protobuf::int64 worker_uid() const;
  void set_worker_uid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.RegisterWorkerUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> worker_tags_;
  ::google::protobuf::internal::ArenaStringPtr worker_address_;
  ::google::protobuf::internal::ArenaStringPtr transfer_address_;
  ::google::protobuf::int64 worker_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateJobUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.CreateJobUpdate) */ {
 public:
  CreateJobUpdate();
  virtual ~CreateJobUpdate();

  CreateJobUpdate(const CreateJobUpdate& from);

  inline CreateJobUpdate& operator=(const CreateJobUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateJobUpdate(CreateJobUpdate&& from) noexcept
    : CreateJobUpdate() {
    *this = ::std::move(from);
  }

  inline CreateJobUpdate& operator=(CreateJobUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateJobUpdate& default_instance();

  enum OptionalNumConsumersCase {
    kNumConsumers = 7,
    OPTIONAL_NUM_CONSUMERS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateJobUpdate* internal_default_instance() {
    return reinterpret_cast<const CreateJobUpdate*>(
               &_CreateJobUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(CreateJobUpdate* other);
  friend void swap(CreateJobUpdate& a, CreateJobUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateJobUpdate* New() const final {
    return CreateMaybeMessage<CreateJobUpdate>(NULL);
  }

  CreateJobUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateJobUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateJobUpdate& from);
  void MergeFrom(const CreateJobUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateJobUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.data.JobKeyDef job_key = 4;
  bool has_job_key() const;
  void clear_job_key();
  static const int kJobKeyFieldNumber = 4;
  private:
  const ::tensorflow::data::JobKeyDef& _internal_job_key() const;
  public:
  const ::tensorflow::data::JobKeyDef& job_key() const;
  ::tensorflow::data::JobKeyDef* release_job_key();
  ::tensorflow::data::JobKeyDef* mutable_job_key();
  void set_allocated_job_key(::tensorflow::data::JobKeyDef* job_key);

  // .tensorflow.data.ProcessingModeDef processing_mode_def = 9;
  bool has_processing_mode_def() const;
  void clear_processing_mode_def();
  static const int kProcessingModeDefFieldNumber = 9;
  private:
  const ::tensorflow::data::ProcessingModeDef& _internal_processing_mode_def() const;
  public:
  const ::tensorflow::data::ProcessingModeDef& processing_mode_def() const;
  ::tensorflow::data::ProcessingModeDef* release_processing_mode_def();
  ::tensorflow::data::ProcessingModeDef* mutable_processing_mode_def();
  void set_allocated_processing_mode_def(::tensorflow::data::ProcessingModeDef* processing_mode_def);

  // int64 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // int64 dataset_id = 2;
  void clear_dataset_id();
  static const int kDatasetIdFieldNumber = 2;
  ::google::protobuf::int64 dataset_id() const;
  void set_dataset_id(::google::protobuf::int64 value);

  // .tensorflow.data.TargetWorkers target_workers = 10;
  void clear_target_workers();
  static const int kTargetWorkersFieldNumber = 10;
  ::tensorflow::data::TargetWorkers target_workers() const;
  void set_target_workers(::tensorflow::data::TargetWorkers value);

  // int64 num_split_providers = 8;
  void clear_num_split_providers();
  static const int kNumSplitProvidersFieldNumber = 8;
  ::google::protobuf::int64 num_split_providers() const;
  void set_num_split_providers(::google::protobuf::int64 value);

  // int64 num_consumers = 7;
  private:
  bool has_num_consumers() const;
  public:
  void clear_num_consumers();
  static const int kNumConsumersFieldNumber = 7;
  ::google::protobuf::int64 num_consumers() const;
  void set_num_consumers(::google::protobuf::int64 value);

  void clear_optional_num_consumers();
  OptionalNumConsumersCase optional_num_consumers_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.CreateJobUpdate)
 private:
  void set_has_num_consumers();

  inline bool has_optional_num_consumers() const;
  inline void clear_has_optional_num_consumers();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::data::JobKeyDef* job_key_;
  ::tensorflow::data::ProcessingModeDef* processing_mode_def_;
  ::google::protobuf::int64 job_id_;
  ::google::protobuf::int64 dataset_id_;
  int target_workers_;
  ::google::protobuf::int64 num_split_providers_;
  union OptionalNumConsumersUnion {
    OptionalNumConsumersUnion() {}
    ::google::protobuf::int64 num_consumers_;
  } optional_num_consumers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ProduceSplitUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.ProduceSplitUpdate) */ {
 public:
  ProduceSplitUpdate();
  virtual ~ProduceSplitUpdate();

  ProduceSplitUpdate(const ProduceSplitUpdate& from);

  inline ProduceSplitUpdate& operator=(const ProduceSplitUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ProduceSplitUpdate(ProduceSplitUpdate&& from) noexcept
    : ProduceSplitUpdate() {
    *this = ::std::move(from);
  }

  inline ProduceSplitUpdate& operator=(ProduceSplitUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ProduceSplitUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ProduceSplitUpdate* internal_default_instance() {
    return reinterpret_cast<const ProduceSplitUpdate*>(
               &_ProduceSplitUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(ProduceSplitUpdate* other);
  friend void swap(ProduceSplitUpdate& a, ProduceSplitUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ProduceSplitUpdate* New() const final {
    return CreateMaybeMessage<ProduceSplitUpdate>(NULL);
  }

  ProduceSplitUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ProduceSplitUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ProduceSplitUpdate& from);
  void MergeFrom(const ProduceSplitUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProduceSplitUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // int64 iteration = 2;
  void clear_iteration();
  static const int kIterationFieldNumber = 2;
  ::google::protobuf::int64 iteration() const;
  void set_iteration(::google::protobuf::int64 value);

  // int64 split_provider_index = 4;
  void clear_split_provider_index();
  static const int kSplitProviderIndexFieldNumber = 4;
  ::google::protobuf::int64 split_provider_index() const;
  void set_split_provider_index(::google::protobuf::int64 value);

  // bool finished = 3;
  void clear_finished();
  static const int kFinishedFieldNumber = 3;
  bool finished() const;
  void set_finished(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.ProduceSplitUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 job_id_;
  ::google::protobuf::int64 iteration_;
  ::google::protobuf::int64 split_provider_index_;
  bool finished_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AcquireJobClientUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.AcquireJobClientUpdate) */ {
 public:
  AcquireJobClientUpdate();
  virtual ~AcquireJobClientUpdate();

  AcquireJobClientUpdate(const AcquireJobClientUpdate& from);

  inline AcquireJobClientUpdate& operator=(const AcquireJobClientUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AcquireJobClientUpdate(AcquireJobClientUpdate&& from) noexcept
    : AcquireJobClientUpdate() {
    *this = ::std::move(from);
  }

  inline AcquireJobClientUpdate& operator=(AcquireJobClientUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AcquireJobClientUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AcquireJobClientUpdate* internal_default_instance() {
    return reinterpret_cast<const AcquireJobClientUpdate*>(
               &_AcquireJobClientUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AcquireJobClientUpdate* other);
  friend void swap(AcquireJobClientUpdate& a, AcquireJobClientUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AcquireJobClientUpdate* New() const final {
    return CreateMaybeMessage<AcquireJobClientUpdate>(NULL);
  }

  AcquireJobClientUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AcquireJobClientUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AcquireJobClientUpdate& from);
  void MergeFrom(const AcquireJobClientUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AcquireJobClientUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // int64 job_client_id = 2;
  void clear_job_client_id();
  static const int kJobClientIdFieldNumber = 2;
  ::google::protobuf::int64 job_client_id() const;
  void set_job_client_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.AcquireJobClientUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 job_id_;
  ::google::protobuf::int64 job_client_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReleaseJobClientUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.ReleaseJobClientUpdate) */ {
 public:
  ReleaseJobClientUpdate();
  virtual ~ReleaseJobClientUpdate();

  ReleaseJobClientUpdate(const ReleaseJobClientUpdate& from);

  inline ReleaseJobClientUpdate& operator=(const ReleaseJobClientUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReleaseJobClientUpdate(ReleaseJobClientUpdate&& from) noexcept
    : ReleaseJobClientUpdate() {
    *this = ::std::move(from);
  }

  inline ReleaseJobClientUpdate& operator=(ReleaseJobClientUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReleaseJobClientUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReleaseJobClientUpdate* internal_default_instance() {
    return reinterpret_cast<const ReleaseJobClientUpdate*>(
               &_ReleaseJobClientUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ReleaseJobClientUpdate* other);
  friend void swap(ReleaseJobClientUpdate& a, ReleaseJobClientUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReleaseJobClientUpdate* New() const final {
    return CreateMaybeMessage<ReleaseJobClientUpdate>(NULL);
  }

  ReleaseJobClientUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReleaseJobClientUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReleaseJobClientUpdate& from);
  void MergeFrom(const ReleaseJobClientUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReleaseJobClientUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 job_client_id = 1;
  void clear_job_client_id();
  static const int kJobClientIdFieldNumber = 1;
  ::google::protobuf::int64 job_client_id() const;
  void set_job_client_id(::google::protobuf::int64 value);

  // int64 time_micros = 2;
  void clear_time_micros();
  static const int kTimeMicrosFieldNumber = 2;
  ::google::protobuf::int64 time_micros() const;
  void set_time_micros(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.ReleaseJobClientUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 job_client_id_;
  ::google::protobuf::int64 time_micros_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GarbageCollectJobUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.GarbageCollectJobUpdate) */ {
 public:
  GarbageCollectJobUpdate();
  virtual ~GarbageCollectJobUpdate();

  GarbageCollectJobUpdate(const GarbageCollectJobUpdate& from);

  inline GarbageCollectJobUpdate& operator=(const GarbageCollectJobUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GarbageCollectJobUpdate(GarbageCollectJobUpdate&& from) noexcept
    : GarbageCollectJobUpdate() {
    *this = ::std::move(from);
  }

  inline GarbageCollectJobUpdate& operator=(GarbageCollectJobUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GarbageCollectJobUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GarbageCollectJobUpdate* internal_default_instance() {
    return reinterpret_cast<const GarbageCollectJobUpdate*>(
               &_GarbageCollectJobUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(GarbageCollectJobUpdate* other);
  friend void swap(GarbageCollectJobUpdate& a, GarbageCollectJobUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GarbageCollectJobUpdate* New() const final {
    return CreateMaybeMessage<GarbageCollectJobUpdate>(NULL);
  }

  GarbageCollectJobUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GarbageCollectJobUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GarbageCollectJobUpdate& from);
  void MergeFrom(const GarbageCollectJobUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GarbageCollectJobUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 job_id = 1;
  void clear_job_id();
  static const int kJobIdFieldNumber = 1;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.GarbageCollectJobUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 job_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RemoveTaskUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.RemoveTaskUpdate) */ {
 public:
  RemoveTaskUpdate();
  virtual ~RemoveTaskUpdate();

  RemoveTaskUpdate(const RemoveTaskUpdate& from);

  inline RemoveTaskUpdate& operator=(const RemoveTaskUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoveTaskUpdate(RemoveTaskUpdate&& from) noexcept
    : RemoveTaskUpdate() {
    *this = ::std::move(from);
  }

  inline RemoveTaskUpdate& operator=(RemoveTaskUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoveTaskUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RemoveTaskUpdate* internal_default_instance() {
    return reinterpret_cast<const RemoveTaskUpdate*>(
               &_RemoveTaskUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(RemoveTaskUpdate* other);
  friend void swap(RemoveTaskUpdate& a, RemoveTaskUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoveTaskUpdate* New() const final {
    return CreateMaybeMessage<RemoveTaskUpdate>(NULL);
  }

  RemoveTaskUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RemoveTaskUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RemoveTaskUpdate& from);
  void MergeFrom(const RemoveTaskUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoveTaskUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 task_id = 1;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  ::google::protobuf::int64 task_id() const;
  void set_task_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.RemoveTaskUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 task_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskRejected : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.TaskRejected) */ {
 public:
  TaskRejected();
  virtual ~TaskRejected();

  TaskRejected(const TaskRejected& from);

  inline TaskRejected& operator=(const TaskRejected& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskRejected(TaskRejected&& from) noexcept
    : TaskRejected() {
    *this = ::std::move(from);
  }

  inline TaskRejected& operator=(TaskRejected&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskRejected& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskRejected* internal_default_instance() {
    return reinterpret_cast<const TaskRejected*>(
               &_TaskRejected_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(TaskRejected* other);
  friend void swap(TaskRejected& a, TaskRejected& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskRejected* New() const final {
    return CreateMaybeMessage<TaskRejected>(NULL);
  }

  TaskRejected* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskRejected>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskRejected& from);
  void MergeFrom(const TaskRejected& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskRejected* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 new_target_round = 1;
  void clear_new_target_round();
  static const int kNewTargetRoundFieldNumber = 1;
  ::google::protobuf::int64 new_target_round() const;
  void set_new_target_round(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.TaskRejected)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 new_target_round_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ClientHeartbeatUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.ClientHeartbeatUpdate) */ {
 public:
  ClientHeartbeatUpdate();
  virtual ~ClientHeartbeatUpdate();

  ClientHeartbeatUpdate(const ClientHeartbeatUpdate& from);

  inline ClientHeartbeatUpdate& operator=(const ClientHeartbeatUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClientHeartbeatUpdate(ClientHeartbeatUpdate&& from) noexcept
    : ClientHeartbeatUpdate() {
    *this = ::std::move(from);
  }

  inline ClientHeartbeatUpdate& operator=(ClientHeartbeatUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientHeartbeatUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClientHeartbeatUpdate* internal_default_instance() {
    return reinterpret_cast<const ClientHeartbeatUpdate*>(
               &_ClientHeartbeatUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(ClientHeartbeatUpdate* other);
  friend void swap(ClientHeartbeatUpdate& a, ClientHeartbeatUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClientHeartbeatUpdate* New() const final {
    return CreateMaybeMessage<ClientHeartbeatUpdate>(NULL);
  }

  ClientHeartbeatUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClientHeartbeatUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClientHeartbeatUpdate& from);
  void MergeFrom(const ClientHeartbeatUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClientHeartbeatUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.data.TaskRejected task_rejected = 3;
  bool has_task_rejected() const;
  void clear_task_rejected();
  static const int kTaskRejectedFieldNumber = 3;
  private:
  const ::tensorflow::data::TaskRejected& _internal_task_rejected() const;
  public:
  const ::tensorflow::data::TaskRejected& task_rejected() const;
  ::tensorflow::data::TaskRejected* release_task_rejected();
  ::tensorflow::data::TaskRejected* mutable_task_rejected();
  void set_allocated_task_rejected(::tensorflow::data::TaskRejected* task_rejected);

  // int64 job_client_id = 1;
  void clear_job_client_id();
  static const int kJobClientIdFieldNumber = 1;
  ::google::protobuf::int64 job_client_id() const;
  void set_job_client_id(::google::protobuf::int64 value);

  // bool task_accepted = 2;
  void clear_task_accepted();
  static const int kTaskAcceptedFieldNumber = 2;
  bool task_accepted() const;
  void set_task_accepted(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.ClientHeartbeatUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::data::TaskRejected* task_rejected_;
  ::google::protobuf::int64 job_client_id_;
  bool task_accepted_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreatePendingTaskUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.CreatePendingTaskUpdate) */ {
 public:
  CreatePendingTaskUpdate();
  virtual ~CreatePendingTaskUpdate();

  CreatePendingTaskUpdate(const CreatePendingTaskUpdate& from);

  inline CreatePendingTaskUpdate& operator=(const CreatePendingTaskUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreatePendingTaskUpdate(CreatePendingTaskUpdate&& from) noexcept
    : CreatePendingTaskUpdate() {
    *this = ::std::move(from);
  }

  inline CreatePendingTaskUpdate& operator=(CreatePendingTaskUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreatePendingTaskUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreatePendingTaskUpdate* internal_default_instance() {
    return reinterpret_cast<const CreatePendingTaskUpdate*>(
               &_CreatePendingTaskUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(CreatePendingTaskUpdate* other);
  friend void swap(CreatePendingTaskUpdate& a, CreatePendingTaskUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreatePendingTaskUpdate* New() const final {
    return CreateMaybeMessage<CreatePendingTaskUpdate>(NULL);
  }

  CreatePendingTaskUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreatePendingTaskUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreatePendingTaskUpdate& from);
  void MergeFrom(const CreatePendingTaskUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreatePendingTaskUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string worker_tags = 6;
  int worker_tags_size() const;
  void clear_worker_tags();
  static const int kWorkerTagsFieldNumber = 6;
  const ::std::string& worker_tags(int index) const;
  ::std::string* mutable_worker_tags(int index);
  void set_worker_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_worker_tags(int index, ::std::string&& value);
  #endif
  void set_worker_tags(int index, const char* value);
  void set_worker_tags(int index, const char* value, size_t size);
  ::std::string* add_worker_tags();
  void add_worker_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_worker_tags(::std::string&& value);
  #endif
  void add_worker_tags(const char* value);
  void add_worker_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& worker_tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_worker_tags();

  // string worker_address = 3;
  void clear_worker_address();
  static const int kWorkerAddressFieldNumber = 3;
  const ::std::string& worker_address() const;
  void set_worker_address(const ::std::string& value);
  #if LANG_CXX11
  void set_worker_address(::std::string&& value);
  #endif
  void set_worker_address(const char* value);
  void set_worker_address(const char* value, size_t size);
  ::std::string* mutable_worker_address();
  ::std::string* release_worker_address();
  void set_allocated_worker_address(::std::string* worker_address);

  // string transfer_address = 4;
  void clear_transfer_address();
  static const int kTransferAddressFieldNumber = 4;
  const ::std::string& transfer_address() const;
  void set_transfer_address(const ::std::string& value);
  #if LANG_CXX11
  void set_transfer_address(::std::string&& value);
  #endif
  void set_transfer_address(const char* value);
  void set_transfer_address(const char* value, size_t size);
  ::std::string* mutable_transfer_address();
  ::std::string* release_transfer_address();
  void set_allocated_transfer_address(::std::string* transfer_address);

  // int64 task_id = 1;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  ::google::protobuf::int64 task_id() const;
  void set_task_id(::google::protobuf::int64 value);

  // int64 job_id = 2;
  void clear_job_id();
  static const int kJobIdFieldNumber = 2;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // int64 starting_round = 5;
  void clear_starting_round();
  static const int kStartingRoundFieldNumber = 5;
  ::google::protobuf::int64 starting_round() const;
  void set_starting_round(::google::protobuf::int64 value);

  // int64 worker_uid = 7;
  void clear_worker_uid();
  static const int kWorkerUidFieldNumber = 7;
  ::google::protobuf::int64 worker_uid() const;
  void set_worker_uid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.CreatePendingTaskUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> worker_tags_;
  ::google::protobuf::internal::ArenaStringPtr worker_address_;
  ::google::protobuf::internal::ArenaStringPtr transfer_address_;
  ::google::protobuf::int64 task_id_;
  ::google::protobuf::int64 job_id_;
  ::google::protobuf::int64 starting_round_;
  ::google::protobuf::int64 worker_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CreateTaskUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.CreateTaskUpdate) */ {
 public:
  CreateTaskUpdate();
  virtual ~CreateTaskUpdate();

  CreateTaskUpdate(const CreateTaskUpdate& from);

  inline CreateTaskUpdate& operator=(const CreateTaskUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CreateTaskUpdate(CreateTaskUpdate&& from) noexcept
    : CreateTaskUpdate() {
    *this = ::std::move(from);
  }

  inline CreateTaskUpdate& operator=(CreateTaskUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateTaskUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CreateTaskUpdate* internal_default_instance() {
    return reinterpret_cast<const CreateTaskUpdate*>(
               &_CreateTaskUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(CreateTaskUpdate* other);
  friend void swap(CreateTaskUpdate& a, CreateTaskUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CreateTaskUpdate* New() const final {
    return CreateMaybeMessage<CreateTaskUpdate>(NULL);
  }

  CreateTaskUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CreateTaskUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CreateTaskUpdate& from);
  void MergeFrom(const CreateTaskUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateTaskUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string worker_tags = 7;
  int worker_tags_size() const;
  void clear_worker_tags();
  static const int kWorkerTagsFieldNumber = 7;
  const ::std::string& worker_tags(int index) const;
  ::std::string* mutable_worker_tags(int index);
  void set_worker_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_worker_tags(int index, ::std::string&& value);
  #endif
  void set_worker_tags(int index, const char* value);
  void set_worker_tags(int index, const char* value, size_t size);
  ::std::string* add_worker_tags();
  void add_worker_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_worker_tags(::std::string&& value);
  #endif
  void add_worker_tags(const char* value);
  void add_worker_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& worker_tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_worker_tags();

  // string worker_address = 4;
  void clear_worker_address();
  static const int kWorkerAddressFieldNumber = 4;
  const ::std::string& worker_address() const;
  void set_worker_address(const ::std::string& value);
  #if LANG_CXX11
  void set_worker_address(::std::string&& value);
  #endif
  void set_worker_address(const char* value);
  void set_worker_address(const char* value, size_t size);
  ::std::string* mutable_worker_address();
  ::std::string* release_worker_address();
  void set_allocated_worker_address(::std::string* worker_address);

  // string transfer_address = 6;
  void clear_transfer_address();
  static const int kTransferAddressFieldNumber = 6;
  const ::std::string& transfer_address() const;
  void set_transfer_address(const ::std::string& value);
  #if LANG_CXX11
  void set_transfer_address(::std::string&& value);
  #endif
  void set_transfer_address(const char* value);
  void set_transfer_address(const char* value, size_t size);
  ::std::string* mutable_transfer_address();
  ::std::string* release_transfer_address();
  void set_allocated_transfer_address(::std::string* transfer_address);

  // int64 task_id = 1;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  ::google::protobuf::int64 task_id() const;
  void set_task_id(::google::protobuf::int64 value);

  // int64 job_id = 2;
  void clear_job_id();
  static const int kJobIdFieldNumber = 2;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // int64 worker_uid = 8;
  void clear_worker_uid();
  static const int kWorkerUidFieldNumber = 8;
  ::google::protobuf::int64 worker_uid() const;
  void set_worker_uid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.CreateTaskUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> worker_tags_;
  ::google::protobuf::internal::ArenaStringPtr worker_address_;
  ::google::protobuf::internal::ArenaStringPtr transfer_address_;
  ::google::protobuf::int64 task_id_;
  ::google::protobuf::int64 job_id_;
  ::google::protobuf::int64 worker_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FinishTaskUpdate : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.FinishTaskUpdate) */ {
 public:
  FinishTaskUpdate();
  virtual ~FinishTaskUpdate();

  FinishTaskUpdate(const FinishTaskUpdate& from);

  inline FinishTaskUpdate& operator=(const FinishTaskUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FinishTaskUpdate(FinishTaskUpdate&& from) noexcept
    : FinishTaskUpdate() {
    *this = ::std::move(from);
  }

  inline FinishTaskUpdate& operator=(FinishTaskUpdate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FinishTaskUpdate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FinishTaskUpdate* internal_default_instance() {
    return reinterpret_cast<const FinishTaskUpdate*>(
               &_FinishTaskUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(FinishTaskUpdate* other);
  friend void swap(FinishTaskUpdate& a, FinishTaskUpdate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FinishTaskUpdate* New() const final {
    return CreateMaybeMessage<FinishTaskUpdate>(NULL);
  }

  FinishTaskUpdate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FinishTaskUpdate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FinishTaskUpdate& from);
  void MergeFrom(const FinishTaskUpdate& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FinishTaskUpdate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 task_id = 1;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  ::google::protobuf::int64 task_id() const;
  void set_task_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.FinishTaskUpdate)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 task_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Update

// .tensorflow.data.RegisterDatasetUpdate register_dataset = 1;
inline bool Update::has_register_dataset() const {
  return update_type_case() == kRegisterDataset;
}
inline void Update::set_has_register_dataset() {
  _oneof_case_[0] = kRegisterDataset;
}
inline void Update::clear_register_dataset() {
  if (has_register_dataset()) {
    delete update_type_.register_dataset_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::RegisterDatasetUpdate& Update::_internal_register_dataset() const {
  return *update_type_.register_dataset_;
}
inline ::tensorflow::data::RegisterDatasetUpdate* Update::release_register_dataset() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.register_dataset)
  if (has_register_dataset()) {
    clear_has_update_type();
      ::tensorflow::data::RegisterDatasetUpdate* temp = update_type_.register_dataset_;
    update_type_.register_dataset_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::RegisterDatasetUpdate& Update::register_dataset() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.register_dataset)
  return has_register_dataset()
      ? *update_type_.register_dataset_
      : *reinterpret_cast< ::tensorflow::data::RegisterDatasetUpdate*>(&::tensorflow::data::_RegisterDatasetUpdate_default_instance_);
}
inline ::tensorflow::data::RegisterDatasetUpdate* Update::mutable_register_dataset() {
  if (!has_register_dataset()) {
    clear_update_type();
    set_has_register_dataset();
    update_type_.register_dataset_ = CreateMaybeMessage< ::tensorflow::data::RegisterDatasetUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.register_dataset)
  return update_type_.register_dataset_;
}

// .tensorflow.data.RegisterWorkerUpdate register_worker = 5;
inline bool Update::has_register_worker() const {
  return update_type_case() == kRegisterWorker;
}
inline void Update::set_has_register_worker() {
  _oneof_case_[0] = kRegisterWorker;
}
inline void Update::clear_register_worker() {
  if (has_register_worker()) {
    delete update_type_.register_worker_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::RegisterWorkerUpdate& Update::_internal_register_worker() const {
  return *update_type_.register_worker_;
}
inline ::tensorflow::data::RegisterWorkerUpdate* Update::release_register_worker() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.register_worker)
  if (has_register_worker()) {
    clear_has_update_type();
      ::tensorflow::data::RegisterWorkerUpdate* temp = update_type_.register_worker_;
    update_type_.register_worker_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::RegisterWorkerUpdate& Update::register_worker() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.register_worker)
  return has_register_worker()
      ? *update_type_.register_worker_
      : *reinterpret_cast< ::tensorflow::data::RegisterWorkerUpdate*>(&::tensorflow::data::_RegisterWorkerUpdate_default_instance_);
}
inline ::tensorflow::data::RegisterWorkerUpdate* Update::mutable_register_worker() {
  if (!has_register_worker()) {
    clear_update_type();
    set_has_register_worker();
    update_type_.register_worker_ = CreateMaybeMessage< ::tensorflow::data::RegisterWorkerUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.register_worker)
  return update_type_.register_worker_;
}

// .tensorflow.data.CreateJobUpdate create_job = 2;
inline bool Update::has_create_job() const {
  return update_type_case() == kCreateJob;
}
inline void Update::set_has_create_job() {
  _oneof_case_[0] = kCreateJob;
}
inline void Update::clear_create_job() {
  if (has_create_job()) {
    delete update_type_.create_job_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::CreateJobUpdate& Update::_internal_create_job() const {
  return *update_type_.create_job_;
}
inline ::tensorflow::data::CreateJobUpdate* Update::release_create_job() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.create_job)
  if (has_create_job()) {
    clear_has_update_type();
      ::tensorflow::data::CreateJobUpdate* temp = update_type_.create_job_;
    update_type_.create_job_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::CreateJobUpdate& Update::create_job() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.create_job)
  return has_create_job()
      ? *update_type_.create_job_
      : *reinterpret_cast< ::tensorflow::data::CreateJobUpdate*>(&::tensorflow::data::_CreateJobUpdate_default_instance_);
}
inline ::tensorflow::data::CreateJobUpdate* Update::mutable_create_job() {
  if (!has_create_job()) {
    clear_update_type();
    set_has_create_job();
    update_type_.create_job_ = CreateMaybeMessage< ::tensorflow::data::CreateJobUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.create_job)
  return update_type_.create_job_;
}

// .tensorflow.data.ProduceSplitUpdate produce_split = 8;
inline bool Update::has_produce_split() const {
  return update_type_case() == kProduceSplit;
}
inline void Update::set_has_produce_split() {
  _oneof_case_[0] = kProduceSplit;
}
inline void Update::clear_produce_split() {
  if (has_produce_split()) {
    delete update_type_.produce_split_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::ProduceSplitUpdate& Update::_internal_produce_split() const {
  return *update_type_.produce_split_;
}
inline ::tensorflow::data::ProduceSplitUpdate* Update::release_produce_split() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.produce_split)
  if (has_produce_split()) {
    clear_has_update_type();
      ::tensorflow::data::ProduceSplitUpdate* temp = update_type_.produce_split_;
    update_type_.produce_split_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::ProduceSplitUpdate& Update::produce_split() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.produce_split)
  return has_produce_split()
      ? *update_type_.produce_split_
      : *reinterpret_cast< ::tensorflow::data::ProduceSplitUpdate*>(&::tensorflow::data::_ProduceSplitUpdate_default_instance_);
}
inline ::tensorflow::data::ProduceSplitUpdate* Update::mutable_produce_split() {
  if (!has_produce_split()) {
    clear_update_type();
    set_has_produce_split();
    update_type_.produce_split_ = CreateMaybeMessage< ::tensorflow::data::ProduceSplitUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.produce_split)
  return update_type_.produce_split_;
}

// .tensorflow.data.AcquireJobClientUpdate acquire_job_client = 6;
inline bool Update::has_acquire_job_client() const {
  return update_type_case() == kAcquireJobClient;
}
inline void Update::set_has_acquire_job_client() {
  _oneof_case_[0] = kAcquireJobClient;
}
inline void Update::clear_acquire_job_client() {
  if (has_acquire_job_client()) {
    delete update_type_.acquire_job_client_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::AcquireJobClientUpdate& Update::_internal_acquire_job_client() const {
  return *update_type_.acquire_job_client_;
}
inline ::tensorflow::data::AcquireJobClientUpdate* Update::release_acquire_job_client() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.acquire_job_client)
  if (has_acquire_job_client()) {
    clear_has_update_type();
      ::tensorflow::data::AcquireJobClientUpdate* temp = update_type_.acquire_job_client_;
    update_type_.acquire_job_client_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::AcquireJobClientUpdate& Update::acquire_job_client() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.acquire_job_client)
  return has_acquire_job_client()
      ? *update_type_.acquire_job_client_
      : *reinterpret_cast< ::tensorflow::data::AcquireJobClientUpdate*>(&::tensorflow::data::_AcquireJobClientUpdate_default_instance_);
}
inline ::tensorflow::data::AcquireJobClientUpdate* Update::mutable_acquire_job_client() {
  if (!has_acquire_job_client()) {
    clear_update_type();
    set_has_acquire_job_client();
    update_type_.acquire_job_client_ = CreateMaybeMessage< ::tensorflow::data::AcquireJobClientUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.acquire_job_client)
  return update_type_.acquire_job_client_;
}

// .tensorflow.data.ReleaseJobClientUpdate release_job_client = 7;
inline bool Update::has_release_job_client() const {
  return update_type_case() == kReleaseJobClient;
}
inline void Update::set_has_release_job_client() {
  _oneof_case_[0] = kReleaseJobClient;
}
inline void Update::clear_release_job_client() {
  if (has_release_job_client()) {
    delete update_type_.release_job_client_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::ReleaseJobClientUpdate& Update::_internal_release_job_client() const {
  return *update_type_.release_job_client_;
}
inline ::tensorflow::data::ReleaseJobClientUpdate* Update::release_release_job_client() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.release_job_client)
  if (has_release_job_client()) {
    clear_has_update_type();
      ::tensorflow::data::ReleaseJobClientUpdate* temp = update_type_.release_job_client_;
    update_type_.release_job_client_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::ReleaseJobClientUpdate& Update::release_job_client() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.release_job_client)
  return has_release_job_client()
      ? *update_type_.release_job_client_
      : *reinterpret_cast< ::tensorflow::data::ReleaseJobClientUpdate*>(&::tensorflow::data::_ReleaseJobClientUpdate_default_instance_);
}
inline ::tensorflow::data::ReleaseJobClientUpdate* Update::mutable_release_job_client() {
  if (!has_release_job_client()) {
    clear_update_type();
    set_has_release_job_client();
    update_type_.release_job_client_ = CreateMaybeMessage< ::tensorflow::data::ReleaseJobClientUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.release_job_client)
  return update_type_.release_job_client_;
}

// .tensorflow.data.GarbageCollectJobUpdate garbage_collect_job = 12;
inline bool Update::has_garbage_collect_job() const {
  return update_type_case() == kGarbageCollectJob;
}
inline void Update::set_has_garbage_collect_job() {
  _oneof_case_[0] = kGarbageCollectJob;
}
inline void Update::clear_garbage_collect_job() {
  if (has_garbage_collect_job()) {
    delete update_type_.garbage_collect_job_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::GarbageCollectJobUpdate& Update::_internal_garbage_collect_job() const {
  return *update_type_.garbage_collect_job_;
}
inline ::tensorflow::data::GarbageCollectJobUpdate* Update::release_garbage_collect_job() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.garbage_collect_job)
  if (has_garbage_collect_job()) {
    clear_has_update_type();
      ::tensorflow::data::GarbageCollectJobUpdate* temp = update_type_.garbage_collect_job_;
    update_type_.garbage_collect_job_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::GarbageCollectJobUpdate& Update::garbage_collect_job() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.garbage_collect_job)
  return has_garbage_collect_job()
      ? *update_type_.garbage_collect_job_
      : *reinterpret_cast< ::tensorflow::data::GarbageCollectJobUpdate*>(&::tensorflow::data::_GarbageCollectJobUpdate_default_instance_);
}
inline ::tensorflow::data::GarbageCollectJobUpdate* Update::mutable_garbage_collect_job() {
  if (!has_garbage_collect_job()) {
    clear_update_type();
    set_has_garbage_collect_job();
    update_type_.garbage_collect_job_ = CreateMaybeMessage< ::tensorflow::data::GarbageCollectJobUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.garbage_collect_job)
  return update_type_.garbage_collect_job_;
}

// .tensorflow.data.RemoveTaskUpdate remove_task = 11;
inline bool Update::has_remove_task() const {
  return update_type_case() == kRemoveTask;
}
inline void Update::set_has_remove_task() {
  _oneof_case_[0] = kRemoveTask;
}
inline void Update::clear_remove_task() {
  if (has_remove_task()) {
    delete update_type_.remove_task_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::RemoveTaskUpdate& Update::_internal_remove_task() const {
  return *update_type_.remove_task_;
}
inline ::tensorflow::data::RemoveTaskUpdate* Update::release_remove_task() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.remove_task)
  if (has_remove_task()) {
    clear_has_update_type();
      ::tensorflow::data::RemoveTaskUpdate* temp = update_type_.remove_task_;
    update_type_.remove_task_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::RemoveTaskUpdate& Update::remove_task() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.remove_task)
  return has_remove_task()
      ? *update_type_.remove_task_
      : *reinterpret_cast< ::tensorflow::data::RemoveTaskUpdate*>(&::tensorflow::data::_RemoveTaskUpdate_default_instance_);
}
inline ::tensorflow::data::RemoveTaskUpdate* Update::mutable_remove_task() {
  if (!has_remove_task()) {
    clear_update_type();
    set_has_remove_task();
    update_type_.remove_task_ = CreateMaybeMessage< ::tensorflow::data::RemoveTaskUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.remove_task)
  return update_type_.remove_task_;
}

// .tensorflow.data.CreatePendingTaskUpdate create_pending_task = 9;
inline bool Update::has_create_pending_task() const {
  return update_type_case() == kCreatePendingTask;
}
inline void Update::set_has_create_pending_task() {
  _oneof_case_[0] = kCreatePendingTask;
}
inline void Update::clear_create_pending_task() {
  if (has_create_pending_task()) {
    delete update_type_.create_pending_task_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::CreatePendingTaskUpdate& Update::_internal_create_pending_task() const {
  return *update_type_.create_pending_task_;
}
inline ::tensorflow::data::CreatePendingTaskUpdate* Update::release_create_pending_task() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.create_pending_task)
  if (has_create_pending_task()) {
    clear_has_update_type();
      ::tensorflow::data::CreatePendingTaskUpdate* temp = update_type_.create_pending_task_;
    update_type_.create_pending_task_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::CreatePendingTaskUpdate& Update::create_pending_task() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.create_pending_task)
  return has_create_pending_task()
      ? *update_type_.create_pending_task_
      : *reinterpret_cast< ::tensorflow::data::CreatePendingTaskUpdate*>(&::tensorflow::data::_CreatePendingTaskUpdate_default_instance_);
}
inline ::tensorflow::data::CreatePendingTaskUpdate* Update::mutable_create_pending_task() {
  if (!has_create_pending_task()) {
    clear_update_type();
    set_has_create_pending_task();
    update_type_.create_pending_task_ = CreateMaybeMessage< ::tensorflow::data::CreatePendingTaskUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.create_pending_task)
  return update_type_.create_pending_task_;
}

// .tensorflow.data.ClientHeartbeatUpdate client_heartbeat = 10;
inline bool Update::has_client_heartbeat() const {
  return update_type_case() == kClientHeartbeat;
}
inline void Update::set_has_client_heartbeat() {
  _oneof_case_[0] = kClientHeartbeat;
}
inline void Update::clear_client_heartbeat() {
  if (has_client_heartbeat()) {
    delete update_type_.client_heartbeat_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::ClientHeartbeatUpdate& Update::_internal_client_heartbeat() const {
  return *update_type_.client_heartbeat_;
}
inline ::tensorflow::data::ClientHeartbeatUpdate* Update::release_client_heartbeat() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.client_heartbeat)
  if (has_client_heartbeat()) {
    clear_has_update_type();
      ::tensorflow::data::ClientHeartbeatUpdate* temp = update_type_.client_heartbeat_;
    update_type_.client_heartbeat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::ClientHeartbeatUpdate& Update::client_heartbeat() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.client_heartbeat)
  return has_client_heartbeat()
      ? *update_type_.client_heartbeat_
      : *reinterpret_cast< ::tensorflow::data::ClientHeartbeatUpdate*>(&::tensorflow::data::_ClientHeartbeatUpdate_default_instance_);
}
inline ::tensorflow::data::ClientHeartbeatUpdate* Update::mutable_client_heartbeat() {
  if (!has_client_heartbeat()) {
    clear_update_type();
    set_has_client_heartbeat();
    update_type_.client_heartbeat_ = CreateMaybeMessage< ::tensorflow::data::ClientHeartbeatUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.client_heartbeat)
  return update_type_.client_heartbeat_;
}

// .tensorflow.data.CreateTaskUpdate create_task = 3;
inline bool Update::has_create_task() const {
  return update_type_case() == kCreateTask;
}
inline void Update::set_has_create_task() {
  _oneof_case_[0] = kCreateTask;
}
inline void Update::clear_create_task() {
  if (has_create_task()) {
    delete update_type_.create_task_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::CreateTaskUpdate& Update::_internal_create_task() const {
  return *update_type_.create_task_;
}
inline ::tensorflow::data::CreateTaskUpdate* Update::release_create_task() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.create_task)
  if (has_create_task()) {
    clear_has_update_type();
      ::tensorflow::data::CreateTaskUpdate* temp = update_type_.create_task_;
    update_type_.create_task_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::CreateTaskUpdate& Update::create_task() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.create_task)
  return has_create_task()
      ? *update_type_.create_task_
      : *reinterpret_cast< ::tensorflow::data::CreateTaskUpdate*>(&::tensorflow::data::_CreateTaskUpdate_default_instance_);
}
inline ::tensorflow::data::CreateTaskUpdate* Update::mutable_create_task() {
  if (!has_create_task()) {
    clear_update_type();
    set_has_create_task();
    update_type_.create_task_ = CreateMaybeMessage< ::tensorflow::data::CreateTaskUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.create_task)
  return update_type_.create_task_;
}

// .tensorflow.data.FinishTaskUpdate finish_task = 4;
inline bool Update::has_finish_task() const {
  return update_type_case() == kFinishTask;
}
inline void Update::set_has_finish_task() {
  _oneof_case_[0] = kFinishTask;
}
inline void Update::clear_finish_task() {
  if (has_finish_task()) {
    delete update_type_.finish_task_;
    clear_has_update_type();
  }
}
inline const ::tensorflow::data::FinishTaskUpdate& Update::_internal_finish_task() const {
  return *update_type_.finish_task_;
}
inline ::tensorflow::data::FinishTaskUpdate* Update::release_finish_task() {
  // @@protoc_insertion_point(field_release:tensorflow.data.Update.finish_task)
  if (has_finish_task()) {
    clear_has_update_type();
      ::tensorflow::data::FinishTaskUpdate* temp = update_type_.finish_task_;
    update_type_.finish_task_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::FinishTaskUpdate& Update::finish_task() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.Update.finish_task)
  return has_finish_task()
      ? *update_type_.finish_task_
      : *reinterpret_cast< ::tensorflow::data::FinishTaskUpdate*>(&::tensorflow::data::_FinishTaskUpdate_default_instance_);
}
inline ::tensorflow::data::FinishTaskUpdate* Update::mutable_finish_task() {
  if (!has_finish_task()) {
    clear_update_type();
    set_has_finish_task();
    update_type_.finish_task_ = CreateMaybeMessage< ::tensorflow::data::FinishTaskUpdate >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.Update.finish_task)
  return update_type_.finish_task_;
}

inline bool Update::has_update_type() const {
  return update_type_case() != UPDATE_TYPE_NOT_SET;
}
inline void Update::clear_has_update_type() {
  _oneof_case_[0] = UPDATE_TYPE_NOT_SET;
}
inline Update::UpdateTypeCase Update::update_type_case() const {
  return Update::UpdateTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegisterDatasetUpdate

// int64 dataset_id = 1;
inline void RegisterDatasetUpdate::clear_dataset_id() {
  dataset_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RegisterDatasetUpdate::dataset_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.RegisterDatasetUpdate.dataset_id)
  return dataset_id_;
}
inline void RegisterDatasetUpdate::set_dataset_id(::google::protobuf::int64 value) {
  
  dataset_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.RegisterDatasetUpdate.dataset_id)
}

// uint64 fingerprint = 2;
inline void RegisterDatasetUpdate::clear_fingerprint() {
  fingerprint_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegisterDatasetUpdate::fingerprint() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.RegisterDatasetUpdate.fingerprint)
  return fingerprint_;
}
inline void RegisterDatasetUpdate::set_fingerprint(::google::protobuf::uint64 value) {
  
  fingerprint_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.RegisterDatasetUpdate.fingerprint)
}

// .tensorflow.data.DataServiceMetadata metadata = 3;
inline bool RegisterDatasetUpdate::has_metadata() const {
  return this != internal_default_instance() && metadata_ != NULL;
}
inline const ::tensorflow::data::DataServiceMetadata& RegisterDatasetUpdate::_internal_metadata() const {
  return *metadata_;
}
inline const ::tensorflow::data::DataServiceMetadata& RegisterDatasetUpdate::metadata() const {
  const ::tensorflow::data::DataServiceMetadata* p = metadata_;
  // @@protoc_insertion_point(field_get:tensorflow.data.RegisterDatasetUpdate.metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::DataServiceMetadata*>(
      &::tensorflow::data::_DataServiceMetadata_default_instance_);
}
inline ::tensorflow::data::DataServiceMetadata* RegisterDatasetUpdate::release_metadata() {
  // @@protoc_insertion_point(field_release:tensorflow.data.RegisterDatasetUpdate.metadata)
  
  ::tensorflow::data::DataServiceMetadata* temp = metadata_;
  metadata_ = NULL;
  return temp;
}
inline ::tensorflow::data::DataServiceMetadata* RegisterDatasetUpdate::mutable_metadata() {
  
  if (metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::DataServiceMetadata>(GetArenaNoVirtual());
    metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.RegisterDatasetUpdate.metadata)
  return metadata_;
}
inline void RegisterDatasetUpdate::set_allocated_metadata(::tensorflow::data::DataServiceMetadata* metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(metadata_);
  }
  if (metadata) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    
  } else {
    
  }
  metadata_ = metadata;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.RegisterDatasetUpdate.metadata)
}

// -------------------------------------------------------------------

// RegisterWorkerUpdate

// string worker_address = 1;
inline void RegisterWorkerUpdate::clear_worker_address() {
  worker_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterWorkerUpdate::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.RegisterWorkerUpdate.worker_address)
  return worker_address_.GetNoArena();
}
inline void RegisterWorkerUpdate::set_worker_address(const ::std::string& value) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.RegisterWorkerUpdate.worker_address)
}
#if LANG_CXX11
inline void RegisterWorkerUpdate::set_worker_address(::std::string&& value) {
  
  worker_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.RegisterWorkerUpdate.worker_address)
}
#endif
inline void RegisterWorkerUpdate::set_worker_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.RegisterWorkerUpdate.worker_address)
}
inline void RegisterWorkerUpdate::set_worker_address(const char* value, size_t size) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.RegisterWorkerUpdate.worker_address)
}
inline ::std::string* RegisterWorkerUpdate::mutable_worker_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.RegisterWorkerUpdate.worker_address)
  return worker_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterWorkerUpdate::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.RegisterWorkerUpdate.worker_address)
  
  return worker_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterWorkerUpdate::set_allocated_worker_address(::std::string* worker_address) {
  if (worker_address != NULL) {
    
  } else {
    
  }
  worker_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worker_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.RegisterWorkerUpdate.worker_address)
}

// string transfer_address = 2;
inline void RegisterWorkerUpdate::clear_transfer_address() {
  transfer_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RegisterWorkerUpdate::transfer_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.RegisterWorkerUpdate.transfer_address)
  return transfer_address_.GetNoArena();
}
inline void RegisterWorkerUpdate::set_transfer_address(const ::std::string& value) {
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.RegisterWorkerUpdate.transfer_address)
}
#if LANG_CXX11
inline void RegisterWorkerUpdate::set_transfer_address(::std::string&& value) {
  
  transfer_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.RegisterWorkerUpdate.transfer_address)
}
#endif
inline void RegisterWorkerUpdate::set_transfer_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.RegisterWorkerUpdate.transfer_address)
}
inline void RegisterWorkerUpdate::set_transfer_address(const char* value, size_t size) {
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.RegisterWorkerUpdate.transfer_address)
}
inline ::std::string* RegisterWorkerUpdate::mutable_transfer_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.RegisterWorkerUpdate.transfer_address)
  return transfer_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RegisterWorkerUpdate::release_transfer_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.RegisterWorkerUpdate.transfer_address)
  
  return transfer_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RegisterWorkerUpdate::set_allocated_transfer_address(::std::string* transfer_address) {
  if (transfer_address != NULL) {
    
  } else {
    
  }
  transfer_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transfer_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.RegisterWorkerUpdate.transfer_address)
}

// repeated string worker_tags = 3;
inline int RegisterWorkerUpdate::worker_tags_size() const {
  return worker_tags_.size();
}
inline void RegisterWorkerUpdate::clear_worker_tags() {
  worker_tags_.Clear();
}
inline const ::std::string& RegisterWorkerUpdate::worker_tags(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.RegisterWorkerUpdate.worker_tags)
  return worker_tags_.Get(index);
}
inline ::std::string* RegisterWorkerUpdate::mutable_worker_tags(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.RegisterWorkerUpdate.worker_tags)
  return worker_tags_.Mutable(index);
}
inline void RegisterWorkerUpdate::set_worker_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.RegisterWorkerUpdate.worker_tags)
  worker_tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void RegisterWorkerUpdate::set_worker_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.RegisterWorkerUpdate.worker_tags)
  worker_tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void RegisterWorkerUpdate::set_worker_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  worker_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.data.RegisterWorkerUpdate.worker_tags)
}
inline void RegisterWorkerUpdate::set_worker_tags(int index, const char* value, size_t size) {
  worker_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.RegisterWorkerUpdate.worker_tags)
}
inline ::std::string* RegisterWorkerUpdate::add_worker_tags() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.data.RegisterWorkerUpdate.worker_tags)
  return worker_tags_.Add();
}
inline void RegisterWorkerUpdate::add_worker_tags(const ::std::string& value) {
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.data.RegisterWorkerUpdate.worker_tags)
}
#if LANG_CXX11
inline void RegisterWorkerUpdate::add_worker_tags(::std::string&& value) {
  worker_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.data.RegisterWorkerUpdate.worker_tags)
}
#endif
inline void RegisterWorkerUpdate::add_worker_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.data.RegisterWorkerUpdate.worker_tags)
}
inline void RegisterWorkerUpdate::add_worker_tags(const char* value, size_t size) {
  worker_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.data.RegisterWorkerUpdate.worker_tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RegisterWorkerUpdate::worker_tags() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.RegisterWorkerUpdate.worker_tags)
  return worker_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RegisterWorkerUpdate::mutable_worker_tags() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.RegisterWorkerUpdate.worker_tags)
  return &worker_tags_;
}

// int64 worker_uid = 4;
inline void RegisterWorkerUpdate::clear_worker_uid() {
  worker_uid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RegisterWorkerUpdate::worker_uid() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.RegisterWorkerUpdate.worker_uid)
  return worker_uid_;
}
inline void RegisterWorkerUpdate::set_worker_uid(::google::protobuf::int64 value) {
  
  worker_uid_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.RegisterWorkerUpdate.worker_uid)
}

// -------------------------------------------------------------------

// CreateJobUpdate

// int64 job_id = 1;
inline void CreateJobUpdate::clear_job_id() {
  job_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreateJobUpdate::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateJobUpdate.job_id)
  return job_id_;
}
inline void CreateJobUpdate::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateJobUpdate.job_id)
}

// int64 dataset_id = 2;
inline void CreateJobUpdate::clear_dataset_id() {
  dataset_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreateJobUpdate::dataset_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateJobUpdate.dataset_id)
  return dataset_id_;
}
inline void CreateJobUpdate::set_dataset_id(::google::protobuf::int64 value) {
  
  dataset_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateJobUpdate.dataset_id)
}

// .tensorflow.data.ProcessingModeDef processing_mode_def = 9;
inline bool CreateJobUpdate::has_processing_mode_def() const {
  return this != internal_default_instance() && processing_mode_def_ != NULL;
}
inline const ::tensorflow::data::ProcessingModeDef& CreateJobUpdate::_internal_processing_mode_def() const {
  return *processing_mode_def_;
}
inline const ::tensorflow::data::ProcessingModeDef& CreateJobUpdate::processing_mode_def() const {
  const ::tensorflow::data::ProcessingModeDef* p = processing_mode_def_;
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateJobUpdate.processing_mode_def)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::ProcessingModeDef*>(
      &::tensorflow::data::_ProcessingModeDef_default_instance_);
}
inline ::tensorflow::data::ProcessingModeDef* CreateJobUpdate::release_processing_mode_def() {
  // @@protoc_insertion_point(field_release:tensorflow.data.CreateJobUpdate.processing_mode_def)
  
  ::tensorflow::data::ProcessingModeDef* temp = processing_mode_def_;
  processing_mode_def_ = NULL;
  return temp;
}
inline ::tensorflow::data::ProcessingModeDef* CreateJobUpdate::mutable_processing_mode_def() {
  
  if (processing_mode_def_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::ProcessingModeDef>(GetArenaNoVirtual());
    processing_mode_def_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.CreateJobUpdate.processing_mode_def)
  return processing_mode_def_;
}
inline void CreateJobUpdate::set_allocated_processing_mode_def(::tensorflow::data::ProcessingModeDef* processing_mode_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(processing_mode_def_);
  }
  if (processing_mode_def) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      processing_mode_def = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, processing_mode_def, submessage_arena);
    }
    
  } else {
    
  }
  processing_mode_def_ = processing_mode_def;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.CreateJobUpdate.processing_mode_def)
}

// int64 num_split_providers = 8;
inline void CreateJobUpdate::clear_num_split_providers() {
  num_split_providers_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreateJobUpdate::num_split_providers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateJobUpdate.num_split_providers)
  return num_split_providers_;
}
inline void CreateJobUpdate::set_num_split_providers(::google::protobuf::int64 value) {
  
  num_split_providers_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateJobUpdate.num_split_providers)
}

// .tensorflow.data.JobKeyDef job_key = 4;
inline bool CreateJobUpdate::has_job_key() const {
  return this != internal_default_instance() && job_key_ != NULL;
}
inline const ::tensorflow::data::JobKeyDef& CreateJobUpdate::_internal_job_key() const {
  return *job_key_;
}
inline const ::tensorflow::data::JobKeyDef& CreateJobUpdate::job_key() const {
  const ::tensorflow::data::JobKeyDef* p = job_key_;
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateJobUpdate.job_key)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::JobKeyDef*>(
      &::tensorflow::data::_JobKeyDef_default_instance_);
}
inline ::tensorflow::data::JobKeyDef* CreateJobUpdate::release_job_key() {
  // @@protoc_insertion_point(field_release:tensorflow.data.CreateJobUpdate.job_key)
  
  ::tensorflow::data::JobKeyDef* temp = job_key_;
  job_key_ = NULL;
  return temp;
}
inline ::tensorflow::data::JobKeyDef* CreateJobUpdate::mutable_job_key() {
  
  if (job_key_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::JobKeyDef>(GetArenaNoVirtual());
    job_key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.CreateJobUpdate.job_key)
  return job_key_;
}
inline void CreateJobUpdate::set_allocated_job_key(::tensorflow::data::JobKeyDef* job_key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(job_key_);
  }
  if (job_key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      job_key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, job_key, submessage_arena);
    }
    
  } else {
    
  }
  job_key_ = job_key;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.CreateJobUpdate.job_key)
}

// int64 num_consumers = 7;
inline bool CreateJobUpdate::has_num_consumers() const {
  return optional_num_consumers_case() == kNumConsumers;
}
inline void CreateJobUpdate::set_has_num_consumers() {
  _oneof_case_[0] = kNumConsumers;
}
inline void CreateJobUpdate::clear_num_consumers() {
  if (has_num_consumers()) {
    optional_num_consumers_.num_consumers_ = GOOGLE_LONGLONG(0);
    clear_has_optional_num_consumers();
  }
}
inline ::google::protobuf::int64 CreateJobUpdate::num_consumers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateJobUpdate.num_consumers)
  if (has_num_consumers()) {
    return optional_num_consumers_.num_consumers_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void CreateJobUpdate::set_num_consumers(::google::protobuf::int64 value) {
  if (!has_num_consumers()) {
    clear_optional_num_consumers();
    set_has_num_consumers();
  }
  optional_num_consumers_.num_consumers_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateJobUpdate.num_consumers)
}

// .tensorflow.data.TargetWorkers target_workers = 10;
inline void CreateJobUpdate::clear_target_workers() {
  target_workers_ = 0;
}
inline ::tensorflow::data::TargetWorkers CreateJobUpdate::target_workers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateJobUpdate.target_workers)
  return static_cast< ::tensorflow::data::TargetWorkers >(target_workers_);
}
inline void CreateJobUpdate::set_target_workers(::tensorflow::data::TargetWorkers value) {
  
  target_workers_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateJobUpdate.target_workers)
}

inline bool CreateJobUpdate::has_optional_num_consumers() const {
  return optional_num_consumers_case() != OPTIONAL_NUM_CONSUMERS_NOT_SET;
}
inline void CreateJobUpdate::clear_has_optional_num_consumers() {
  _oneof_case_[0] = OPTIONAL_NUM_CONSUMERS_NOT_SET;
}
inline CreateJobUpdate::OptionalNumConsumersCase CreateJobUpdate::optional_num_consumers_case() const {
  return CreateJobUpdate::OptionalNumConsumersCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// ProduceSplitUpdate

// int64 job_id = 1;
inline void ProduceSplitUpdate::clear_job_id() {
  job_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ProduceSplitUpdate::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ProduceSplitUpdate.job_id)
  return job_id_;
}
inline void ProduceSplitUpdate::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ProduceSplitUpdate.job_id)
}

// int64 iteration = 2;
inline void ProduceSplitUpdate::clear_iteration() {
  iteration_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ProduceSplitUpdate::iteration() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ProduceSplitUpdate.iteration)
  return iteration_;
}
inline void ProduceSplitUpdate::set_iteration(::google::protobuf::int64 value) {
  
  iteration_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ProduceSplitUpdate.iteration)
}

// int64 split_provider_index = 4;
inline void ProduceSplitUpdate::clear_split_provider_index() {
  split_provider_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ProduceSplitUpdate::split_provider_index() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ProduceSplitUpdate.split_provider_index)
  return split_provider_index_;
}
inline void ProduceSplitUpdate::set_split_provider_index(::google::protobuf::int64 value) {
  
  split_provider_index_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ProduceSplitUpdate.split_provider_index)
}

// bool finished = 3;
inline void ProduceSplitUpdate::clear_finished() {
  finished_ = false;
}
inline bool ProduceSplitUpdate::finished() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ProduceSplitUpdate.finished)
  return finished_;
}
inline void ProduceSplitUpdate::set_finished(bool value) {
  
  finished_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ProduceSplitUpdate.finished)
}

// -------------------------------------------------------------------

// AcquireJobClientUpdate

// int64 job_id = 1;
inline void AcquireJobClientUpdate::clear_job_id() {
  job_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AcquireJobClientUpdate::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.AcquireJobClientUpdate.job_id)
  return job_id_;
}
inline void AcquireJobClientUpdate::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.AcquireJobClientUpdate.job_id)
}

// int64 job_client_id = 2;
inline void AcquireJobClientUpdate::clear_job_client_id() {
  job_client_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 AcquireJobClientUpdate::job_client_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.AcquireJobClientUpdate.job_client_id)
  return job_client_id_;
}
inline void AcquireJobClientUpdate::set_job_client_id(::google::protobuf::int64 value) {
  
  job_client_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.AcquireJobClientUpdate.job_client_id)
}

// -------------------------------------------------------------------

// ReleaseJobClientUpdate

// int64 job_client_id = 1;
inline void ReleaseJobClientUpdate::clear_job_client_id() {
  job_client_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReleaseJobClientUpdate::job_client_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ReleaseJobClientUpdate.job_client_id)
  return job_client_id_;
}
inline void ReleaseJobClientUpdate::set_job_client_id(::google::protobuf::int64 value) {
  
  job_client_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ReleaseJobClientUpdate.job_client_id)
}

// int64 time_micros = 2;
inline void ReleaseJobClientUpdate::clear_time_micros() {
  time_micros_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReleaseJobClientUpdate::time_micros() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ReleaseJobClientUpdate.time_micros)
  return time_micros_;
}
inline void ReleaseJobClientUpdate::set_time_micros(::google::protobuf::int64 value) {
  
  time_micros_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ReleaseJobClientUpdate.time_micros)
}

// -------------------------------------------------------------------

// GarbageCollectJobUpdate

// int64 job_id = 1;
inline void GarbageCollectJobUpdate::clear_job_id() {
  job_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GarbageCollectJobUpdate::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.GarbageCollectJobUpdate.job_id)
  return job_id_;
}
inline void GarbageCollectJobUpdate::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.GarbageCollectJobUpdate.job_id)
}

// -------------------------------------------------------------------

// RemoveTaskUpdate

// int64 task_id = 1;
inline void RemoveTaskUpdate::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 RemoveTaskUpdate::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.RemoveTaskUpdate.task_id)
  return task_id_;
}
inline void RemoveTaskUpdate::set_task_id(::google::protobuf::int64 value) {
  
  task_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.RemoveTaskUpdate.task_id)
}

// -------------------------------------------------------------------

// TaskRejected

// int64 new_target_round = 1;
inline void TaskRejected::clear_new_target_round() {
  new_target_round_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskRejected::new_target_round() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskRejected.new_target_round)
  return new_target_round_;
}
inline void TaskRejected::set_new_target_round(::google::protobuf::int64 value) {
  
  new_target_round_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskRejected.new_target_round)
}

// -------------------------------------------------------------------

// ClientHeartbeatUpdate

// int64 job_client_id = 1;
inline void ClientHeartbeatUpdate::clear_job_client_id() {
  job_client_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ClientHeartbeatUpdate::job_client_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ClientHeartbeatUpdate.job_client_id)
  return job_client_id_;
}
inline void ClientHeartbeatUpdate::set_job_client_id(::google::protobuf::int64 value) {
  
  job_client_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ClientHeartbeatUpdate.job_client_id)
}

// bool task_accepted = 2;
inline void ClientHeartbeatUpdate::clear_task_accepted() {
  task_accepted_ = false;
}
inline bool ClientHeartbeatUpdate::task_accepted() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.ClientHeartbeatUpdate.task_accepted)
  return task_accepted_;
}
inline void ClientHeartbeatUpdate::set_task_accepted(bool value) {
  
  task_accepted_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.ClientHeartbeatUpdate.task_accepted)
}

// .tensorflow.data.TaskRejected task_rejected = 3;
inline bool ClientHeartbeatUpdate::has_task_rejected() const {
  return this != internal_default_instance() && task_rejected_ != NULL;
}
inline void ClientHeartbeatUpdate::clear_task_rejected() {
  if (GetArenaNoVirtual() == NULL && task_rejected_ != NULL) {
    delete task_rejected_;
  }
  task_rejected_ = NULL;
}
inline const ::tensorflow::data::TaskRejected& ClientHeartbeatUpdate::_internal_task_rejected() const {
  return *task_rejected_;
}
inline const ::tensorflow::data::TaskRejected& ClientHeartbeatUpdate::task_rejected() const {
  const ::tensorflow::data::TaskRejected* p = task_rejected_;
  // @@protoc_insertion_point(field_get:tensorflow.data.ClientHeartbeatUpdate.task_rejected)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::TaskRejected*>(
      &::tensorflow::data::_TaskRejected_default_instance_);
}
inline ::tensorflow::data::TaskRejected* ClientHeartbeatUpdate::release_task_rejected() {
  // @@protoc_insertion_point(field_release:tensorflow.data.ClientHeartbeatUpdate.task_rejected)
  
  ::tensorflow::data::TaskRejected* temp = task_rejected_;
  task_rejected_ = NULL;
  return temp;
}
inline ::tensorflow::data::TaskRejected* ClientHeartbeatUpdate::mutable_task_rejected() {
  
  if (task_rejected_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::TaskRejected>(GetArenaNoVirtual());
    task_rejected_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.ClientHeartbeatUpdate.task_rejected)
  return task_rejected_;
}
inline void ClientHeartbeatUpdate::set_allocated_task_rejected(::tensorflow::data::TaskRejected* task_rejected) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete task_rejected_;
  }
  if (task_rejected) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      task_rejected = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, task_rejected, submessage_arena);
    }
    
  } else {
    
  }
  task_rejected_ = task_rejected;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.ClientHeartbeatUpdate.task_rejected)
}

// -------------------------------------------------------------------

// CreatePendingTaskUpdate

// int64 task_id = 1;
inline void CreatePendingTaskUpdate::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreatePendingTaskUpdate::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreatePendingTaskUpdate.task_id)
  return task_id_;
}
inline void CreatePendingTaskUpdate::set_task_id(::google::protobuf::int64 value) {
  
  task_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreatePendingTaskUpdate.task_id)
}

// int64 job_id = 2;
inline void CreatePendingTaskUpdate::clear_job_id() {
  job_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreatePendingTaskUpdate::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreatePendingTaskUpdate.job_id)
  return job_id_;
}
inline void CreatePendingTaskUpdate::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreatePendingTaskUpdate.job_id)
}

// string worker_address = 3;
inline void CreatePendingTaskUpdate::clear_worker_address() {
  worker_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreatePendingTaskUpdate::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreatePendingTaskUpdate.worker_address)
  return worker_address_.GetNoArena();
}
inline void CreatePendingTaskUpdate::set_worker_address(const ::std::string& value) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.CreatePendingTaskUpdate.worker_address)
}
#if LANG_CXX11
inline void CreatePendingTaskUpdate::set_worker_address(::std::string&& value) {
  
  worker_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.CreatePendingTaskUpdate.worker_address)
}
#endif
inline void CreatePendingTaskUpdate::set_worker_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.CreatePendingTaskUpdate.worker_address)
}
inline void CreatePendingTaskUpdate::set_worker_address(const char* value, size_t size) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.CreatePendingTaskUpdate.worker_address)
}
inline ::std::string* CreatePendingTaskUpdate::mutable_worker_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.CreatePendingTaskUpdate.worker_address)
  return worker_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreatePendingTaskUpdate::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.CreatePendingTaskUpdate.worker_address)
  
  return worker_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreatePendingTaskUpdate::set_allocated_worker_address(::std::string* worker_address) {
  if (worker_address != NULL) {
    
  } else {
    
  }
  worker_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worker_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.CreatePendingTaskUpdate.worker_address)
}

// string transfer_address = 4;
inline void CreatePendingTaskUpdate::clear_transfer_address() {
  transfer_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreatePendingTaskUpdate::transfer_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreatePendingTaskUpdate.transfer_address)
  return transfer_address_.GetNoArena();
}
inline void CreatePendingTaskUpdate::set_transfer_address(const ::std::string& value) {
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.CreatePendingTaskUpdate.transfer_address)
}
#if LANG_CXX11
inline void CreatePendingTaskUpdate::set_transfer_address(::std::string&& value) {
  
  transfer_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.CreatePendingTaskUpdate.transfer_address)
}
#endif
inline void CreatePendingTaskUpdate::set_transfer_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.CreatePendingTaskUpdate.transfer_address)
}
inline void CreatePendingTaskUpdate::set_transfer_address(const char* value, size_t size) {
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.CreatePendingTaskUpdate.transfer_address)
}
inline ::std::string* CreatePendingTaskUpdate::mutable_transfer_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.CreatePendingTaskUpdate.transfer_address)
  return transfer_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreatePendingTaskUpdate::release_transfer_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.CreatePendingTaskUpdate.transfer_address)
  
  return transfer_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreatePendingTaskUpdate::set_allocated_transfer_address(::std::string* transfer_address) {
  if (transfer_address != NULL) {
    
  } else {
    
  }
  transfer_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transfer_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.CreatePendingTaskUpdate.transfer_address)
}

// repeated string worker_tags = 6;
inline int CreatePendingTaskUpdate::worker_tags_size() const {
  return worker_tags_.size();
}
inline void CreatePendingTaskUpdate::clear_worker_tags() {
  worker_tags_.Clear();
}
inline const ::std::string& CreatePendingTaskUpdate::worker_tags(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
  return worker_tags_.Get(index);
}
inline ::std::string* CreatePendingTaskUpdate::mutable_worker_tags(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
  return worker_tags_.Mutable(index);
}
inline void CreatePendingTaskUpdate::set_worker_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
  worker_tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CreatePendingTaskUpdate::set_worker_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
  worker_tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CreatePendingTaskUpdate::set_worker_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  worker_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
}
inline void CreatePendingTaskUpdate::set_worker_tags(int index, const char* value, size_t size) {
  worker_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
}
inline ::std::string* CreatePendingTaskUpdate::add_worker_tags() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
  return worker_tags_.Add();
}
inline void CreatePendingTaskUpdate::add_worker_tags(const ::std::string& value) {
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
}
#if LANG_CXX11
inline void CreatePendingTaskUpdate::add_worker_tags(::std::string&& value) {
  worker_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
}
#endif
inline void CreatePendingTaskUpdate::add_worker_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
}
inline void CreatePendingTaskUpdate::add_worker_tags(const char* value, size_t size) {
  worker_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CreatePendingTaskUpdate::worker_tags() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
  return worker_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CreatePendingTaskUpdate::mutable_worker_tags() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.CreatePendingTaskUpdate.worker_tags)
  return &worker_tags_;
}

// int64 worker_uid = 7;
inline void CreatePendingTaskUpdate::clear_worker_uid() {
  worker_uid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreatePendingTaskUpdate::worker_uid() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreatePendingTaskUpdate.worker_uid)
  return worker_uid_;
}
inline void CreatePendingTaskUpdate::set_worker_uid(::google::protobuf::int64 value) {
  
  worker_uid_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreatePendingTaskUpdate.worker_uid)
}

// int64 starting_round = 5;
inline void CreatePendingTaskUpdate::clear_starting_round() {
  starting_round_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreatePendingTaskUpdate::starting_round() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreatePendingTaskUpdate.starting_round)
  return starting_round_;
}
inline void CreatePendingTaskUpdate::set_starting_round(::google::protobuf::int64 value) {
  
  starting_round_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreatePendingTaskUpdate.starting_round)
}

// -------------------------------------------------------------------

// CreateTaskUpdate

// int64 task_id = 1;
inline void CreateTaskUpdate::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreateTaskUpdate::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateTaskUpdate.task_id)
  return task_id_;
}
inline void CreateTaskUpdate::set_task_id(::google::protobuf::int64 value) {
  
  task_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateTaskUpdate.task_id)
}

// int64 job_id = 2;
inline void CreateTaskUpdate::clear_job_id() {
  job_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreateTaskUpdate::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateTaskUpdate.job_id)
  return job_id_;
}
inline void CreateTaskUpdate::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateTaskUpdate.job_id)
}

// string worker_address = 4;
inline void CreateTaskUpdate::clear_worker_address() {
  worker_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateTaskUpdate::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateTaskUpdate.worker_address)
  return worker_address_.GetNoArena();
}
inline void CreateTaskUpdate::set_worker_address(const ::std::string& value) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateTaskUpdate.worker_address)
}
#if LANG_CXX11
inline void CreateTaskUpdate::set_worker_address(::std::string&& value) {
  
  worker_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.CreateTaskUpdate.worker_address)
}
#endif
inline void CreateTaskUpdate::set_worker_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.CreateTaskUpdate.worker_address)
}
inline void CreateTaskUpdate::set_worker_address(const char* value, size_t size) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.CreateTaskUpdate.worker_address)
}
inline ::std::string* CreateTaskUpdate::mutable_worker_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.CreateTaskUpdate.worker_address)
  return worker_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateTaskUpdate::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.CreateTaskUpdate.worker_address)
  
  return worker_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTaskUpdate::set_allocated_worker_address(::std::string* worker_address) {
  if (worker_address != NULL) {
    
  } else {
    
  }
  worker_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worker_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.CreateTaskUpdate.worker_address)
}

// string transfer_address = 6;
inline void CreateTaskUpdate::clear_transfer_address() {
  transfer_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CreateTaskUpdate::transfer_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateTaskUpdate.transfer_address)
  return transfer_address_.GetNoArena();
}
inline void CreateTaskUpdate::set_transfer_address(const ::std::string& value) {
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateTaskUpdate.transfer_address)
}
#if LANG_CXX11
inline void CreateTaskUpdate::set_transfer_address(::std::string&& value) {
  
  transfer_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.CreateTaskUpdate.transfer_address)
}
#endif
inline void CreateTaskUpdate::set_transfer_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.CreateTaskUpdate.transfer_address)
}
inline void CreateTaskUpdate::set_transfer_address(const char* value, size_t size) {
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.CreateTaskUpdate.transfer_address)
}
inline ::std::string* CreateTaskUpdate::mutable_transfer_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.CreateTaskUpdate.transfer_address)
  return transfer_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CreateTaskUpdate::release_transfer_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.CreateTaskUpdate.transfer_address)
  
  return transfer_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CreateTaskUpdate::set_allocated_transfer_address(::std::string* transfer_address) {
  if (transfer_address != NULL) {
    
  } else {
    
  }
  transfer_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transfer_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.CreateTaskUpdate.transfer_address)
}

// repeated string worker_tags = 7;
inline int CreateTaskUpdate::worker_tags_size() const {
  return worker_tags_.size();
}
inline void CreateTaskUpdate::clear_worker_tags() {
  worker_tags_.Clear();
}
inline const ::std::string& CreateTaskUpdate::worker_tags(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateTaskUpdate.worker_tags)
  return worker_tags_.Get(index);
}
inline ::std::string* CreateTaskUpdate::mutable_worker_tags(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.CreateTaskUpdate.worker_tags)
  return worker_tags_.Mutable(index);
}
inline void CreateTaskUpdate::set_worker_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateTaskUpdate.worker_tags)
  worker_tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void CreateTaskUpdate::set_worker_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateTaskUpdate.worker_tags)
  worker_tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void CreateTaskUpdate::set_worker_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  worker_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.data.CreateTaskUpdate.worker_tags)
}
inline void CreateTaskUpdate::set_worker_tags(int index, const char* value, size_t size) {
  worker_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.CreateTaskUpdate.worker_tags)
}
inline ::std::string* CreateTaskUpdate::add_worker_tags() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.data.CreateTaskUpdate.worker_tags)
  return worker_tags_.Add();
}
inline void CreateTaskUpdate::add_worker_tags(const ::std::string& value) {
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.data.CreateTaskUpdate.worker_tags)
}
#if LANG_CXX11
inline void CreateTaskUpdate::add_worker_tags(::std::string&& value) {
  worker_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.data.CreateTaskUpdate.worker_tags)
}
#endif
inline void CreateTaskUpdate::add_worker_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.data.CreateTaskUpdate.worker_tags)
}
inline void CreateTaskUpdate::add_worker_tags(const char* value, size_t size) {
  worker_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.data.CreateTaskUpdate.worker_tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CreateTaskUpdate::worker_tags() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.CreateTaskUpdate.worker_tags)
  return worker_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CreateTaskUpdate::mutable_worker_tags() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.CreateTaskUpdate.worker_tags)
  return &worker_tags_;
}

// int64 worker_uid = 8;
inline void CreateTaskUpdate::clear_worker_uid() {
  worker_uid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CreateTaskUpdate::worker_uid() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.CreateTaskUpdate.worker_uid)
  return worker_uid_;
}
inline void CreateTaskUpdate::set_worker_uid(::google::protobuf::int64 value) {
  
  worker_uid_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.CreateTaskUpdate.worker_uid)
}

// -------------------------------------------------------------------

// FinishTaskUpdate

// int64 task_id = 1;
inline void FinishTaskUpdate::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 FinishTaskUpdate::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.FinishTaskUpdate.task_id)
  return task_id_;
}
inline void FinishTaskUpdate::set_task_id(::google::protobuf::int64 value) {
  
  task_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.FinishTaskUpdate.task_id)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace data
}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fjournal_2eproto
