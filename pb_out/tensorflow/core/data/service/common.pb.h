// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/data/service/common.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/core/framework/graph.pb.h"
#include "tensorflow/core/protobuf/data_service.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto 

namespace protobuf_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto
namespace tensorflow {
namespace data {
class DatasetDef;
class DatasetDefDefaultTypeInternal;
extern DatasetDefDefaultTypeInternal _DatasetDef_default_instance_;
class JobKeyDef;
class JobKeyDefDefaultTypeInternal;
extern JobKeyDefDefaultTypeInternal _JobKeyDef_default_instance_;
class TaskDef;
class TaskDefDefaultTypeInternal;
extern TaskDefDefaultTypeInternal _TaskDef_default_instance_;
class TaskInfo;
class TaskInfoDefaultTypeInternal;
extern TaskInfoDefaultTypeInternal _TaskInfo_default_instance_;
}  // namespace data
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::data::DatasetDef* Arena::CreateMaybeMessage<::tensorflow::data::DatasetDef>(Arena*);
template<> ::tensorflow::data::JobKeyDef* Arena::CreateMaybeMessage<::tensorflow::data::JobKeyDef>(Arena*);
template<> ::tensorflow::data::TaskDef* Arena::CreateMaybeMessage<::tensorflow::data::TaskDef>(Arena*);
template<> ::tensorflow::data::TaskInfo* Arena::CreateMaybeMessage<::tensorflow::data::TaskInfo>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {
namespace data {

enum TargetWorkers {
  TARGET_WORKERS_UNSPECIFIED = 0,
  TARGET_WORKERS_AUTO = 1,
  TARGET_WORKERS_ANY = 2,
  TARGET_WORKERS_LOCAL = 3,
  TargetWorkers_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  TargetWorkers_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool TargetWorkers_IsValid(int value);
const TargetWorkers TargetWorkers_MIN = TARGET_WORKERS_UNSPECIFIED;
const TargetWorkers TargetWorkers_MAX = TARGET_WORKERS_LOCAL;
const int TargetWorkers_ARRAYSIZE = TargetWorkers_MAX + 1;

const ::google::protobuf::EnumDescriptor* TargetWorkers_descriptor();
inline const ::std::string& TargetWorkers_Name(TargetWorkers value) {
  return ::google::protobuf::internal::NameOfEnum(
    TargetWorkers_descriptor(), value);
}
inline bool TargetWorkers_Parse(
    const ::std::string& name, TargetWorkers* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TargetWorkers>(
    TargetWorkers_descriptor(), name, value);
}
// ===================================================================

class DatasetDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.DatasetDef) */ {
 public:
  DatasetDef();
  virtual ~DatasetDef();

  DatasetDef(const DatasetDef& from);

  inline DatasetDef& operator=(const DatasetDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DatasetDef(DatasetDef&& from) noexcept
    : DatasetDef() {
    *this = ::std::move(from);
  }

  inline DatasetDef& operator=(DatasetDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DatasetDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DatasetDef* internal_default_instance() {
    return reinterpret_cast<const DatasetDef*>(
               &_DatasetDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(DatasetDef* other);
  friend void swap(DatasetDef& a, DatasetDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DatasetDef* New() const final {
    return CreateMaybeMessage<DatasetDef>(NULL);
  }

  DatasetDef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DatasetDef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DatasetDef& from);
  void MergeFrom(const DatasetDef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DatasetDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.GraphDef graph = 1;
  bool has_graph() const;
  void clear_graph();
  static const int kGraphFieldNumber = 1;
  private:
  const ::tensorflow::GraphDef& _internal_graph() const;
  public:
  const ::tensorflow::GraphDef& graph() const;
  ::tensorflow::GraphDef* release_graph();
  ::tensorflow::GraphDef* mutable_graph();
  void set_allocated_graph(::tensorflow::GraphDef* graph);

  // @@protoc_insertion_point(class_scope:tensorflow.data.DatasetDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::GraphDef* graph_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class JobKeyDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.JobKeyDef) */ {
 public:
  JobKeyDef();
  virtual ~JobKeyDef();

  JobKeyDef(const JobKeyDef& from);

  inline JobKeyDef& operator=(const JobKeyDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JobKeyDef(JobKeyDef&& from) noexcept
    : JobKeyDef() {
    *this = ::std::move(from);
  }

  inline JobKeyDef& operator=(JobKeyDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const JobKeyDef& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JobKeyDef* internal_default_instance() {
    return reinterpret_cast<const JobKeyDef*>(
               &_JobKeyDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(JobKeyDef* other);
  friend void swap(JobKeyDef& a, JobKeyDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JobKeyDef* New() const final {
    return CreateMaybeMessage<JobKeyDef>(NULL);
  }

  JobKeyDef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JobKeyDef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JobKeyDef& from);
  void MergeFrom(const JobKeyDef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JobKeyDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 iteration = 2;
  void clear_iteration();
  static const int kIterationFieldNumber = 2;
  ::google::protobuf::int64 iteration() const;
  void set_iteration(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.JobKeyDef)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 iteration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskDef : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.TaskDef) */ {
 public:
  TaskDef();
  virtual ~TaskDef();

  TaskDef(const TaskDef& from);

  inline TaskDef& operator=(const TaskDef& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskDef(TaskDef&& from) noexcept
    : TaskDef() {
    *this = ::std::move(from);
  }

  inline TaskDef& operator=(TaskDef&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskDef& default_instance();

  enum DatasetCase {
    kDatasetDef = 1,
    kPath = 2,
    DATASET_NOT_SET = 0,
  };

  enum OptionalNumConsumersCase {
    kNumConsumers = 7,
    OPTIONAL_NUM_CONSUMERS_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskDef* internal_default_instance() {
    return reinterpret_cast<const TaskDef*>(
               &_TaskDef_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TaskDef* other);
  friend void swap(TaskDef& a, TaskDef& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskDef* New() const final {
    return CreateMaybeMessage<TaskDef>(NULL);
  }

  TaskDef* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskDef>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskDef& from);
  void MergeFrom(const TaskDef& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskDef* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string worker_address = 8;
  void clear_worker_address();
  static const int kWorkerAddressFieldNumber = 8;
  const ::std::string& worker_address() const;
  void set_worker_address(const ::std::string& value);
  #if LANG_CXX11
  void set_worker_address(::std::string&& value);
  #endif
  void set_worker_address(const char* value);
  void set_worker_address(const char* value, size_t size);
  ::std::string* mutable_worker_address();
  ::std::string* release_worker_address();
  void set_allocated_worker_address(::std::string* worker_address);

  // .tensorflow.data.ProcessingModeDef processing_mode_def = 10;
  bool has_processing_mode_def() const;
  void clear_processing_mode_def();
  static const int kProcessingModeDefFieldNumber = 10;
  private:
  const ::tensorflow::data::ProcessingModeDef& _internal_processing_mode_def() const;
  public:
  const ::tensorflow::data::ProcessingModeDef& processing_mode_def() const;
  ::tensorflow::data::ProcessingModeDef* release_processing_mode_def();
  ::tensorflow::data::ProcessingModeDef* mutable_processing_mode_def();
  void set_allocated_processing_mode_def(::tensorflow::data::ProcessingModeDef* processing_mode_def);

  // int64 dataset_id = 3;
  void clear_dataset_id();
  static const int kDatasetIdFieldNumber = 3;
  ::google::protobuf::int64 dataset_id() const;
  void set_dataset_id(::google::protobuf::int64 value);

  // int64 task_id = 4;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 4;
  ::google::protobuf::int64 task_id() const;
  void set_task_id(::google::protobuf::int64 value);

  // int64 job_id = 5;
  void clear_job_id();
  static const int kJobIdFieldNumber = 5;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // int64 num_split_providers = 9;
  void clear_num_split_providers();
  static const int kNumSplitProvidersFieldNumber = 9;
  ::google::protobuf::int64 num_split_providers() const;
  void set_num_split_providers(::google::protobuf::int64 value);

  // int64 num_workers = 11;
  void clear_num_workers();
  static const int kNumWorkersFieldNumber = 11;
  ::google::protobuf::int64 num_workers() const;
  void set_num_workers(::google::protobuf::int64 value);

  // int64 worker_index = 12;
  void clear_worker_index();
  static const int kWorkerIndexFieldNumber = 12;
  ::google::protobuf::int64 worker_index() const;
  void set_worker_index(::google::protobuf::int64 value);

  // .tensorflow.data.DatasetDef dataset_def = 1;
  bool has_dataset_def() const;
  void clear_dataset_def();
  static const int kDatasetDefFieldNumber = 1;
  private:
  const ::tensorflow::data::DatasetDef& _internal_dataset_def() const;
  public:
  const ::tensorflow::data::DatasetDef& dataset_def() const;
  ::tensorflow::data::DatasetDef* release_dataset_def();
  ::tensorflow::data::DatasetDef* mutable_dataset_def();
  void set_allocated_dataset_def(::tensorflow::data::DatasetDef* dataset_def);

  // string path = 2;
  private:
  bool has_path() const;
  public:
  void clear_path();
  static const int kPathFieldNumber = 2;
  const ::std::string& path() const;
  void set_path(const ::std::string& value);
  #if LANG_CXX11
  void set_path(::std::string&& value);
  #endif
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  ::std::string* mutable_path();
  ::std::string* release_path();
  void set_allocated_path(::std::string* path);

  // int64 num_consumers = 7;
  private:
  bool has_num_consumers() const;
  public:
  void clear_num_consumers();
  static const int kNumConsumersFieldNumber = 7;
  ::google::protobuf::int64 num_consumers() const;
  void set_num_consumers(::google::protobuf::int64 value);

  void clear_dataset();
  DatasetCase dataset_case() const;
  void clear_optional_num_consumers();
  OptionalNumConsumersCase optional_num_consumers_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.data.TaskDef)
 private:
  void set_has_dataset_def();
  void set_has_path();
  void set_has_num_consumers();

  inline bool has_dataset() const;
  inline void clear_has_dataset();

  inline bool has_optional_num_consumers() const;
  inline void clear_has_optional_num_consumers();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr worker_address_;
  ::tensorflow::data::ProcessingModeDef* processing_mode_def_;
  ::google::protobuf::int64 dataset_id_;
  ::google::protobuf::int64 task_id_;
  ::google::protobuf::int64 job_id_;
  ::google::protobuf::int64 num_split_providers_;
  ::google::protobuf::int64 num_workers_;
  ::google::protobuf::int64 worker_index_;
  union DatasetUnion {
    DatasetUnion() {}
    ::tensorflow::data::DatasetDef* dataset_def_;
    ::google::protobuf::internal::ArenaStringPtr path_;
  } dataset_;
  union OptionalNumConsumersUnion {
    OptionalNumConsumersUnion() {}
    ::google::protobuf::int64 num_consumers_;
  } optional_num_consumers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[2];

  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TaskInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.data.TaskInfo) */ {
 public:
  TaskInfo();
  virtual ~TaskInfo();

  TaskInfo(const TaskInfo& from);

  inline TaskInfo& operator=(const TaskInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TaskInfo(TaskInfo&& from) noexcept
    : TaskInfo() {
    *this = ::std::move(from);
  }

  inline TaskInfo& operator=(TaskInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TaskInfo* internal_default_instance() {
    return reinterpret_cast<const TaskInfo*>(
               &_TaskInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(TaskInfo* other);
  friend void swap(TaskInfo& a, TaskInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TaskInfo* New() const final {
    return CreateMaybeMessage<TaskInfo>(NULL);
  }

  TaskInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TaskInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TaskInfo& from);
  void MergeFrom(const TaskInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TaskInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string worker_tags = 6;
  int worker_tags_size() const;
  void clear_worker_tags();
  static const int kWorkerTagsFieldNumber = 6;
  const ::std::string& worker_tags(int index) const;
  ::std::string* mutable_worker_tags(int index);
  void set_worker_tags(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_worker_tags(int index, ::std::string&& value);
  #endif
  void set_worker_tags(int index, const char* value);
  void set_worker_tags(int index, const char* value, size_t size);
  ::std::string* add_worker_tags();
  void add_worker_tags(const ::std::string& value);
  #if LANG_CXX11
  void add_worker_tags(::std::string&& value);
  #endif
  void add_worker_tags(const char* value);
  void add_worker_tags(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& worker_tags() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_worker_tags();

  // string worker_address = 1;
  void clear_worker_address();
  static const int kWorkerAddressFieldNumber = 1;
  const ::std::string& worker_address() const;
  void set_worker_address(const ::std::string& value);
  #if LANG_CXX11
  void set_worker_address(::std::string&& value);
  #endif
  void set_worker_address(const char* value);
  void set_worker_address(const char* value, size_t size);
  ::std::string* mutable_worker_address();
  ::std::string* release_worker_address();
  void set_allocated_worker_address(::std::string* worker_address);

  // string transfer_address = 4;
  void clear_transfer_address();
  static const int kTransferAddressFieldNumber = 4;
  const ::std::string& transfer_address() const;
  void set_transfer_address(const ::std::string& value);
  #if LANG_CXX11
  void set_transfer_address(::std::string&& value);
  #endif
  void set_transfer_address(const char* value);
  void set_transfer_address(const char* value, size_t size);
  ::std::string* mutable_transfer_address();
  ::std::string* release_transfer_address();
  void set_allocated_transfer_address(::std::string* transfer_address);

  // int64 task_id = 2;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  ::google::protobuf::int64 task_id() const;
  void set_task_id(::google::protobuf::int64 value);

  // int64 job_id = 3;
  void clear_job_id();
  static const int kJobIdFieldNumber = 3;
  ::google::protobuf::int64 job_id() const;
  void set_job_id(::google::protobuf::int64 value);

  // int64 starting_round = 5;
  void clear_starting_round();
  static const int kStartingRoundFieldNumber = 5;
  ::google::protobuf::int64 starting_round() const;
  void set_starting_round(::google::protobuf::int64 value);

  // int64 worker_uid = 7;
  void clear_worker_uid();
  static const int kWorkerUidFieldNumber = 7;
  ::google::protobuf::int64 worker_uid() const;
  void set_worker_uid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.data.TaskInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> worker_tags_;
  ::google::protobuf::internal::ArenaStringPtr worker_address_;
  ::google::protobuf::internal::ArenaStringPtr transfer_address_;
  ::google::protobuf::int64 task_id_;
  ::google::protobuf::int64 job_id_;
  ::google::protobuf::int64 starting_round_;
  ::google::protobuf::int64 worker_uid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DatasetDef

// .tensorflow.GraphDef graph = 1;
inline bool DatasetDef::has_graph() const {
  return this != internal_default_instance() && graph_ != NULL;
}
inline const ::tensorflow::GraphDef& DatasetDef::_internal_graph() const {
  return *graph_;
}
inline const ::tensorflow::GraphDef& DatasetDef::graph() const {
  const ::tensorflow::GraphDef* p = graph_;
  // @@protoc_insertion_point(field_get:tensorflow.data.DatasetDef.graph)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::GraphDef*>(
      &::tensorflow::_GraphDef_default_instance_);
}
inline ::tensorflow::GraphDef* DatasetDef::release_graph() {
  // @@protoc_insertion_point(field_release:tensorflow.data.DatasetDef.graph)
  
  ::tensorflow::GraphDef* temp = graph_;
  graph_ = NULL;
  return temp;
}
inline ::tensorflow::GraphDef* DatasetDef::mutable_graph() {
  
  if (graph_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::GraphDef>(GetArenaNoVirtual());
    graph_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.DatasetDef.graph)
  return graph_;
}
inline void DatasetDef::set_allocated_graph(::tensorflow::GraphDef* graph) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(graph_);
  }
  if (graph) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(graph)->GetArena();
    if (message_arena != submessage_arena) {
      graph = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, graph, submessage_arena);
    }
    
  } else {
    
  }
  graph_ = graph;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.DatasetDef.graph)
}

// -------------------------------------------------------------------

// JobKeyDef

// string name = 1;
inline void JobKeyDef::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& JobKeyDef::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.JobKeyDef.name)
  return name_.GetNoArena();
}
inline void JobKeyDef::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.JobKeyDef.name)
}
#if LANG_CXX11
inline void JobKeyDef::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.JobKeyDef.name)
}
#endif
inline void JobKeyDef::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.JobKeyDef.name)
}
inline void JobKeyDef::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.JobKeyDef.name)
}
inline ::std::string* JobKeyDef::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.JobKeyDef.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* JobKeyDef::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.data.JobKeyDef.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void JobKeyDef::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.JobKeyDef.name)
}

// int64 iteration = 2;
inline void JobKeyDef::clear_iteration() {
  iteration_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 JobKeyDef::iteration() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.JobKeyDef.iteration)
  return iteration_;
}
inline void JobKeyDef::set_iteration(::google::protobuf::int64 value) {
  
  iteration_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.JobKeyDef.iteration)
}

// -------------------------------------------------------------------

// TaskDef

// .tensorflow.data.DatasetDef dataset_def = 1;
inline bool TaskDef::has_dataset_def() const {
  return dataset_case() == kDatasetDef;
}
inline void TaskDef::set_has_dataset_def() {
  _oneof_case_[0] = kDatasetDef;
}
inline void TaskDef::clear_dataset_def() {
  if (has_dataset_def()) {
    delete dataset_.dataset_def_;
    clear_has_dataset();
  }
}
inline const ::tensorflow::data::DatasetDef& TaskDef::_internal_dataset_def() const {
  return *dataset_.dataset_def_;
}
inline ::tensorflow::data::DatasetDef* TaskDef::release_dataset_def() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.dataset_def)
  if (has_dataset_def()) {
    clear_has_dataset();
      ::tensorflow::data::DatasetDef* temp = dataset_.dataset_def_;
    dataset_.dataset_def_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::data::DatasetDef& TaskDef::dataset_def() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.dataset_def)
  return has_dataset_def()
      ? *dataset_.dataset_def_
      : *reinterpret_cast< ::tensorflow::data::DatasetDef*>(&::tensorflow::data::_DatasetDef_default_instance_);
}
inline ::tensorflow::data::DatasetDef* TaskDef::mutable_dataset_def() {
  if (!has_dataset_def()) {
    clear_dataset();
    set_has_dataset_def();
    dataset_.dataset_def_ = CreateMaybeMessage< ::tensorflow::data::DatasetDef >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.dataset_def)
  return dataset_.dataset_def_;
}

// string path = 2;
inline bool TaskDef::has_path() const {
  return dataset_case() == kPath;
}
inline void TaskDef::set_has_path() {
  _oneof_case_[0] = kPath;
}
inline void TaskDef::clear_path() {
  if (has_path()) {
    dataset_.path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_dataset();
  }
}
inline const ::std::string& TaskDef::path() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.path)
  if (has_path()) {
    return dataset_.path_.GetNoArena();
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void TaskDef::set_path(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.path)
  if (!has_path()) {
    clear_dataset();
    set_has_path();
    dataset_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  dataset_.path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.path)
}
#if LANG_CXX11
inline void TaskDef::set_path(::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.path)
  if (!has_path()) {
    clear_dataset();
    set_has_path();
    dataset_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  dataset_.path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.TaskDef.path)
}
#endif
inline void TaskDef::set_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  if (!has_path()) {
    clear_dataset();
    set_has_path();
    dataset_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  dataset_.path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.TaskDef.path)
}
inline void TaskDef::set_path(const char* value, size_t size) {
  if (!has_path()) {
    clear_dataset();
    set_has_path();
    dataset_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  dataset_.path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.TaskDef.path)
}
inline ::std::string* TaskDef::mutable_path() {
  if (!has_path()) {
    clear_dataset();
    set_has_path();
    dataset_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.path)
  return dataset_.path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskDef::release_path() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.path)
  if (has_path()) {
    clear_has_dataset();
    return dataset_.path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void TaskDef::set_allocated_path(::std::string* path) {
  if (!has_path()) {
    dataset_.path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_dataset();
  if (path != NULL) {
    set_has_path();
    dataset_.path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  }
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskDef.path)
}

// int64 dataset_id = 3;
inline void TaskDef::clear_dataset_id() {
  dataset_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskDef::dataset_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.dataset_id)
  return dataset_id_;
}
inline void TaskDef::set_dataset_id(::google::protobuf::int64 value) {
  
  dataset_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.dataset_id)
}

// int64 task_id = 4;
inline void TaskDef::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskDef::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.task_id)
  return task_id_;
}
inline void TaskDef::set_task_id(::google::protobuf::int64 value) {
  
  task_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.task_id)
}

// int64 job_id = 5;
inline void TaskDef::clear_job_id() {
  job_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskDef::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.job_id)
  return job_id_;
}
inline void TaskDef::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.job_id)
}

// int64 num_split_providers = 9;
inline void TaskDef::clear_num_split_providers() {
  num_split_providers_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskDef::num_split_providers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.num_split_providers)
  return num_split_providers_;
}
inline void TaskDef::set_num_split_providers(::google::protobuf::int64 value) {
  
  num_split_providers_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.num_split_providers)
}

// string worker_address = 8;
inline void TaskDef::clear_worker_address() {
  worker_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskDef::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.worker_address)
  return worker_address_.GetNoArena();
}
inline void TaskDef::set_worker_address(const ::std::string& value) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.worker_address)
}
#if LANG_CXX11
inline void TaskDef::set_worker_address(::std::string&& value) {
  
  worker_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.TaskDef.worker_address)
}
#endif
inline void TaskDef::set_worker_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.TaskDef.worker_address)
}
inline void TaskDef::set_worker_address(const char* value, size_t size) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.TaskDef.worker_address)
}
inline ::std::string* TaskDef::mutable_worker_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.worker_address)
  return worker_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskDef::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.worker_address)
  
  return worker_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskDef::set_allocated_worker_address(::std::string* worker_address) {
  if (worker_address != NULL) {
    
  } else {
    
  }
  worker_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worker_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskDef.worker_address)
}

// .tensorflow.data.ProcessingModeDef processing_mode_def = 10;
inline bool TaskDef::has_processing_mode_def() const {
  return this != internal_default_instance() && processing_mode_def_ != NULL;
}
inline const ::tensorflow::data::ProcessingModeDef& TaskDef::_internal_processing_mode_def() const {
  return *processing_mode_def_;
}
inline const ::tensorflow::data::ProcessingModeDef& TaskDef::processing_mode_def() const {
  const ::tensorflow::data::ProcessingModeDef* p = processing_mode_def_;
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.processing_mode_def)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::data::ProcessingModeDef*>(
      &::tensorflow::data::_ProcessingModeDef_default_instance_);
}
inline ::tensorflow::data::ProcessingModeDef* TaskDef::release_processing_mode_def() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskDef.processing_mode_def)
  
  ::tensorflow::data::ProcessingModeDef* temp = processing_mode_def_;
  processing_mode_def_ = NULL;
  return temp;
}
inline ::tensorflow::data::ProcessingModeDef* TaskDef::mutable_processing_mode_def() {
  
  if (processing_mode_def_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::data::ProcessingModeDef>(GetArenaNoVirtual());
    processing_mode_def_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskDef.processing_mode_def)
  return processing_mode_def_;
}
inline void TaskDef::set_allocated_processing_mode_def(::tensorflow::data::ProcessingModeDef* processing_mode_def) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(processing_mode_def_);
  }
  if (processing_mode_def) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      processing_mode_def = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, processing_mode_def, submessage_arena);
    }
    
  } else {
    
  }
  processing_mode_def_ = processing_mode_def;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskDef.processing_mode_def)
}

// int64 num_consumers = 7;
inline bool TaskDef::has_num_consumers() const {
  return optional_num_consumers_case() == kNumConsumers;
}
inline void TaskDef::set_has_num_consumers() {
  _oneof_case_[1] = kNumConsumers;
}
inline void TaskDef::clear_num_consumers() {
  if (has_num_consumers()) {
    optional_num_consumers_.num_consumers_ = GOOGLE_LONGLONG(0);
    clear_has_optional_num_consumers();
  }
}
inline ::google::protobuf::int64 TaskDef::num_consumers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.num_consumers)
  if (has_num_consumers()) {
    return optional_num_consumers_.num_consumers_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void TaskDef::set_num_consumers(::google::protobuf::int64 value) {
  if (!has_num_consumers()) {
    clear_optional_num_consumers();
    set_has_num_consumers();
  }
  optional_num_consumers_.num_consumers_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.num_consumers)
}

// int64 num_workers = 11;
inline void TaskDef::clear_num_workers() {
  num_workers_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskDef::num_workers() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.num_workers)
  return num_workers_;
}
inline void TaskDef::set_num_workers(::google::protobuf::int64 value) {
  
  num_workers_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.num_workers)
}

// int64 worker_index = 12;
inline void TaskDef::clear_worker_index() {
  worker_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskDef::worker_index() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskDef.worker_index)
  return worker_index_;
}
inline void TaskDef::set_worker_index(::google::protobuf::int64 value) {
  
  worker_index_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskDef.worker_index)
}

inline bool TaskDef::has_dataset() const {
  return dataset_case() != DATASET_NOT_SET;
}
inline void TaskDef::clear_has_dataset() {
  _oneof_case_[0] = DATASET_NOT_SET;
}
inline bool TaskDef::has_optional_num_consumers() const {
  return optional_num_consumers_case() != OPTIONAL_NUM_CONSUMERS_NOT_SET;
}
inline void TaskDef::clear_has_optional_num_consumers() {
  _oneof_case_[1] = OPTIONAL_NUM_CONSUMERS_NOT_SET;
}
inline TaskDef::DatasetCase TaskDef::dataset_case() const {
  return TaskDef::DatasetCase(_oneof_case_[0]);
}
inline TaskDef::OptionalNumConsumersCase TaskDef::optional_num_consumers_case() const {
  return TaskDef::OptionalNumConsumersCase(_oneof_case_[1]);
}
// -------------------------------------------------------------------

// TaskInfo

// string worker_address = 1;
inline void TaskInfo::clear_worker_address() {
  worker_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskInfo::worker_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.worker_address)
  return worker_address_.GetNoArena();
}
inline void TaskInfo::set_worker_address(const ::std::string& value) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_address)
}
#if LANG_CXX11
inline void TaskInfo::set_worker_address(::std::string&& value) {
  
  worker_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.TaskInfo.worker_address)
}
#endif
inline void TaskInfo::set_worker_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.TaskInfo.worker_address)
}
inline void TaskInfo::set_worker_address(const char* value, size_t size) {
  
  worker_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.TaskInfo.worker_address)
}
inline ::std::string* TaskInfo::mutable_worker_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskInfo.worker_address)
  return worker_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskInfo::release_worker_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskInfo.worker_address)
  
  return worker_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskInfo::set_allocated_worker_address(::std::string* worker_address) {
  if (worker_address != NULL) {
    
  } else {
    
  }
  worker_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), worker_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskInfo.worker_address)
}

// string transfer_address = 4;
inline void TaskInfo::clear_transfer_address() {
  transfer_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TaskInfo::transfer_address() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.transfer_address)
  return transfer_address_.GetNoArena();
}
inline void TaskInfo::set_transfer_address(const ::std::string& value) {
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.transfer_address)
}
#if LANG_CXX11
inline void TaskInfo::set_transfer_address(::std::string&& value) {
  
  transfer_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.data.TaskInfo.transfer_address)
}
#endif
inline void TaskInfo::set_transfer_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.data.TaskInfo.transfer_address)
}
inline void TaskInfo::set_transfer_address(const char* value, size_t size) {
  
  transfer_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.TaskInfo.transfer_address)
}
inline ::std::string* TaskInfo::mutable_transfer_address() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskInfo.transfer_address)
  return transfer_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TaskInfo::release_transfer_address() {
  // @@protoc_insertion_point(field_release:tensorflow.data.TaskInfo.transfer_address)
  
  return transfer_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TaskInfo::set_allocated_transfer_address(::std::string* transfer_address) {
  if (transfer_address != NULL) {
    
  } else {
    
  }
  transfer_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), transfer_address);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.data.TaskInfo.transfer_address)
}

// repeated string worker_tags = 6;
inline int TaskInfo::worker_tags_size() const {
  return worker_tags_.size();
}
inline void TaskInfo::clear_worker_tags() {
  worker_tags_.Clear();
}
inline const ::std::string& TaskInfo::worker_tags(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.worker_tags)
  return worker_tags_.Get(index);
}
inline ::std::string* TaskInfo::mutable_worker_tags(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.data.TaskInfo.worker_tags)
  return worker_tags_.Mutable(index);
}
inline void TaskInfo::set_worker_tags(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_tags)
  worker_tags_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void TaskInfo::set_worker_tags(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_tags)
  worker_tags_.Mutable(index)->assign(std::move(value));
}
#endif
inline void TaskInfo::set_worker_tags(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  worker_tags_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::set_worker_tags(int index, const char* value, size_t size) {
  worker_tags_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.data.TaskInfo.worker_tags)
}
inline ::std::string* TaskInfo::add_worker_tags() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.data.TaskInfo.worker_tags)
  return worker_tags_.Add();
}
inline void TaskInfo::add_worker_tags(const ::std::string& value) {
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.data.TaskInfo.worker_tags)
}
#if LANG_CXX11
inline void TaskInfo::add_worker_tags(::std::string&& value) {
  worker_tags_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.data.TaskInfo.worker_tags)
}
#endif
inline void TaskInfo::add_worker_tags(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  worker_tags_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.data.TaskInfo.worker_tags)
}
inline void TaskInfo::add_worker_tags(const char* value, size_t size) {
  worker_tags_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.data.TaskInfo.worker_tags)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TaskInfo::worker_tags() const {
  // @@protoc_insertion_point(field_list:tensorflow.data.TaskInfo.worker_tags)
  return worker_tags_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TaskInfo::mutable_worker_tags() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.data.TaskInfo.worker_tags)
  return &worker_tags_;
}

// int64 task_id = 2;
inline void TaskInfo::clear_task_id() {
  task_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskInfo::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.task_id)
  return task_id_;
}
inline void TaskInfo::set_task_id(::google::protobuf::int64 value) {
  
  task_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.task_id)
}

// int64 job_id = 3;
inline void TaskInfo::clear_job_id() {
  job_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskInfo::job_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.job_id)
  return job_id_;
}
inline void TaskInfo::set_job_id(::google::protobuf::int64 value) {
  
  job_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.job_id)
}

// int64 worker_uid = 7;
inline void TaskInfo::clear_worker_uid() {
  worker_uid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskInfo::worker_uid() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.worker_uid)
  return worker_uid_;
}
inline void TaskInfo::set_worker_uid(::google::protobuf::int64 value) {
  
  worker_uid_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.worker_uid)
}

// int64 starting_round = 5;
inline void TaskInfo::clear_starting_round() {
  starting_round_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 TaskInfo::starting_round() const {
  // @@protoc_insertion_point(field_get:tensorflow.data.TaskInfo.starting_round)
  return starting_round_;
}
inline void TaskInfo::set_starting_round(::google::protobuf::int64 value) {
  
  starting_round_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.data.TaskInfo.starting_round)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace data
}  // namespace tensorflow

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tensorflow::data::TargetWorkers> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tensorflow::data::TargetWorkers>() {
  return ::tensorflow::data::TargetWorkers_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fcore_2fdata_2fservice_2fcommon_2eproto
