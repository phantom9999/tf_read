// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: tensorflow/core/protobuf/coordination_service.proto

#include "tensorflow/core/protobuf/coordination_service.pb.h"
#include "tensorflow/core/protobuf/coordination_service.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace tensorflow {

static const char* CoordinationService_method_names[] = {
  "/tensorflow.CoordinationService/RegisterTask",
  "/tensorflow.CoordinationService/Heartbeat",
  "/tensorflow.CoordinationService/WaitForAllTasks",
  "/tensorflow.CoordinationService/ShutdownTask",
  "/tensorflow.CoordinationService/ResetTask",
  "/tensorflow.CoordinationService/ReportErrorToTask",
  "/tensorflow.CoordinationService/ReportErrorToService",
  "/tensorflow.CoordinationService/InsertKeyValue",
  "/tensorflow.CoordinationService/GetKeyValue",
  "/tensorflow.CoordinationService/DeleteKeyValue",
  "/tensorflow.CoordinationService/Barrier",
  "/tensorflow.CoordinationService/CancelBarrier",
};

std::unique_ptr< CoordinationService::Stub> CoordinationService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< CoordinationService::Stub> stub(new CoordinationService::Stub(channel));
  return stub;
}

CoordinationService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_RegisterTask_(CoordinationService_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Heartbeat_(CoordinationService_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_WaitForAllTasks_(CoordinationService_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ShutdownTask_(CoordinationService_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ResetTask_(CoordinationService_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReportErrorToTask_(CoordinationService_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ReportErrorToService_(CoordinationService_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_InsertKeyValue_(CoordinationService_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetKeyValue_(CoordinationService_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_DeleteKeyValue_(CoordinationService_method_names[9], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Barrier_(CoordinationService_method_names[10], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_CancelBarrier_(CoordinationService_method_names[11], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status CoordinationService::Stub::RegisterTask(::grpc::ClientContext* context, const ::tensorflow::RegisterTaskRequest& request, ::tensorflow::RegisterTaskResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_RegisterTask_, context, request, response);
}

void CoordinationService::Stub::experimental_async::RegisterTask(::grpc::ClientContext* context, const ::tensorflow::RegisterTaskRequest* request, ::tensorflow::RegisterTaskResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_RegisterTask_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::RegisterTaskResponse>* CoordinationService::Stub::AsyncRegisterTaskRaw(::grpc::ClientContext* context, const ::tensorflow::RegisterTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::RegisterTaskResponse>::Create(channel_.get(), cq, rpcmethod_RegisterTask_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::RegisterTaskResponse>* CoordinationService::Stub::PrepareAsyncRegisterTaskRaw(::grpc::ClientContext* context, const ::tensorflow::RegisterTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::RegisterTaskResponse>::Create(channel_.get(), cq, rpcmethod_RegisterTask_, context, request, false);
}

::grpc::Status CoordinationService::Stub::Heartbeat(::grpc::ClientContext* context, const ::tensorflow::HeartbeatRequest& request, ::tensorflow::HeartbeatResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Heartbeat_, context, request, response);
}

void CoordinationService::Stub::experimental_async::Heartbeat(::grpc::ClientContext* context, const ::tensorflow::HeartbeatRequest* request, ::tensorflow::HeartbeatResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Heartbeat_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::HeartbeatResponse>* CoordinationService::Stub::AsyncHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::HeartbeatResponse>::Create(channel_.get(), cq, rpcmethod_Heartbeat_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::HeartbeatResponse>* CoordinationService::Stub::PrepareAsyncHeartbeatRaw(::grpc::ClientContext* context, const ::tensorflow::HeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::HeartbeatResponse>::Create(channel_.get(), cq, rpcmethod_Heartbeat_, context, request, false);
}

::grpc::Status CoordinationService::Stub::WaitForAllTasks(::grpc::ClientContext* context, const ::tensorflow::WaitForAllTasksRequest& request, ::tensorflow::WaitForAllTasksResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_WaitForAllTasks_, context, request, response);
}

void CoordinationService::Stub::experimental_async::WaitForAllTasks(::grpc::ClientContext* context, const ::tensorflow::WaitForAllTasksRequest* request, ::tensorflow::WaitForAllTasksResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_WaitForAllTasks_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::WaitForAllTasksResponse>* CoordinationService::Stub::AsyncWaitForAllTasksRaw(::grpc::ClientContext* context, const ::tensorflow::WaitForAllTasksRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::WaitForAllTasksResponse>::Create(channel_.get(), cq, rpcmethod_WaitForAllTasks_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::WaitForAllTasksResponse>* CoordinationService::Stub::PrepareAsyncWaitForAllTasksRaw(::grpc::ClientContext* context, const ::tensorflow::WaitForAllTasksRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::WaitForAllTasksResponse>::Create(channel_.get(), cq, rpcmethod_WaitForAllTasks_, context, request, false);
}

::grpc::Status CoordinationService::Stub::ShutdownTask(::grpc::ClientContext* context, const ::tensorflow::ShutdownTaskRequest& request, ::tensorflow::ShutdownTaskResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ShutdownTask_, context, request, response);
}

void CoordinationService::Stub::experimental_async::ShutdownTask(::grpc::ClientContext* context, const ::tensorflow::ShutdownTaskRequest* request, ::tensorflow::ShutdownTaskResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ShutdownTask_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ShutdownTaskResponse>* CoordinationService::Stub::AsyncShutdownTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ShutdownTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::ShutdownTaskResponse>::Create(channel_.get(), cq, rpcmethod_ShutdownTask_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ShutdownTaskResponse>* CoordinationService::Stub::PrepareAsyncShutdownTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ShutdownTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::ShutdownTaskResponse>::Create(channel_.get(), cq, rpcmethod_ShutdownTask_, context, request, false);
}

::grpc::Status CoordinationService::Stub::ResetTask(::grpc::ClientContext* context, const ::tensorflow::ResetTaskRequest& request, ::tensorflow::ResetTaskResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ResetTask_, context, request, response);
}

void CoordinationService::Stub::experimental_async::ResetTask(::grpc::ClientContext* context, const ::tensorflow::ResetTaskRequest* request, ::tensorflow::ResetTaskResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ResetTask_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ResetTaskResponse>* CoordinationService::Stub::AsyncResetTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ResetTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::ResetTaskResponse>::Create(channel_.get(), cq, rpcmethod_ResetTask_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ResetTaskResponse>* CoordinationService::Stub::PrepareAsyncResetTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ResetTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::ResetTaskResponse>::Create(channel_.get(), cq, rpcmethod_ResetTask_, context, request, false);
}

::grpc::Status CoordinationService::Stub::ReportErrorToTask(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToTaskRequest& request, ::tensorflow::ReportErrorToTaskResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ReportErrorToTask_, context, request, response);
}

void CoordinationService::Stub::experimental_async::ReportErrorToTask(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToTaskRequest* request, ::tensorflow::ReportErrorToTaskResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReportErrorToTask_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ReportErrorToTaskResponse>* CoordinationService::Stub::AsyncReportErrorToTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::ReportErrorToTaskResponse>::Create(channel_.get(), cq, rpcmethod_ReportErrorToTask_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ReportErrorToTaskResponse>* CoordinationService::Stub::PrepareAsyncReportErrorToTaskRaw(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToTaskRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::ReportErrorToTaskResponse>::Create(channel_.get(), cq, rpcmethod_ReportErrorToTask_, context, request, false);
}

::grpc::Status CoordinationService::Stub::ReportErrorToService(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToServiceRequest& request, ::tensorflow::ReportErrorToServiceResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ReportErrorToService_, context, request, response);
}

void CoordinationService::Stub::experimental_async::ReportErrorToService(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToServiceRequest* request, ::tensorflow::ReportErrorToServiceResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ReportErrorToService_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ReportErrorToServiceResponse>* CoordinationService::Stub::AsyncReportErrorToServiceRaw(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToServiceRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::ReportErrorToServiceResponse>::Create(channel_.get(), cq, rpcmethod_ReportErrorToService_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::ReportErrorToServiceResponse>* CoordinationService::Stub::PrepareAsyncReportErrorToServiceRaw(::grpc::ClientContext* context, const ::tensorflow::ReportErrorToServiceRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::ReportErrorToServiceResponse>::Create(channel_.get(), cq, rpcmethod_ReportErrorToService_, context, request, false);
}

::grpc::Status CoordinationService::Stub::InsertKeyValue(::grpc::ClientContext* context, const ::tensorflow::InsertKeyValueRequest& request, ::tensorflow::InsertKeyValueResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_InsertKeyValue_, context, request, response);
}

void CoordinationService::Stub::experimental_async::InsertKeyValue(::grpc::ClientContext* context, const ::tensorflow::InsertKeyValueRequest* request, ::tensorflow::InsertKeyValueResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_InsertKeyValue_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::InsertKeyValueResponse>* CoordinationService::Stub::AsyncInsertKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::InsertKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::InsertKeyValueResponse>::Create(channel_.get(), cq, rpcmethod_InsertKeyValue_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::InsertKeyValueResponse>* CoordinationService::Stub::PrepareAsyncInsertKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::InsertKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::InsertKeyValueResponse>::Create(channel_.get(), cq, rpcmethod_InsertKeyValue_, context, request, false);
}

::grpc::Status CoordinationService::Stub::GetKeyValue(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueRequest& request, ::tensorflow::GetKeyValueResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetKeyValue_, context, request, response);
}

void CoordinationService::Stub::experimental_async::GetKeyValue(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueRequest* request, ::tensorflow::GetKeyValueResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetKeyValue_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetKeyValueResponse>* CoordinationService::Stub::AsyncGetKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::GetKeyValueResponse>::Create(channel_.get(), cq, rpcmethod_GetKeyValue_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::GetKeyValueResponse>* CoordinationService::Stub::PrepareAsyncGetKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::GetKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::GetKeyValueResponse>::Create(channel_.get(), cq, rpcmethod_GetKeyValue_, context, request, false);
}

::grpc::Status CoordinationService::Stub::DeleteKeyValue(::grpc::ClientContext* context, const ::tensorflow::DeleteKeyValueRequest& request, ::tensorflow::DeleteKeyValueResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_DeleteKeyValue_, context, request, response);
}

void CoordinationService::Stub::experimental_async::DeleteKeyValue(::grpc::ClientContext* context, const ::tensorflow::DeleteKeyValueRequest* request, ::tensorflow::DeleteKeyValueResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_DeleteKeyValue_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::DeleteKeyValueResponse>* CoordinationService::Stub::AsyncDeleteKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::DeleteKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::DeleteKeyValueResponse>::Create(channel_.get(), cq, rpcmethod_DeleteKeyValue_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::DeleteKeyValueResponse>* CoordinationService::Stub::PrepareAsyncDeleteKeyValueRaw(::grpc::ClientContext* context, const ::tensorflow::DeleteKeyValueRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::DeleteKeyValueResponse>::Create(channel_.get(), cq, rpcmethod_DeleteKeyValue_, context, request, false);
}

::grpc::Status CoordinationService::Stub::Barrier(::grpc::ClientContext* context, const ::tensorflow::BarrierRequest& request, ::tensorflow::BarrierResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Barrier_, context, request, response);
}

void CoordinationService::Stub::experimental_async::Barrier(::grpc::ClientContext* context, const ::tensorflow::BarrierRequest* request, ::tensorflow::BarrierResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Barrier_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::BarrierResponse>* CoordinationService::Stub::AsyncBarrierRaw(::grpc::ClientContext* context, const ::tensorflow::BarrierRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::BarrierResponse>::Create(channel_.get(), cq, rpcmethod_Barrier_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::BarrierResponse>* CoordinationService::Stub::PrepareAsyncBarrierRaw(::grpc::ClientContext* context, const ::tensorflow::BarrierRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::BarrierResponse>::Create(channel_.get(), cq, rpcmethod_Barrier_, context, request, false);
}

::grpc::Status CoordinationService::Stub::CancelBarrier(::grpc::ClientContext* context, const ::tensorflow::CancelBarrierRequest& request, ::tensorflow::CancelBarrierResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_CancelBarrier_, context, request, response);
}

void CoordinationService::Stub::experimental_async::CancelBarrier(::grpc::ClientContext* context, const ::tensorflow::CancelBarrierRequest* request, ::tensorflow::CancelBarrierResponse* response, std::function<void(::grpc::Status)> f) {
  return ::grpc::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_CancelBarrier_, context, request, response, std::move(f));
}

::grpc::ClientAsyncResponseReader< ::tensorflow::CancelBarrierResponse>* CoordinationService::Stub::AsyncCancelBarrierRaw(::grpc::ClientContext* context, const ::tensorflow::CancelBarrierRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::CancelBarrierResponse>::Create(channel_.get(), cq, rpcmethod_CancelBarrier_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::tensorflow::CancelBarrierResponse>* CoordinationService::Stub::PrepareAsyncCancelBarrierRaw(::grpc::ClientContext* context, const ::tensorflow::CancelBarrierRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncResponseReaderFactory< ::tensorflow::CancelBarrierResponse>::Create(channel_.get(), cq, rpcmethod_CancelBarrier_, context, request, false);
}

CoordinationService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::RegisterTaskRequest, ::tensorflow::RegisterTaskResponse>(
          std::mem_fn(&CoordinationService::Service::RegisterTask), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::HeartbeatRequest, ::tensorflow::HeartbeatResponse>(
          std::mem_fn(&CoordinationService::Service::Heartbeat), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::WaitForAllTasksRequest, ::tensorflow::WaitForAllTasksResponse>(
          std::mem_fn(&CoordinationService::Service::WaitForAllTasks), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::ShutdownTaskRequest, ::tensorflow::ShutdownTaskResponse>(
          std::mem_fn(&CoordinationService::Service::ShutdownTask), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::ResetTaskRequest, ::tensorflow::ResetTaskResponse>(
          std::mem_fn(&CoordinationService::Service::ResetTask), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::ReportErrorToTaskRequest, ::tensorflow::ReportErrorToTaskResponse>(
          std::mem_fn(&CoordinationService::Service::ReportErrorToTask), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::ReportErrorToServiceRequest, ::tensorflow::ReportErrorToServiceResponse>(
          std::mem_fn(&CoordinationService::Service::ReportErrorToService), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::InsertKeyValueRequest, ::tensorflow::InsertKeyValueResponse>(
          std::mem_fn(&CoordinationService::Service::InsertKeyValue), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::GetKeyValueRequest, ::tensorflow::GetKeyValueResponse>(
          std::mem_fn(&CoordinationService::Service::GetKeyValue), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[9],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::DeleteKeyValueRequest, ::tensorflow::DeleteKeyValueResponse>(
          std::mem_fn(&CoordinationService::Service::DeleteKeyValue), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::BarrierRequest, ::tensorflow::BarrierResponse>(
          std::mem_fn(&CoordinationService::Service::Barrier), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      CoordinationService_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< CoordinationService::Service, ::tensorflow::CancelBarrierRequest, ::tensorflow::CancelBarrierResponse>(
          std::mem_fn(&CoordinationService::Service::CancelBarrier), this)));
}

CoordinationService::Service::~Service() {
}

::grpc::Status CoordinationService::Service::RegisterTask(::grpc::ServerContext* context, const ::tensorflow::RegisterTaskRequest* request, ::tensorflow::RegisterTaskResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::Heartbeat(::grpc::ServerContext* context, const ::tensorflow::HeartbeatRequest* request, ::tensorflow::HeartbeatResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::WaitForAllTasks(::grpc::ServerContext* context, const ::tensorflow::WaitForAllTasksRequest* request, ::tensorflow::WaitForAllTasksResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::ShutdownTask(::grpc::ServerContext* context, const ::tensorflow::ShutdownTaskRequest* request, ::tensorflow::ShutdownTaskResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::ResetTask(::grpc::ServerContext* context, const ::tensorflow::ResetTaskRequest* request, ::tensorflow::ResetTaskResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::ReportErrorToTask(::grpc::ServerContext* context, const ::tensorflow::ReportErrorToTaskRequest* request, ::tensorflow::ReportErrorToTaskResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::ReportErrorToService(::grpc::ServerContext* context, const ::tensorflow::ReportErrorToServiceRequest* request, ::tensorflow::ReportErrorToServiceResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::InsertKeyValue(::grpc::ServerContext* context, const ::tensorflow::InsertKeyValueRequest* request, ::tensorflow::InsertKeyValueResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::GetKeyValue(::grpc::ServerContext* context, const ::tensorflow::GetKeyValueRequest* request, ::tensorflow::GetKeyValueResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::DeleteKeyValue(::grpc::ServerContext* context, const ::tensorflow::DeleteKeyValueRequest* request, ::tensorflow::DeleteKeyValueResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::Barrier(::grpc::ServerContext* context, const ::tensorflow::BarrierRequest* request, ::tensorflow::BarrierResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status CoordinationService::Service::CancelBarrier(::grpc::ServerContext* context, const ::tensorflow::CancelBarrierRequest* request, ::tensorflow::CancelBarrierResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace tensorflow

