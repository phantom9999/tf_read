// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/core/protobuf/coordination_service.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/compiler/xla/pjrt/distributed/protocol.pb.h"
#include "tensorflow/core/framework/device_attributes.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto 

namespace protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[30];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto
namespace tensorflow {
class BarrierRequest;
class BarrierRequestDefaultTypeInternal;
extern BarrierRequestDefaultTypeInternal _BarrierRequest_default_instance_;
class BarrierResponse;
class BarrierResponseDefaultTypeInternal;
extern BarrierResponseDefaultTypeInternal _BarrierResponse_default_instance_;
class CancelBarrierRequest;
class CancelBarrierRequestDefaultTypeInternal;
extern CancelBarrierRequestDefaultTypeInternal _CancelBarrierRequest_default_instance_;
class CancelBarrierResponse;
class CancelBarrierResponseDefaultTypeInternal;
extern CancelBarrierResponseDefaultTypeInternal _CancelBarrierResponse_default_instance_;
class CoordinatedTask;
class CoordinatedTaskDefaultTypeInternal;
extern CoordinatedTaskDefaultTypeInternal _CoordinatedTask_default_instance_;
class CoordinationServiceDeviceInfo;
class CoordinationServiceDeviceInfoDefaultTypeInternal;
extern CoordinationServiceDeviceInfoDefaultTypeInternal _CoordinationServiceDeviceInfo_default_instance_;
class CoordinationServiceError;
class CoordinationServiceErrorDefaultTypeInternal;
extern CoordinationServiceErrorDefaultTypeInternal _CoordinationServiceError_default_instance_;
class DeleteKeyValueRequest;
class DeleteKeyValueRequestDefaultTypeInternal;
extern DeleteKeyValueRequestDefaultTypeInternal _DeleteKeyValueRequest_default_instance_;
class DeleteKeyValueResponse;
class DeleteKeyValueResponseDefaultTypeInternal;
extern DeleteKeyValueResponseDefaultTypeInternal _DeleteKeyValueResponse_default_instance_;
class GetKeyValueRequest;
class GetKeyValueRequestDefaultTypeInternal;
extern GetKeyValueRequestDefaultTypeInternal _GetKeyValueRequest_default_instance_;
class GetKeyValueResponse;
class GetKeyValueResponseDefaultTypeInternal;
extern GetKeyValueResponseDefaultTypeInternal _GetKeyValueResponse_default_instance_;
class HeartbeatRequest;
class HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HeartbeatResponse;
class HeartbeatResponseDefaultTypeInternal;
extern HeartbeatResponseDefaultTypeInternal _HeartbeatResponse_default_instance_;
class InsertKeyValueRequest;
class InsertKeyValueRequestDefaultTypeInternal;
extern InsertKeyValueRequestDefaultTypeInternal _InsertKeyValueRequest_default_instance_;
class InsertKeyValueResponse;
class InsertKeyValueResponseDefaultTypeInternal;
extern InsertKeyValueResponseDefaultTypeInternal _InsertKeyValueResponse_default_instance_;
class KeyValueEntry;
class KeyValueEntryDefaultTypeInternal;
extern KeyValueEntryDefaultTypeInternal _KeyValueEntry_default_instance_;
class RegisterTaskRequest;
class RegisterTaskRequestDefaultTypeInternal;
extern RegisterTaskRequestDefaultTypeInternal _RegisterTaskRequest_default_instance_;
class RegisterTaskResponse;
class RegisterTaskResponseDefaultTypeInternal;
extern RegisterTaskResponseDefaultTypeInternal _RegisterTaskResponse_default_instance_;
class ReportErrorToServiceRequest;
class ReportErrorToServiceRequestDefaultTypeInternal;
extern ReportErrorToServiceRequestDefaultTypeInternal _ReportErrorToServiceRequest_default_instance_;
class ReportErrorToServiceResponse;
class ReportErrorToServiceResponseDefaultTypeInternal;
extern ReportErrorToServiceResponseDefaultTypeInternal _ReportErrorToServiceResponse_default_instance_;
class ReportErrorToTaskRequest;
class ReportErrorToTaskRequestDefaultTypeInternal;
extern ReportErrorToTaskRequestDefaultTypeInternal _ReportErrorToTaskRequest_default_instance_;
class ReportErrorToTaskResponse;
class ReportErrorToTaskResponseDefaultTypeInternal;
extern ReportErrorToTaskResponseDefaultTypeInternal _ReportErrorToTaskResponse_default_instance_;
class ResetTaskRequest;
class ResetTaskRequestDefaultTypeInternal;
extern ResetTaskRequestDefaultTypeInternal _ResetTaskRequest_default_instance_;
class ResetTaskResponse;
class ResetTaskResponseDefaultTypeInternal;
extern ResetTaskResponseDefaultTypeInternal _ResetTaskResponse_default_instance_;
class ShutdownTaskRequest;
class ShutdownTaskRequestDefaultTypeInternal;
extern ShutdownTaskRequestDefaultTypeInternal _ShutdownTaskRequest_default_instance_;
class ShutdownTaskResponse;
class ShutdownTaskResponseDefaultTypeInternal;
extern ShutdownTaskResponseDefaultTypeInternal _ShutdownTaskResponse_default_instance_;
class TfDeviceList;
class TfDeviceListDefaultTypeInternal;
extern TfDeviceListDefaultTypeInternal _TfDeviceList_default_instance_;
class WaitForAllTasksRequest;
class WaitForAllTasksRequestDefaultTypeInternal;
extern WaitForAllTasksRequestDefaultTypeInternal _WaitForAllTasksRequest_default_instance_;
class WaitForAllTasksResponse;
class WaitForAllTasksResponseDefaultTypeInternal;
extern WaitForAllTasksResponseDefaultTypeInternal _WaitForAllTasksResponse_default_instance_;
class XlaDeviceList;
class XlaDeviceListDefaultTypeInternal;
extern XlaDeviceListDefaultTypeInternal _XlaDeviceList_default_instance_;
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::BarrierRequest* Arena::CreateMaybeMessage<::tensorflow::BarrierRequest>(Arena*);
template<> ::tensorflow::BarrierResponse* Arena::CreateMaybeMessage<::tensorflow::BarrierResponse>(Arena*);
template<> ::tensorflow::CancelBarrierRequest* Arena::CreateMaybeMessage<::tensorflow::CancelBarrierRequest>(Arena*);
template<> ::tensorflow::CancelBarrierResponse* Arena::CreateMaybeMessage<::tensorflow::CancelBarrierResponse>(Arena*);
template<> ::tensorflow::CoordinatedTask* Arena::CreateMaybeMessage<::tensorflow::CoordinatedTask>(Arena*);
template<> ::tensorflow::CoordinationServiceDeviceInfo* Arena::CreateMaybeMessage<::tensorflow::CoordinationServiceDeviceInfo>(Arena*);
template<> ::tensorflow::CoordinationServiceError* Arena::CreateMaybeMessage<::tensorflow::CoordinationServiceError>(Arena*);
template<> ::tensorflow::DeleteKeyValueRequest* Arena::CreateMaybeMessage<::tensorflow::DeleteKeyValueRequest>(Arena*);
template<> ::tensorflow::DeleteKeyValueResponse* Arena::CreateMaybeMessage<::tensorflow::DeleteKeyValueResponse>(Arena*);
template<> ::tensorflow::GetKeyValueRequest* Arena::CreateMaybeMessage<::tensorflow::GetKeyValueRequest>(Arena*);
template<> ::tensorflow::GetKeyValueResponse* Arena::CreateMaybeMessage<::tensorflow::GetKeyValueResponse>(Arena*);
template<> ::tensorflow::HeartbeatRequest* Arena::CreateMaybeMessage<::tensorflow::HeartbeatRequest>(Arena*);
template<> ::tensorflow::HeartbeatResponse* Arena::CreateMaybeMessage<::tensorflow::HeartbeatResponse>(Arena*);
template<> ::tensorflow::InsertKeyValueRequest* Arena::CreateMaybeMessage<::tensorflow::InsertKeyValueRequest>(Arena*);
template<> ::tensorflow::InsertKeyValueResponse* Arena::CreateMaybeMessage<::tensorflow::InsertKeyValueResponse>(Arena*);
template<> ::tensorflow::KeyValueEntry* Arena::CreateMaybeMessage<::tensorflow::KeyValueEntry>(Arena*);
template<> ::tensorflow::RegisterTaskRequest* Arena::CreateMaybeMessage<::tensorflow::RegisterTaskRequest>(Arena*);
template<> ::tensorflow::RegisterTaskResponse* Arena::CreateMaybeMessage<::tensorflow::RegisterTaskResponse>(Arena*);
template<> ::tensorflow::ReportErrorToServiceRequest* Arena::CreateMaybeMessage<::tensorflow::ReportErrorToServiceRequest>(Arena*);
template<> ::tensorflow::ReportErrorToServiceResponse* Arena::CreateMaybeMessage<::tensorflow::ReportErrorToServiceResponse>(Arena*);
template<> ::tensorflow::ReportErrorToTaskRequest* Arena::CreateMaybeMessage<::tensorflow::ReportErrorToTaskRequest>(Arena*);
template<> ::tensorflow::ReportErrorToTaskResponse* Arena::CreateMaybeMessage<::tensorflow::ReportErrorToTaskResponse>(Arena*);
template<> ::tensorflow::ResetTaskRequest* Arena::CreateMaybeMessage<::tensorflow::ResetTaskRequest>(Arena*);
template<> ::tensorflow::ResetTaskResponse* Arena::CreateMaybeMessage<::tensorflow::ResetTaskResponse>(Arena*);
template<> ::tensorflow::ShutdownTaskRequest* Arena::CreateMaybeMessage<::tensorflow::ShutdownTaskRequest>(Arena*);
template<> ::tensorflow::ShutdownTaskResponse* Arena::CreateMaybeMessage<::tensorflow::ShutdownTaskResponse>(Arena*);
template<> ::tensorflow::TfDeviceList* Arena::CreateMaybeMessage<::tensorflow::TfDeviceList>(Arena*);
template<> ::tensorflow::WaitForAllTasksRequest* Arena::CreateMaybeMessage<::tensorflow::WaitForAllTasksRequest>(Arena*);
template<> ::tensorflow::WaitForAllTasksResponse* Arena::CreateMaybeMessage<::tensorflow::WaitForAllTasksResponse>(Arena*);
template<> ::tensorflow::XlaDeviceList* Arena::CreateMaybeMessage<::tensorflow::XlaDeviceList>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {

// ===================================================================

class CoordinatedTask : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CoordinatedTask) */ {
 public:
  CoordinatedTask();
  virtual ~CoordinatedTask();

  CoordinatedTask(const CoordinatedTask& from);

  inline CoordinatedTask& operator=(const CoordinatedTask& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CoordinatedTask(CoordinatedTask&& from) noexcept
    : CoordinatedTask() {
    *this = ::std::move(from);
  }

  inline CoordinatedTask& operator=(CoordinatedTask&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CoordinatedTask& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoordinatedTask* internal_default_instance() {
    return reinterpret_cast<const CoordinatedTask*>(
               &_CoordinatedTask_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(CoordinatedTask* other);
  friend void swap(CoordinatedTask& a, CoordinatedTask& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CoordinatedTask* New() const final {
    return CreateMaybeMessage<CoordinatedTask>(NULL);
  }

  CoordinatedTask* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CoordinatedTask>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CoordinatedTask& from);
  void MergeFrom(const CoordinatedTask& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinatedTask* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string job_name = 1;
  void clear_job_name();
  static const int kJobNameFieldNumber = 1;
  const ::std::string& job_name() const;
  void set_job_name(const ::std::string& value);
  #if LANG_CXX11
  void set_job_name(::std::string&& value);
  #endif
  void set_job_name(const char* value);
  void set_job_name(const char* value, size_t size);
  ::std::string* mutable_job_name();
  ::std::string* release_job_name();
  void set_allocated_job_name(::std::string* job_name);

  // int32 task_id = 2;
  void clear_task_id();
  static const int kTaskIdFieldNumber = 2;
  ::google::protobuf::int32 task_id() const;
  void set_task_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.CoordinatedTask)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr job_name_;
  ::google::protobuf::int32 task_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CoordinationServiceError : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CoordinationServiceError) */ {
 public:
  CoordinationServiceError();
  virtual ~CoordinationServiceError();

  CoordinationServiceError(const CoordinationServiceError& from);

  inline CoordinationServiceError& operator=(const CoordinationServiceError& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CoordinationServiceError(CoordinationServiceError&& from) noexcept
    : CoordinationServiceError() {
    *this = ::std::move(from);
  }

  inline CoordinationServiceError& operator=(CoordinationServiceError&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CoordinationServiceError& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoordinationServiceError* internal_default_instance() {
    return reinterpret_cast<const CoordinationServiceError*>(
               &_CoordinationServiceError_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(CoordinationServiceError* other);
  friend void swap(CoordinationServiceError& a, CoordinationServiceError& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CoordinationServiceError* New() const final {
    return CreateMaybeMessage<CoordinationServiceError>(NULL);
  }

  CoordinationServiceError* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CoordinationServiceError>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CoordinationServiceError& from);
  void MergeFrom(const CoordinationServiceError& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinationServiceError* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.CoordinatedTask source_task = 4;
  bool has_source_task() const;
  void clear_source_task();
  static const int kSourceTaskFieldNumber = 4;
  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  public:
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // bool is_reported_error = 3;
  void clear_is_reported_error();
  static const int kIsReportedErrorFieldNumber = 3;
  bool is_reported_error() const;
  void set_is_reported_error(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.CoordinationServiceError)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinatedTask* source_task_;
  bool is_reported_error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class TfDeviceList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.TfDeviceList) */ {
 public:
  TfDeviceList();
  virtual ~TfDeviceList();

  TfDeviceList(const TfDeviceList& from);

  inline TfDeviceList& operator=(const TfDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TfDeviceList(TfDeviceList&& from) noexcept
    : TfDeviceList() {
    *this = ::std::move(from);
  }

  inline TfDeviceList& operator=(TfDeviceList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const TfDeviceList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TfDeviceList* internal_default_instance() {
    return reinterpret_cast<const TfDeviceList*>(
               &_TfDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(TfDeviceList* other);
  friend void swap(TfDeviceList& a, TfDeviceList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TfDeviceList* New() const final {
    return CreateMaybeMessage<TfDeviceList>(NULL);
  }

  TfDeviceList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TfDeviceList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TfDeviceList& from);
  void MergeFrom(const TfDeviceList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TfDeviceList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.DeviceAttributes devices = 1;
  int devices_size() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 1;
  ::tensorflow::DeviceAttributes* mutable_devices(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
      mutable_devices();
  const ::tensorflow::DeviceAttributes& devices(int index) const;
  ::tensorflow::DeviceAttributes* add_devices();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
      devices() const;

  // @@protoc_insertion_point(class_scope:tensorflow.TfDeviceList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes > devices_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XlaDeviceList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.XlaDeviceList) */ {
 public:
  XlaDeviceList();
  virtual ~XlaDeviceList();

  XlaDeviceList(const XlaDeviceList& from);

  inline XlaDeviceList& operator=(const XlaDeviceList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XlaDeviceList(XlaDeviceList&& from) noexcept
    : XlaDeviceList() {
    *this = ::std::move(from);
  }

  inline XlaDeviceList& operator=(XlaDeviceList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XlaDeviceList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XlaDeviceList* internal_default_instance() {
    return reinterpret_cast<const XlaDeviceList*>(
               &_XlaDeviceList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(XlaDeviceList* other);
  friend void swap(XlaDeviceList& a, XlaDeviceList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XlaDeviceList* New() const final {
    return CreateMaybeMessage<XlaDeviceList>(NULL);
  }

  XlaDeviceList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XlaDeviceList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XlaDeviceList& from);
  void MergeFrom(const XlaDeviceList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XlaDeviceList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xla.GlobalTopologyProto devices = 1;
  bool has_devices() const;
  void clear_devices();
  static const int kDevicesFieldNumber = 1;
  private:
  const ::xla::GlobalTopologyProto& _internal_devices() const;
  public:
  const ::xla::GlobalTopologyProto& devices() const;
  ::xla::GlobalTopologyProto* release_devices();
  ::xla::GlobalTopologyProto* mutable_devices();
  void set_allocated_devices(::xla::GlobalTopologyProto* devices);

  // @@protoc_insertion_point(class_scope:tensorflow.XlaDeviceList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xla::GlobalTopologyProto* devices_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CoordinationServiceDeviceInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CoordinationServiceDeviceInfo) */ {
 public:
  CoordinationServiceDeviceInfo();
  virtual ~CoordinationServiceDeviceInfo();

  CoordinationServiceDeviceInfo(const CoordinationServiceDeviceInfo& from);

  inline CoordinationServiceDeviceInfo& operator=(const CoordinationServiceDeviceInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CoordinationServiceDeviceInfo(CoordinationServiceDeviceInfo&& from) noexcept
    : CoordinationServiceDeviceInfo() {
    *this = ::std::move(from);
  }

  inline CoordinationServiceDeviceInfo& operator=(CoordinationServiceDeviceInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CoordinationServiceDeviceInfo& default_instance();

  enum TypeCase {
    kTf = 1,
    kXla = 2,
    TYPE_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CoordinationServiceDeviceInfo* internal_default_instance() {
    return reinterpret_cast<const CoordinationServiceDeviceInfo*>(
               &_CoordinationServiceDeviceInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(CoordinationServiceDeviceInfo* other);
  friend void swap(CoordinationServiceDeviceInfo& a, CoordinationServiceDeviceInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CoordinationServiceDeviceInfo* New() const final {
    return CreateMaybeMessage<CoordinationServiceDeviceInfo>(NULL);
  }

  CoordinationServiceDeviceInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CoordinationServiceDeviceInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CoordinationServiceDeviceInfo& from);
  void MergeFrom(const CoordinationServiceDeviceInfo& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CoordinationServiceDeviceInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.TfDeviceList tf = 1;
  bool has_tf() const;
  void clear_tf();
  static const int kTfFieldNumber = 1;
  private:
  const ::tensorflow::TfDeviceList& _internal_tf() const;
  public:
  const ::tensorflow::TfDeviceList& tf() const;
  ::tensorflow::TfDeviceList* release_tf();
  ::tensorflow::TfDeviceList* mutable_tf();
  void set_allocated_tf(::tensorflow::TfDeviceList* tf);

  // .tensorflow.XlaDeviceList xla = 2;
  bool has_xla() const;
  void clear_xla();
  static const int kXlaFieldNumber = 2;
  private:
  const ::tensorflow::XlaDeviceList& _internal_xla() const;
  public:
  const ::tensorflow::XlaDeviceList& xla() const;
  ::tensorflow::XlaDeviceList* release_xla();
  ::tensorflow::XlaDeviceList* mutable_xla();
  void set_allocated_xla(::tensorflow::XlaDeviceList* xla);

  void clear_type();
  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:tensorflow.CoordinationServiceDeviceInfo)
 private:
  void set_has_tf();
  void set_has_xla();

  inline bool has_type() const;
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union TypeUnion {
    TypeUnion() {}
    ::tensorflow::TfDeviceList* tf_;
    ::tensorflow::XlaDeviceList* xla_;
  } type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterTaskRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.RegisterTaskRequest) */ {
 public:
  RegisterTaskRequest();
  virtual ~RegisterTaskRequest();

  RegisterTaskRequest(const RegisterTaskRequest& from);

  inline RegisterTaskRequest& operator=(const RegisterTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterTaskRequest(RegisterTaskRequest&& from) noexcept
    : RegisterTaskRequest() {
    *this = ::std::move(from);
  }

  inline RegisterTaskRequest& operator=(RegisterTaskRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterTaskRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterTaskRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterTaskRequest*>(
               &_RegisterTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(RegisterTaskRequest* other);
  friend void swap(RegisterTaskRequest& a, RegisterTaskRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterTaskRequest* New() const final {
    return CreateMaybeMessage<RegisterTaskRequest>(NULL);
  }

  RegisterTaskRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterTaskRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterTaskRequest& from);
  void MergeFrom(const RegisterTaskRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterTaskRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.CoordinatedTask source_task = 5;
  bool has_source_task() const;
  void clear_source_task();
  static const int kSourceTaskFieldNumber = 5;
  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  public:
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // fixed64 incarnation = 3;
  void clear_incarnation();
  static const int kIncarnationFieldNumber = 3;
  ::google::protobuf::uint64 incarnation() const;
  void set_incarnation(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.RegisterTaskRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinatedTask* source_task_;
  ::google::protobuf::uint64 incarnation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RegisterTaskResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.RegisterTaskResponse) */ {
 public:
  RegisterTaskResponse();
  virtual ~RegisterTaskResponse();

  RegisterTaskResponse(const RegisterTaskResponse& from);

  inline RegisterTaskResponse& operator=(const RegisterTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RegisterTaskResponse(RegisterTaskResponse&& from) noexcept
    : RegisterTaskResponse() {
    *this = ::std::move(from);
  }

  inline RegisterTaskResponse& operator=(RegisterTaskResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RegisterTaskResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RegisterTaskResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterTaskResponse*>(
               &_RegisterTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(RegisterTaskResponse* other);
  friend void swap(RegisterTaskResponse& a, RegisterTaskResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RegisterTaskResponse* New() const final {
    return CreateMaybeMessage<RegisterTaskResponse>(NULL);
  }

  RegisterTaskResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RegisterTaskResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RegisterTaskResponse& from);
  void MergeFrom(const RegisterTaskResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterTaskResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed64 leader_incarnation = 1;
  void clear_leader_incarnation();
  static const int kLeaderIncarnationFieldNumber = 1;
  ::google::protobuf::uint64 leader_incarnation() const;
  void set_leader_incarnation(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.RegisterTaskResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 leader_incarnation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.HeartbeatRequest) */ {
 public:
  HeartbeatRequest();
  virtual ~HeartbeatRequest();

  HeartbeatRequest(const HeartbeatRequest& from);

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(HeartbeatRequest* other);
  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatRequest* New() const final {
    return CreateMaybeMessage<HeartbeatRequest>(NULL);
  }

  HeartbeatRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatRequest& from);
  void MergeFrom(const HeartbeatRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.CoordinatedTask source_task = 4;
  bool has_source_task() const;
  void clear_source_task();
  static const int kSourceTaskFieldNumber = 4;
  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  public:
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // fixed64 incarnation = 3;
  void clear_incarnation();
  static const int kIncarnationFieldNumber = 3;
  ::google::protobuf::uint64 incarnation() const;
  void set_incarnation(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.HeartbeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinatedTask* source_task_;
  ::google::protobuf::uint64 incarnation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.HeartbeatResponse) */ {
 public:
  HeartbeatResponse();
  virtual ~HeartbeatResponse();

  HeartbeatResponse(const HeartbeatResponse& from);

  inline HeartbeatResponse& operator=(const HeartbeatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatResponse(HeartbeatResponse&& from) noexcept
    : HeartbeatResponse() {
    *this = ::std::move(from);
  }

  inline HeartbeatResponse& operator=(HeartbeatResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatResponse* internal_default_instance() {
    return reinterpret_cast<const HeartbeatResponse*>(
               &_HeartbeatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(HeartbeatResponse* other);
  friend void swap(HeartbeatResponse& a, HeartbeatResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatResponse* New() const final {
    return CreateMaybeMessage<HeartbeatResponse>(NULL);
  }

  HeartbeatResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatResponse& from);
  void MergeFrom(const HeartbeatResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // fixed64 leader_incarnation = 1;
  void clear_leader_incarnation();
  static const int kLeaderIncarnationFieldNumber = 1;
  ::google::protobuf::uint64 leader_incarnation() const;
  void set_leader_incarnation(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.HeartbeatResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 leader_incarnation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitForAllTasksRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.WaitForAllTasksRequest) */ {
 public:
  WaitForAllTasksRequest();
  virtual ~WaitForAllTasksRequest();

  WaitForAllTasksRequest(const WaitForAllTasksRequest& from);

  inline WaitForAllTasksRequest& operator=(const WaitForAllTasksRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitForAllTasksRequest(WaitForAllTasksRequest&& from) noexcept
    : WaitForAllTasksRequest() {
    *this = ::std::move(from);
  }

  inline WaitForAllTasksRequest& operator=(WaitForAllTasksRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitForAllTasksRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitForAllTasksRequest* internal_default_instance() {
    return reinterpret_cast<const WaitForAllTasksRequest*>(
               &_WaitForAllTasksRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(WaitForAllTasksRequest* other);
  friend void swap(WaitForAllTasksRequest& a, WaitForAllTasksRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitForAllTasksRequest* New() const final {
    return CreateMaybeMessage<WaitForAllTasksRequest>(NULL);
  }

  WaitForAllTasksRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitForAllTasksRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitForAllTasksRequest& from);
  void MergeFrom(const WaitForAllTasksRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitForAllTasksRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.CoordinationServiceDeviceInfo local_device_info = 4;
  bool has_local_device_info() const;
  void clear_local_device_info();
  static const int kLocalDeviceInfoFieldNumber = 4;
  private:
  const ::tensorflow::CoordinationServiceDeviceInfo& _internal_local_device_info() const;
  public:
  const ::tensorflow::CoordinationServiceDeviceInfo& local_device_info() const;
  ::tensorflow::CoordinationServiceDeviceInfo* release_local_device_info();
  ::tensorflow::CoordinationServiceDeviceInfo* mutable_local_device_info();
  void set_allocated_local_device_info(::tensorflow::CoordinationServiceDeviceInfo* local_device_info);

  // .tensorflow.CoordinatedTask source_task = 5;
  bool has_source_task() const;
  void clear_source_task();
  static const int kSourceTaskFieldNumber = 5;
  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  public:
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // @@protoc_insertion_point(class_scope:tensorflow.WaitForAllTasksRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinationServiceDeviceInfo* local_device_info_;
  ::tensorflow::CoordinatedTask* source_task_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WaitForAllTasksResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.WaitForAllTasksResponse) */ {
 public:
  WaitForAllTasksResponse();
  virtual ~WaitForAllTasksResponse();

  WaitForAllTasksResponse(const WaitForAllTasksResponse& from);

  inline WaitForAllTasksResponse& operator=(const WaitForAllTasksResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WaitForAllTasksResponse(WaitForAllTasksResponse&& from) noexcept
    : WaitForAllTasksResponse() {
    *this = ::std::move(from);
  }

  inline WaitForAllTasksResponse& operator=(WaitForAllTasksResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WaitForAllTasksResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WaitForAllTasksResponse* internal_default_instance() {
    return reinterpret_cast<const WaitForAllTasksResponse*>(
               &_WaitForAllTasksResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(WaitForAllTasksResponse* other);
  friend void swap(WaitForAllTasksResponse& a, WaitForAllTasksResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WaitForAllTasksResponse* New() const final {
    return CreateMaybeMessage<WaitForAllTasksResponse>(NULL);
  }

  WaitForAllTasksResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WaitForAllTasksResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WaitForAllTasksResponse& from);
  void MergeFrom(const WaitForAllTasksResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WaitForAllTasksResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.CoordinationServiceDeviceInfo cluster_device_info = 3;
  bool has_cluster_device_info() const;
  void clear_cluster_device_info();
  static const int kClusterDeviceInfoFieldNumber = 3;
  private:
  const ::tensorflow::CoordinationServiceDeviceInfo& _internal_cluster_device_info() const;
  public:
  const ::tensorflow::CoordinationServiceDeviceInfo& cluster_device_info() const;
  ::tensorflow::CoordinationServiceDeviceInfo* release_cluster_device_info();
  ::tensorflow::CoordinationServiceDeviceInfo* mutable_cluster_device_info();
  void set_allocated_cluster_device_info(::tensorflow::CoordinationServiceDeviceInfo* cluster_device_info);

  // fixed64 leader_incarnation = 1;
  void clear_leader_incarnation();
  static const int kLeaderIncarnationFieldNumber = 1;
  ::google::protobuf::uint64 leader_incarnation() const;
  void set_leader_incarnation(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.WaitForAllTasksResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinationServiceDeviceInfo* cluster_device_info_;
  ::google::protobuf::uint64 leader_incarnation_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShutdownTaskRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ShutdownTaskRequest) */ {
 public:
  ShutdownTaskRequest();
  virtual ~ShutdownTaskRequest();

  ShutdownTaskRequest(const ShutdownTaskRequest& from);

  inline ShutdownTaskRequest& operator=(const ShutdownTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShutdownTaskRequest(ShutdownTaskRequest&& from) noexcept
    : ShutdownTaskRequest() {
    *this = ::std::move(from);
  }

  inline ShutdownTaskRequest& operator=(ShutdownTaskRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownTaskRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShutdownTaskRequest* internal_default_instance() {
    return reinterpret_cast<const ShutdownTaskRequest*>(
               &_ShutdownTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(ShutdownTaskRequest* other);
  friend void swap(ShutdownTaskRequest& a, ShutdownTaskRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShutdownTaskRequest* New() const final {
    return CreateMaybeMessage<ShutdownTaskRequest>(NULL);
  }

  ShutdownTaskRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShutdownTaskRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ShutdownTaskRequest& from);
  void MergeFrom(const ShutdownTaskRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownTaskRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.CoordinatedTask source_task = 1;
  bool has_source_task() const;
  void clear_source_task();
  static const int kSourceTaskFieldNumber = 1;
  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  public:
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // @@protoc_insertion_point(class_scope:tensorflow.ShutdownTaskRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinatedTask* source_task_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShutdownTaskResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ShutdownTaskResponse) */ {
 public:
  ShutdownTaskResponse();
  virtual ~ShutdownTaskResponse();

  ShutdownTaskResponse(const ShutdownTaskResponse& from);

  inline ShutdownTaskResponse& operator=(const ShutdownTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShutdownTaskResponse(ShutdownTaskResponse&& from) noexcept
    : ShutdownTaskResponse() {
    *this = ::std::move(from);
  }

  inline ShutdownTaskResponse& operator=(ShutdownTaskResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShutdownTaskResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShutdownTaskResponse* internal_default_instance() {
    return reinterpret_cast<const ShutdownTaskResponse*>(
               &_ShutdownTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(ShutdownTaskResponse* other);
  friend void swap(ShutdownTaskResponse& a, ShutdownTaskResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShutdownTaskResponse* New() const final {
    return CreateMaybeMessage<ShutdownTaskResponse>(NULL);
  }

  ShutdownTaskResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShutdownTaskResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ShutdownTaskResponse& from);
  void MergeFrom(const ShutdownTaskResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShutdownTaskResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ShutdownTaskResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetTaskRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ResetTaskRequest) */ {
 public:
  ResetTaskRequest();
  virtual ~ResetTaskRequest();

  ResetTaskRequest(const ResetTaskRequest& from);

  inline ResetTaskRequest& operator=(const ResetTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetTaskRequest(ResetTaskRequest&& from) noexcept
    : ResetTaskRequest() {
    *this = ::std::move(from);
  }

  inline ResetTaskRequest& operator=(ResetTaskRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetTaskRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetTaskRequest* internal_default_instance() {
    return reinterpret_cast<const ResetTaskRequest*>(
               &_ResetTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(ResetTaskRequest* other);
  friend void swap(ResetTaskRequest& a, ResetTaskRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetTaskRequest* New() const final {
    return CreateMaybeMessage<ResetTaskRequest>(NULL);
  }

  ResetTaskRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResetTaskRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResetTaskRequest& from);
  void MergeFrom(const ResetTaskRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetTaskRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.CoordinatedTask source_task = 1;
  bool has_source_task() const;
  void clear_source_task();
  static const int kSourceTaskFieldNumber = 1;
  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  public:
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // @@protoc_insertion_point(class_scope:tensorflow.ResetTaskRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::CoordinatedTask* source_task_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ResetTaskResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ResetTaskResponse) */ {
 public:
  ResetTaskResponse();
  virtual ~ResetTaskResponse();

  ResetTaskResponse(const ResetTaskResponse& from);

  inline ResetTaskResponse& operator=(const ResetTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ResetTaskResponse(ResetTaskResponse&& from) noexcept
    : ResetTaskResponse() {
    *this = ::std::move(from);
  }

  inline ResetTaskResponse& operator=(ResetTaskResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResetTaskResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ResetTaskResponse* internal_default_instance() {
    return reinterpret_cast<const ResetTaskResponse*>(
               &_ResetTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(ResetTaskResponse* other);
  friend void swap(ResetTaskResponse& a, ResetTaskResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ResetTaskResponse* New() const final {
    return CreateMaybeMessage<ResetTaskResponse>(NULL);
  }

  ResetTaskResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ResetTaskResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ResetTaskResponse& from);
  void MergeFrom(const ResetTaskResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetTaskResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ResetTaskResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportErrorToTaskRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToTaskRequest) */ {
 public:
  ReportErrorToTaskRequest();
  virtual ~ReportErrorToTaskRequest();

  ReportErrorToTaskRequest(const ReportErrorToTaskRequest& from);

  inline ReportErrorToTaskRequest& operator=(const ReportErrorToTaskRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportErrorToTaskRequest(ReportErrorToTaskRequest&& from) noexcept
    : ReportErrorToTaskRequest() {
    *this = ::std::move(from);
  }

  inline ReportErrorToTaskRequest& operator=(ReportErrorToTaskRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportErrorToTaskRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportErrorToTaskRequest* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToTaskRequest*>(
               &_ReportErrorToTaskRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(ReportErrorToTaskRequest* other);
  friend void swap(ReportErrorToTaskRequest& a, ReportErrorToTaskRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportErrorToTaskRequest* New() const final {
    return CreateMaybeMessage<ReportErrorToTaskRequest>(NULL);
  }

  ReportErrorToTaskRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReportErrorToTaskRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReportErrorToTaskRequest& from);
  void MergeFrom(const ReportErrorToTaskRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportErrorToTaskRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_message = 2;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // .tensorflow.CoordinationServiceError error_payload = 5;
  bool has_error_payload() const;
  void clear_error_payload();
  static const int kErrorPayloadFieldNumber = 5;
  private:
  const ::tensorflow::CoordinationServiceError& _internal_error_payload() const;
  public:
  const ::tensorflow::CoordinationServiceError& error_payload() const;
  ::tensorflow::CoordinationServiceError* release_error_payload();
  ::tensorflow::CoordinationServiceError* mutable_error_payload();
  void set_allocated_error_payload(::tensorflow::CoordinationServiceError* error_payload);

  // int32 error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToTaskRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  ::tensorflow::CoordinationServiceError* error_payload_;
  ::google::protobuf::int32 error_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportErrorToTaskResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToTaskResponse) */ {
 public:
  ReportErrorToTaskResponse();
  virtual ~ReportErrorToTaskResponse();

  ReportErrorToTaskResponse(const ReportErrorToTaskResponse& from);

  inline ReportErrorToTaskResponse& operator=(const ReportErrorToTaskResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportErrorToTaskResponse(ReportErrorToTaskResponse&& from) noexcept
    : ReportErrorToTaskResponse() {
    *this = ::std::move(from);
  }

  inline ReportErrorToTaskResponse& operator=(ReportErrorToTaskResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportErrorToTaskResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportErrorToTaskResponse* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToTaskResponse*>(
               &_ReportErrorToTaskResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(ReportErrorToTaskResponse* other);
  friend void swap(ReportErrorToTaskResponse& a, ReportErrorToTaskResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportErrorToTaskResponse* New() const final {
    return CreateMaybeMessage<ReportErrorToTaskResponse>(NULL);
  }

  ReportErrorToTaskResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReportErrorToTaskResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReportErrorToTaskResponse& from);
  void MergeFrom(const ReportErrorToTaskResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportErrorToTaskResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToTaskResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportErrorToServiceRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToServiceRequest) */ {
 public:
  ReportErrorToServiceRequest();
  virtual ~ReportErrorToServiceRequest();

  ReportErrorToServiceRequest(const ReportErrorToServiceRequest& from);

  inline ReportErrorToServiceRequest& operator=(const ReportErrorToServiceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportErrorToServiceRequest(ReportErrorToServiceRequest&& from) noexcept
    : ReportErrorToServiceRequest() {
    *this = ::std::move(from);
  }

  inline ReportErrorToServiceRequest& operator=(ReportErrorToServiceRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportErrorToServiceRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportErrorToServiceRequest* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToServiceRequest*>(
               &_ReportErrorToServiceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ReportErrorToServiceRequest* other);
  friend void swap(ReportErrorToServiceRequest& a, ReportErrorToServiceRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportErrorToServiceRequest* New() const final {
    return CreateMaybeMessage<ReportErrorToServiceRequest>(NULL);
  }

  ReportErrorToServiceRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReportErrorToServiceRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReportErrorToServiceRequest& from);
  void MergeFrom(const ReportErrorToServiceRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportErrorToServiceRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string error_message = 2;
  void clear_error_message();
  static const int kErrorMessageFieldNumber = 2;
  const ::std::string& error_message() const;
  void set_error_message(const ::std::string& value);
  #if LANG_CXX11
  void set_error_message(::std::string&& value);
  #endif
  void set_error_message(const char* value);
  void set_error_message(const char* value, size_t size);
  ::std::string* mutable_error_message();
  ::std::string* release_error_message();
  void set_allocated_error_message(::std::string* error_message);

  // .tensorflow.CoordinatedTask error_origin = 5;
  bool has_error_origin() const;
  void clear_error_origin();
  static const int kErrorOriginFieldNumber = 5;
  private:
  const ::tensorflow::CoordinatedTask& _internal_error_origin() const;
  public:
  const ::tensorflow::CoordinatedTask& error_origin() const;
  ::tensorflow::CoordinatedTask* release_error_origin();
  ::tensorflow::CoordinatedTask* mutable_error_origin();
  void set_allocated_error_origin(::tensorflow::CoordinatedTask* error_origin);

  // int32 error_code = 1;
  void clear_error_code();
  static const int kErrorCodeFieldNumber = 1;
  ::google::protobuf::int32 error_code() const;
  void set_error_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToServiceRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr error_message_;
  ::tensorflow::CoordinatedTask* error_origin_;
  ::google::protobuf::int32 error_code_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportErrorToServiceResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.ReportErrorToServiceResponse) */ {
 public:
  ReportErrorToServiceResponse();
  virtual ~ReportErrorToServiceResponse();

  ReportErrorToServiceResponse(const ReportErrorToServiceResponse& from);

  inline ReportErrorToServiceResponse& operator=(const ReportErrorToServiceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportErrorToServiceResponse(ReportErrorToServiceResponse&& from) noexcept
    : ReportErrorToServiceResponse() {
    *this = ::std::move(from);
  }

  inline ReportErrorToServiceResponse& operator=(ReportErrorToServiceResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportErrorToServiceResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportErrorToServiceResponse* internal_default_instance() {
    return reinterpret_cast<const ReportErrorToServiceResponse*>(
               &_ReportErrorToServiceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ReportErrorToServiceResponse* other);
  friend void swap(ReportErrorToServiceResponse& a, ReportErrorToServiceResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportErrorToServiceResponse* New() const final {
    return CreateMaybeMessage<ReportErrorToServiceResponse>(NULL);
  }

  ReportErrorToServiceResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReportErrorToServiceResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReportErrorToServiceResponse& from);
  void MergeFrom(const ReportErrorToServiceResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportErrorToServiceResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.ReportErrorToServiceResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyValueEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.KeyValueEntry) */ {
 public:
  KeyValueEntry();
  virtual ~KeyValueEntry();

  KeyValueEntry(const KeyValueEntry& from);

  inline KeyValueEntry& operator=(const KeyValueEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyValueEntry(KeyValueEntry&& from) noexcept
    : KeyValueEntry() {
    *this = ::std::move(from);
  }

  inline KeyValueEntry& operator=(KeyValueEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValueEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyValueEntry* internal_default_instance() {
    return reinterpret_cast<const KeyValueEntry*>(
               &_KeyValueEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(KeyValueEntry* other);
  friend void swap(KeyValueEntry& a, KeyValueEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyValueEntry* New() const final {
    return CreateMaybeMessage<KeyValueEntry>(NULL);
  }

  KeyValueEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyValueEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyValueEntry& from);
  void MergeFrom(const KeyValueEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyValueEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:tensorflow.KeyValueEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InsertKeyValueRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.InsertKeyValueRequest) */ {
 public:
  InsertKeyValueRequest();
  virtual ~InsertKeyValueRequest();

  InsertKeyValueRequest(const InsertKeyValueRequest& from);

  inline InsertKeyValueRequest& operator=(const InsertKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InsertKeyValueRequest(InsertKeyValueRequest&& from) noexcept
    : InsertKeyValueRequest() {
    *this = ::std::move(from);
  }

  inline InsertKeyValueRequest& operator=(InsertKeyValueRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertKeyValueRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InsertKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const InsertKeyValueRequest*>(
               &_InsertKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(InsertKeyValueRequest* other);
  friend void swap(InsertKeyValueRequest& a, InsertKeyValueRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InsertKeyValueRequest* New() const final {
    return CreateMaybeMessage<InsertKeyValueRequest>(NULL);
  }

  InsertKeyValueRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InsertKeyValueRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InsertKeyValueRequest& from);
  void MergeFrom(const InsertKeyValueRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertKeyValueRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.KeyValueEntry kv = 1;
  bool has_kv() const;
  void clear_kv();
  static const int kKvFieldNumber = 1;
  private:
  const ::tensorflow::KeyValueEntry& _internal_kv() const;
  public:
  const ::tensorflow::KeyValueEntry& kv() const;
  ::tensorflow::KeyValueEntry* release_kv();
  ::tensorflow::KeyValueEntry* mutable_kv();
  void set_allocated_kv(::tensorflow::KeyValueEntry* kv);

  // @@protoc_insertion_point(class_scope:tensorflow.InsertKeyValueRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::KeyValueEntry* kv_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InsertKeyValueResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.InsertKeyValueResponse) */ {
 public:
  InsertKeyValueResponse();
  virtual ~InsertKeyValueResponse();

  InsertKeyValueResponse(const InsertKeyValueResponse& from);

  inline InsertKeyValueResponse& operator=(const InsertKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InsertKeyValueResponse(InsertKeyValueResponse&& from) noexcept
    : InsertKeyValueResponse() {
    *this = ::std::move(from);
  }

  inline InsertKeyValueResponse& operator=(InsertKeyValueResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const InsertKeyValueResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InsertKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const InsertKeyValueResponse*>(
               &_InsertKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(InsertKeyValueResponse* other);
  friend void swap(InsertKeyValueResponse& a, InsertKeyValueResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InsertKeyValueResponse* New() const final {
    return CreateMaybeMessage<InsertKeyValueResponse>(NULL);
  }

  InsertKeyValueResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InsertKeyValueResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InsertKeyValueResponse& from);
  void MergeFrom(const InsertKeyValueResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InsertKeyValueResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.InsertKeyValueResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetKeyValueRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.GetKeyValueRequest) */ {
 public:
  GetKeyValueRequest();
  virtual ~GetKeyValueRequest();

  GetKeyValueRequest(const GetKeyValueRequest& from);

  inline GetKeyValueRequest& operator=(const GetKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetKeyValueRequest(GetKeyValueRequest&& from) noexcept
    : GetKeyValueRequest() {
    *this = ::std::move(from);
  }

  inline GetKeyValueRequest& operator=(GetKeyValueRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetKeyValueRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const GetKeyValueRequest*>(
               &_GetKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(GetKeyValueRequest* other);
  friend void swap(GetKeyValueRequest& a, GetKeyValueRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetKeyValueRequest* New() const final {
    return CreateMaybeMessage<GetKeyValueRequest>(NULL);
  }

  GetKeyValueRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetKeyValueRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetKeyValueRequest& from);
  void MergeFrom(const GetKeyValueRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKeyValueRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:tensorflow.GetKeyValueRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetKeyValueResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.GetKeyValueResponse) */ {
 public:
  GetKeyValueResponse();
  virtual ~GetKeyValueResponse();

  GetKeyValueResponse(const GetKeyValueResponse& from);

  inline GetKeyValueResponse& operator=(const GetKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetKeyValueResponse(GetKeyValueResponse&& from) noexcept
    : GetKeyValueResponse() {
    *this = ::std::move(from);
  }

  inline GetKeyValueResponse& operator=(GetKeyValueResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetKeyValueResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const GetKeyValueResponse*>(
               &_GetKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(GetKeyValueResponse* other);
  friend void swap(GetKeyValueResponse& a, GetKeyValueResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetKeyValueResponse* New() const final {
    return CreateMaybeMessage<GetKeyValueResponse>(NULL);
  }

  GetKeyValueResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetKeyValueResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetKeyValueResponse& from);
  void MergeFrom(const GetKeyValueResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetKeyValueResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .tensorflow.KeyValueEntry kv = 1;
  bool has_kv() const;
  void clear_kv();
  static const int kKvFieldNumber = 1;
  private:
  const ::tensorflow::KeyValueEntry& _internal_kv() const;
  public:
  const ::tensorflow::KeyValueEntry& kv() const;
  ::tensorflow::KeyValueEntry* release_kv();
  ::tensorflow::KeyValueEntry* mutable_kv();
  void set_allocated_kv(::tensorflow::KeyValueEntry* kv);

  // @@protoc_insertion_point(class_scope:tensorflow.GetKeyValueResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::tensorflow::KeyValueEntry* kv_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteKeyValueRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.DeleteKeyValueRequest) */ {
 public:
  DeleteKeyValueRequest();
  virtual ~DeleteKeyValueRequest();

  DeleteKeyValueRequest(const DeleteKeyValueRequest& from);

  inline DeleteKeyValueRequest& operator=(const DeleteKeyValueRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteKeyValueRequest(DeleteKeyValueRequest&& from) noexcept
    : DeleteKeyValueRequest() {
    *this = ::std::move(from);
  }

  inline DeleteKeyValueRequest& operator=(DeleteKeyValueRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteKeyValueRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteKeyValueRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyValueRequest*>(
               &_DeleteKeyValueRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(DeleteKeyValueRequest* other);
  friend void swap(DeleteKeyValueRequest& a, DeleteKeyValueRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteKeyValueRequest* New() const final {
    return CreateMaybeMessage<DeleteKeyValueRequest>(NULL);
  }

  DeleteKeyValueRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteKeyValueRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteKeyValueRequest& from);
  void MergeFrom(const DeleteKeyValueRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteKeyValueRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bool is_directory = 2;
  void clear_is_directory();
  static const int kIsDirectoryFieldNumber = 2;
  bool is_directory() const;
  void set_is_directory(bool value);

  // @@protoc_insertion_point(class_scope:tensorflow.DeleteKeyValueRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  bool is_directory_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteKeyValueResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.DeleteKeyValueResponse) */ {
 public:
  DeleteKeyValueResponse();
  virtual ~DeleteKeyValueResponse();

  DeleteKeyValueResponse(const DeleteKeyValueResponse& from);

  inline DeleteKeyValueResponse& operator=(const DeleteKeyValueResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteKeyValueResponse(DeleteKeyValueResponse&& from) noexcept
    : DeleteKeyValueResponse() {
    *this = ::std::move(from);
  }

  inline DeleteKeyValueResponse& operator=(DeleteKeyValueResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteKeyValueResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteKeyValueResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteKeyValueResponse*>(
               &_DeleteKeyValueResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(DeleteKeyValueResponse* other);
  friend void swap(DeleteKeyValueResponse& a, DeleteKeyValueResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteKeyValueResponse* New() const final {
    return CreateMaybeMessage<DeleteKeyValueResponse>(NULL);
  }

  DeleteKeyValueResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteKeyValueResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteKeyValueResponse& from);
  void MergeFrom(const DeleteKeyValueResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteKeyValueResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.DeleteKeyValueResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BarrierRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.BarrierRequest) */ {
 public:
  BarrierRequest();
  virtual ~BarrierRequest();

  BarrierRequest(const BarrierRequest& from);

  inline BarrierRequest& operator=(const BarrierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BarrierRequest(BarrierRequest&& from) noexcept
    : BarrierRequest() {
    *this = ::std::move(from);
  }

  inline BarrierRequest& operator=(BarrierRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BarrierRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BarrierRequest* internal_default_instance() {
    return reinterpret_cast<const BarrierRequest*>(
               &_BarrierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(BarrierRequest* other);
  friend void swap(BarrierRequest& a, BarrierRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BarrierRequest* New() const final {
    return CreateMaybeMessage<BarrierRequest>(NULL);
  }

  BarrierRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BarrierRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BarrierRequest& from);
  void MergeFrom(const BarrierRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BarrierRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.CoordinatedTask tasks = 3;
  int tasks_size() const;
  void clear_tasks();
  static const int kTasksFieldNumber = 3;
  ::tensorflow::CoordinatedTask* mutable_tasks(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTask >*
      mutable_tasks();
  const ::tensorflow::CoordinatedTask& tasks(int index) const;
  ::tensorflow::CoordinatedTask* add_tasks();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTask >&
      tasks() const;

  // string barrier_id = 1;
  void clear_barrier_id();
  static const int kBarrierIdFieldNumber = 1;
  const ::std::string& barrier_id() const;
  void set_barrier_id(const ::std::string& value);
  #if LANG_CXX11
  void set_barrier_id(::std::string&& value);
  #endif
  void set_barrier_id(const char* value);
  void set_barrier_id(const char* value, size_t size);
  ::std::string* mutable_barrier_id();
  ::std::string* release_barrier_id();
  void set_allocated_barrier_id(::std::string* barrier_id);

  // .tensorflow.CoordinatedTask source_task = 4;
  bool has_source_task() const;
  void clear_source_task();
  static const int kSourceTaskFieldNumber = 4;
  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  public:
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // int64 barrier_timeout_in_ms = 2;
  void clear_barrier_timeout_in_ms();
  static const int kBarrierTimeoutInMsFieldNumber = 2;
  ::google::protobuf::int64 barrier_timeout_in_ms() const;
  void set_barrier_timeout_in_ms(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.BarrierRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTask > tasks_;
  ::google::protobuf::internal::ArenaStringPtr barrier_id_;
  ::tensorflow::CoordinatedTask* source_task_;
  ::google::protobuf::int64 barrier_timeout_in_ms_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BarrierResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.BarrierResponse) */ {
 public:
  BarrierResponse();
  virtual ~BarrierResponse();

  BarrierResponse(const BarrierResponse& from);

  inline BarrierResponse& operator=(const BarrierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BarrierResponse(BarrierResponse&& from) noexcept
    : BarrierResponse() {
    *this = ::std::move(from);
  }

  inline BarrierResponse& operator=(BarrierResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const BarrierResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BarrierResponse* internal_default_instance() {
    return reinterpret_cast<const BarrierResponse*>(
               &_BarrierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(BarrierResponse* other);
  friend void swap(BarrierResponse& a, BarrierResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BarrierResponse* New() const final {
    return CreateMaybeMessage<BarrierResponse>(NULL);
  }

  BarrierResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BarrierResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BarrierResponse& from);
  void MergeFrom(const BarrierResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BarrierResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.BarrierResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CancelBarrierRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CancelBarrierRequest) */ {
 public:
  CancelBarrierRequest();
  virtual ~CancelBarrierRequest();

  CancelBarrierRequest(const CancelBarrierRequest& from);

  inline CancelBarrierRequest& operator=(const CancelBarrierRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CancelBarrierRequest(CancelBarrierRequest&& from) noexcept
    : CancelBarrierRequest() {
    *this = ::std::move(from);
  }

  inline CancelBarrierRequest& operator=(CancelBarrierRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelBarrierRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelBarrierRequest* internal_default_instance() {
    return reinterpret_cast<const CancelBarrierRequest*>(
               &_CancelBarrierRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(CancelBarrierRequest* other);
  friend void swap(CancelBarrierRequest& a, CancelBarrierRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CancelBarrierRequest* New() const final {
    return CreateMaybeMessage<CancelBarrierRequest>(NULL);
  }

  CancelBarrierRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CancelBarrierRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CancelBarrierRequest& from);
  void MergeFrom(const CancelBarrierRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelBarrierRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string barrier_id = 1;
  void clear_barrier_id();
  static const int kBarrierIdFieldNumber = 1;
  const ::std::string& barrier_id() const;
  void set_barrier_id(const ::std::string& value);
  #if LANG_CXX11
  void set_barrier_id(::std::string&& value);
  #endif
  void set_barrier_id(const char* value);
  void set_barrier_id(const char* value, size_t size);
  ::std::string* mutable_barrier_id();
  ::std::string* release_barrier_id();
  void set_allocated_barrier_id(::std::string* barrier_id);

  // .tensorflow.CoordinatedTask source_task = 2;
  bool has_source_task() const;
  void clear_source_task();
  static const int kSourceTaskFieldNumber = 2;
  private:
  const ::tensorflow::CoordinatedTask& _internal_source_task() const;
  public:
  const ::tensorflow::CoordinatedTask& source_task() const;
  ::tensorflow::CoordinatedTask* release_source_task();
  ::tensorflow::CoordinatedTask* mutable_source_task();
  void set_allocated_source_task(::tensorflow::CoordinatedTask* source_task);

  // @@protoc_insertion_point(class_scope:tensorflow.CancelBarrierRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr barrier_id_;
  ::tensorflow::CoordinatedTask* source_task_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CancelBarrierResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.CancelBarrierResponse) */ {
 public:
  CancelBarrierResponse();
  virtual ~CancelBarrierResponse();

  CancelBarrierResponse(const CancelBarrierResponse& from);

  inline CancelBarrierResponse& operator=(const CancelBarrierResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CancelBarrierResponse(CancelBarrierResponse&& from) noexcept
    : CancelBarrierResponse() {
    *this = ::std::move(from);
  }

  inline CancelBarrierResponse& operator=(CancelBarrierResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CancelBarrierResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CancelBarrierResponse* internal_default_instance() {
    return reinterpret_cast<const CancelBarrierResponse*>(
               &_CancelBarrierResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(CancelBarrierResponse* other);
  friend void swap(CancelBarrierResponse& a, CancelBarrierResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CancelBarrierResponse* New() const final {
    return CreateMaybeMessage<CancelBarrierResponse>(NULL);
  }

  CancelBarrierResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CancelBarrierResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CancelBarrierResponse& from);
  void MergeFrom(const CancelBarrierResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CancelBarrierResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:tensorflow.CancelBarrierResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CoordinatedTask

// string job_name = 1;
inline void CoordinatedTask::clear_job_name() {
  job_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CoordinatedTask::job_name() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTask.job_name)
  return job_name_.GetNoArena();
}
inline void CoordinatedTask::set_job_name(const ::std::string& value) {
  
  job_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTask.job_name)
}
#if LANG_CXX11
inline void CoordinatedTask::set_job_name(::std::string&& value) {
  
  job_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.CoordinatedTask.job_name)
}
#endif
inline void CoordinatedTask::set_job_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  job_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CoordinatedTask.job_name)
}
inline void CoordinatedTask::set_job_name(const char* value, size_t size) {
  
  job_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CoordinatedTask.job_name)
}
inline ::std::string* CoordinatedTask::mutable_job_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinatedTask.job_name)
  return job_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CoordinatedTask::release_job_name() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinatedTask.job_name)
  
  return job_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CoordinatedTask::set_allocated_job_name(::std::string* job_name) {
  if (job_name != NULL) {
    
  } else {
    
  }
  job_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), job_name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinatedTask.job_name)
}

// int32 task_id = 2;
inline void CoordinatedTask::clear_task_id() {
  task_id_ = 0;
}
inline ::google::protobuf::int32 CoordinatedTask::task_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinatedTask.task_id)
  return task_id_;
}
inline void CoordinatedTask::set_task_id(::google::protobuf::int32 value) {
  
  task_id_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CoordinatedTask.task_id)
}

// -------------------------------------------------------------------

// CoordinationServiceError

// bool is_reported_error = 3;
inline void CoordinationServiceError::clear_is_reported_error() {
  is_reported_error_ = false;
}
inline bool CoordinationServiceError::is_reported_error() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinationServiceError.is_reported_error)
  return is_reported_error_;
}
inline void CoordinationServiceError::set_is_reported_error(bool value) {
  
  is_reported_error_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.CoordinationServiceError.is_reported_error)
}

// .tensorflow.CoordinatedTask source_task = 4;
inline bool CoordinationServiceError::has_source_task() const {
  return this != internal_default_instance() && source_task_ != NULL;
}
inline void CoordinationServiceError::clear_source_task() {
  if (GetArenaNoVirtual() == NULL && source_task_ != NULL) {
    delete source_task_;
  }
  source_task_ = NULL;
}
inline const ::tensorflow::CoordinatedTask& CoordinationServiceError::_internal_source_task() const {
  return *source_task_;
}
inline const ::tensorflow::CoordinatedTask& CoordinationServiceError::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.CoordinationServiceError.source_task)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* CoordinationServiceError::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinationServiceError.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinatedTask* CoordinationServiceError::mutable_source_task() {
  
  if (source_task_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinationServiceError.source_task)
  return source_task_;
}
inline void CoordinationServiceError::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_task_;
  }
  if (source_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CoordinationServiceError.source_task)
}

// -------------------------------------------------------------------

// TfDeviceList

// repeated .tensorflow.DeviceAttributes devices = 1;
inline int TfDeviceList::devices_size() const {
  return devices_.size();
}
inline ::tensorflow::DeviceAttributes* TfDeviceList::mutable_devices(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.TfDeviceList.devices)
  return devices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >*
TfDeviceList::mutable_devices() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.TfDeviceList.devices)
  return &devices_;
}
inline const ::tensorflow::DeviceAttributes& TfDeviceList::devices(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.TfDeviceList.devices)
  return devices_.Get(index);
}
inline ::tensorflow::DeviceAttributes* TfDeviceList::add_devices() {
  // @@protoc_insertion_point(field_add:tensorflow.TfDeviceList.devices)
  return devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::DeviceAttributes >&
TfDeviceList::devices() const {
  // @@protoc_insertion_point(field_list:tensorflow.TfDeviceList.devices)
  return devices_;
}

// -------------------------------------------------------------------

// XlaDeviceList

// .xla.GlobalTopologyProto devices = 1;
inline bool XlaDeviceList::has_devices() const {
  return this != internal_default_instance() && devices_ != NULL;
}
inline const ::xla::GlobalTopologyProto& XlaDeviceList::_internal_devices() const {
  return *devices_;
}
inline const ::xla::GlobalTopologyProto& XlaDeviceList::devices() const {
  const ::xla::GlobalTopologyProto* p = devices_;
  // @@protoc_insertion_point(field_get:tensorflow.XlaDeviceList.devices)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::GlobalTopologyProto*>(
      &::xla::_GlobalTopologyProto_default_instance_);
}
inline ::xla::GlobalTopologyProto* XlaDeviceList::release_devices() {
  // @@protoc_insertion_point(field_release:tensorflow.XlaDeviceList.devices)
  
  ::xla::GlobalTopologyProto* temp = devices_;
  devices_ = NULL;
  return temp;
}
inline ::xla::GlobalTopologyProto* XlaDeviceList::mutable_devices() {
  
  if (devices_ == NULL) {
    auto* p = CreateMaybeMessage<::xla::GlobalTopologyProto>(GetArenaNoVirtual());
    devices_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.XlaDeviceList.devices)
  return devices_;
}
inline void XlaDeviceList::set_allocated_devices(::xla::GlobalTopologyProto* devices) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(devices_);
  }
  if (devices) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      devices = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, devices, submessage_arena);
    }
    
  } else {
    
  }
  devices_ = devices;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.XlaDeviceList.devices)
}

// -------------------------------------------------------------------

// CoordinationServiceDeviceInfo

// .tensorflow.TfDeviceList tf = 1;
inline bool CoordinationServiceDeviceInfo::has_tf() const {
  return type_case() == kTf;
}
inline void CoordinationServiceDeviceInfo::set_has_tf() {
  _oneof_case_[0] = kTf;
}
inline void CoordinationServiceDeviceInfo::clear_tf() {
  if (has_tf()) {
    delete type_.tf_;
    clear_has_type();
  }
}
inline const ::tensorflow::TfDeviceList& CoordinationServiceDeviceInfo::_internal_tf() const {
  return *type_.tf_;
}
inline ::tensorflow::TfDeviceList* CoordinationServiceDeviceInfo::release_tf() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinationServiceDeviceInfo.tf)
  if (has_tf()) {
    clear_has_type();
      ::tensorflow::TfDeviceList* temp = type_.tf_;
    type_.tf_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::TfDeviceList& CoordinationServiceDeviceInfo::tf() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinationServiceDeviceInfo.tf)
  return has_tf()
      ? *type_.tf_
      : *reinterpret_cast< ::tensorflow::TfDeviceList*>(&::tensorflow::_TfDeviceList_default_instance_);
}
inline ::tensorflow::TfDeviceList* CoordinationServiceDeviceInfo::mutable_tf() {
  if (!has_tf()) {
    clear_type();
    set_has_tf();
    type_.tf_ = CreateMaybeMessage< ::tensorflow::TfDeviceList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinationServiceDeviceInfo.tf)
  return type_.tf_;
}

// .tensorflow.XlaDeviceList xla = 2;
inline bool CoordinationServiceDeviceInfo::has_xla() const {
  return type_case() == kXla;
}
inline void CoordinationServiceDeviceInfo::set_has_xla() {
  _oneof_case_[0] = kXla;
}
inline void CoordinationServiceDeviceInfo::clear_xla() {
  if (has_xla()) {
    delete type_.xla_;
    clear_has_type();
  }
}
inline const ::tensorflow::XlaDeviceList& CoordinationServiceDeviceInfo::_internal_xla() const {
  return *type_.xla_;
}
inline ::tensorflow::XlaDeviceList* CoordinationServiceDeviceInfo::release_xla() {
  // @@protoc_insertion_point(field_release:tensorflow.CoordinationServiceDeviceInfo.xla)
  if (has_xla()) {
    clear_has_type();
      ::tensorflow::XlaDeviceList* temp = type_.xla_;
    type_.xla_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline const ::tensorflow::XlaDeviceList& CoordinationServiceDeviceInfo::xla() const {
  // @@protoc_insertion_point(field_get:tensorflow.CoordinationServiceDeviceInfo.xla)
  return has_xla()
      ? *type_.xla_
      : *reinterpret_cast< ::tensorflow::XlaDeviceList*>(&::tensorflow::_XlaDeviceList_default_instance_);
}
inline ::tensorflow::XlaDeviceList* CoordinationServiceDeviceInfo::mutable_xla() {
  if (!has_xla()) {
    clear_type();
    set_has_xla();
    type_.xla_ = CreateMaybeMessage< ::tensorflow::XlaDeviceList >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CoordinationServiceDeviceInfo.xla)
  return type_.xla_;
}

inline bool CoordinationServiceDeviceInfo::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void CoordinationServiceDeviceInfo::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline CoordinationServiceDeviceInfo::TypeCase CoordinationServiceDeviceInfo::type_case() const {
  return CoordinationServiceDeviceInfo::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegisterTaskRequest

// fixed64 incarnation = 3;
inline void RegisterTaskRequest::clear_incarnation() {
  incarnation_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegisterTaskRequest::incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterTaskRequest.incarnation)
  return incarnation_;
}
inline void RegisterTaskRequest::set_incarnation(::google::protobuf::uint64 value) {
  
  incarnation_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RegisterTaskRequest.incarnation)
}

// .tensorflow.CoordinatedTask source_task = 5;
inline bool RegisterTaskRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != NULL;
}
inline void RegisterTaskRequest::clear_source_task() {
  if (GetArenaNoVirtual() == NULL && source_task_ != NULL) {
    delete source_task_;
  }
  source_task_ = NULL;
}
inline const ::tensorflow::CoordinatedTask& RegisterTaskRequest::_internal_source_task() const {
  return *source_task_;
}
inline const ::tensorflow::CoordinatedTask& RegisterTaskRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.RegisterTaskRequest.source_task)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* RegisterTaskRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.RegisterTaskRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinatedTask* RegisterTaskRequest::mutable_source_task() {
  
  if (source_task_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.RegisterTaskRequest.source_task)
  return source_task_;
}
inline void RegisterTaskRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_task_;
  }
  if (source_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.RegisterTaskRequest.source_task)
}

// -------------------------------------------------------------------

// RegisterTaskResponse

// fixed64 leader_incarnation = 1;
inline void RegisterTaskResponse::clear_leader_incarnation() {
  leader_incarnation_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 RegisterTaskResponse::leader_incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.RegisterTaskResponse.leader_incarnation)
  return leader_incarnation_;
}
inline void RegisterTaskResponse::set_leader_incarnation(::google::protobuf::uint64 value) {
  
  leader_incarnation_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.RegisterTaskResponse.leader_incarnation)
}

// -------------------------------------------------------------------

// HeartbeatRequest

// fixed64 incarnation = 3;
inline void HeartbeatRequest::clear_incarnation() {
  incarnation_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HeartbeatRequest::incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.HeartbeatRequest.incarnation)
  return incarnation_;
}
inline void HeartbeatRequest::set_incarnation(::google::protobuf::uint64 value) {
  
  incarnation_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HeartbeatRequest.incarnation)
}

// .tensorflow.CoordinatedTask source_task = 4;
inline bool HeartbeatRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != NULL;
}
inline void HeartbeatRequest::clear_source_task() {
  if (GetArenaNoVirtual() == NULL && source_task_ != NULL) {
    delete source_task_;
  }
  source_task_ = NULL;
}
inline const ::tensorflow::CoordinatedTask& HeartbeatRequest::_internal_source_task() const {
  return *source_task_;
}
inline const ::tensorflow::CoordinatedTask& HeartbeatRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.HeartbeatRequest.source_task)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* HeartbeatRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.HeartbeatRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinatedTask* HeartbeatRequest::mutable_source_task() {
  
  if (source_task_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.HeartbeatRequest.source_task)
  return source_task_;
}
inline void HeartbeatRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_task_;
  }
  if (source_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.HeartbeatRequest.source_task)
}

// -------------------------------------------------------------------

// HeartbeatResponse

// fixed64 leader_incarnation = 1;
inline void HeartbeatResponse::clear_leader_incarnation() {
  leader_incarnation_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 HeartbeatResponse::leader_incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.HeartbeatResponse.leader_incarnation)
  return leader_incarnation_;
}
inline void HeartbeatResponse::set_leader_incarnation(::google::protobuf::uint64 value) {
  
  leader_incarnation_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.HeartbeatResponse.leader_incarnation)
}

// -------------------------------------------------------------------

// WaitForAllTasksRequest

// .tensorflow.CoordinationServiceDeviceInfo local_device_info = 4;
inline bool WaitForAllTasksRequest::has_local_device_info() const {
  return this != internal_default_instance() && local_device_info_ != NULL;
}
inline void WaitForAllTasksRequest::clear_local_device_info() {
  if (GetArenaNoVirtual() == NULL && local_device_info_ != NULL) {
    delete local_device_info_;
  }
  local_device_info_ = NULL;
}
inline const ::tensorflow::CoordinationServiceDeviceInfo& WaitForAllTasksRequest::_internal_local_device_info() const {
  return *local_device_info_;
}
inline const ::tensorflow::CoordinationServiceDeviceInfo& WaitForAllTasksRequest::local_device_info() const {
  const ::tensorflow::CoordinationServiceDeviceInfo* p = local_device_info_;
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksRequest.local_device_info)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinationServiceDeviceInfo*>(
      &::tensorflow::_CoordinationServiceDeviceInfo_default_instance_);
}
inline ::tensorflow::CoordinationServiceDeviceInfo* WaitForAllTasksRequest::release_local_device_info() {
  // @@protoc_insertion_point(field_release:tensorflow.WaitForAllTasksRequest.local_device_info)
  
  ::tensorflow::CoordinationServiceDeviceInfo* temp = local_device_info_;
  local_device_info_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinationServiceDeviceInfo* WaitForAllTasksRequest::mutable_local_device_info() {
  
  if (local_device_info_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinationServiceDeviceInfo>(GetArenaNoVirtual());
    local_device_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.WaitForAllTasksRequest.local_device_info)
  return local_device_info_;
}
inline void WaitForAllTasksRequest::set_allocated_local_device_info(::tensorflow::CoordinationServiceDeviceInfo* local_device_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete local_device_info_;
  }
  if (local_device_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      local_device_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, local_device_info, submessage_arena);
    }
    
  } else {
    
  }
  local_device_info_ = local_device_info;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.WaitForAllTasksRequest.local_device_info)
}

// .tensorflow.CoordinatedTask source_task = 5;
inline bool WaitForAllTasksRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != NULL;
}
inline void WaitForAllTasksRequest::clear_source_task() {
  if (GetArenaNoVirtual() == NULL && source_task_ != NULL) {
    delete source_task_;
  }
  source_task_ = NULL;
}
inline const ::tensorflow::CoordinatedTask& WaitForAllTasksRequest::_internal_source_task() const {
  return *source_task_;
}
inline const ::tensorflow::CoordinatedTask& WaitForAllTasksRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksRequest.source_task)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* WaitForAllTasksRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.WaitForAllTasksRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinatedTask* WaitForAllTasksRequest::mutable_source_task() {
  
  if (source_task_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.WaitForAllTasksRequest.source_task)
  return source_task_;
}
inline void WaitForAllTasksRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_task_;
  }
  if (source_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.WaitForAllTasksRequest.source_task)
}

// -------------------------------------------------------------------

// WaitForAllTasksResponse

// fixed64 leader_incarnation = 1;
inline void WaitForAllTasksResponse::clear_leader_incarnation() {
  leader_incarnation_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 WaitForAllTasksResponse::leader_incarnation() const {
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksResponse.leader_incarnation)
  return leader_incarnation_;
}
inline void WaitForAllTasksResponse::set_leader_incarnation(::google::protobuf::uint64 value) {
  
  leader_incarnation_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.WaitForAllTasksResponse.leader_incarnation)
}

// .tensorflow.CoordinationServiceDeviceInfo cluster_device_info = 3;
inline bool WaitForAllTasksResponse::has_cluster_device_info() const {
  return this != internal_default_instance() && cluster_device_info_ != NULL;
}
inline void WaitForAllTasksResponse::clear_cluster_device_info() {
  if (GetArenaNoVirtual() == NULL && cluster_device_info_ != NULL) {
    delete cluster_device_info_;
  }
  cluster_device_info_ = NULL;
}
inline const ::tensorflow::CoordinationServiceDeviceInfo& WaitForAllTasksResponse::_internal_cluster_device_info() const {
  return *cluster_device_info_;
}
inline const ::tensorflow::CoordinationServiceDeviceInfo& WaitForAllTasksResponse::cluster_device_info() const {
  const ::tensorflow::CoordinationServiceDeviceInfo* p = cluster_device_info_;
  // @@protoc_insertion_point(field_get:tensorflow.WaitForAllTasksResponse.cluster_device_info)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinationServiceDeviceInfo*>(
      &::tensorflow::_CoordinationServiceDeviceInfo_default_instance_);
}
inline ::tensorflow::CoordinationServiceDeviceInfo* WaitForAllTasksResponse::release_cluster_device_info() {
  // @@protoc_insertion_point(field_release:tensorflow.WaitForAllTasksResponse.cluster_device_info)
  
  ::tensorflow::CoordinationServiceDeviceInfo* temp = cluster_device_info_;
  cluster_device_info_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinationServiceDeviceInfo* WaitForAllTasksResponse::mutable_cluster_device_info() {
  
  if (cluster_device_info_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinationServiceDeviceInfo>(GetArenaNoVirtual());
    cluster_device_info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.WaitForAllTasksResponse.cluster_device_info)
  return cluster_device_info_;
}
inline void WaitForAllTasksResponse::set_allocated_cluster_device_info(::tensorflow::CoordinationServiceDeviceInfo* cluster_device_info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete cluster_device_info_;
  }
  if (cluster_device_info) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      cluster_device_info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cluster_device_info, submessage_arena);
    }
    
  } else {
    
  }
  cluster_device_info_ = cluster_device_info;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.WaitForAllTasksResponse.cluster_device_info)
}

// -------------------------------------------------------------------

// ShutdownTaskRequest

// .tensorflow.CoordinatedTask source_task = 1;
inline bool ShutdownTaskRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != NULL;
}
inline void ShutdownTaskRequest::clear_source_task() {
  if (GetArenaNoVirtual() == NULL && source_task_ != NULL) {
    delete source_task_;
  }
  source_task_ = NULL;
}
inline const ::tensorflow::CoordinatedTask& ShutdownTaskRequest::_internal_source_task() const {
  return *source_task_;
}
inline const ::tensorflow::CoordinatedTask& ShutdownTaskRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.ShutdownTaskRequest.source_task)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* ShutdownTaskRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.ShutdownTaskRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinatedTask* ShutdownTaskRequest::mutable_source_task() {
  
  if (source_task_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.ShutdownTaskRequest.source_task)
  return source_task_;
}
inline void ShutdownTaskRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_task_;
  }
  if (source_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ShutdownTaskRequest.source_task)
}

// -------------------------------------------------------------------

// ShutdownTaskResponse

// -------------------------------------------------------------------

// ResetTaskRequest

// .tensorflow.CoordinatedTask source_task = 1;
inline bool ResetTaskRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != NULL;
}
inline void ResetTaskRequest::clear_source_task() {
  if (GetArenaNoVirtual() == NULL && source_task_ != NULL) {
    delete source_task_;
  }
  source_task_ = NULL;
}
inline const ::tensorflow::CoordinatedTask& ResetTaskRequest::_internal_source_task() const {
  return *source_task_;
}
inline const ::tensorflow::CoordinatedTask& ResetTaskRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.ResetTaskRequest.source_task)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* ResetTaskRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.ResetTaskRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinatedTask* ResetTaskRequest::mutable_source_task() {
  
  if (source_task_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.ResetTaskRequest.source_task)
  return source_task_;
}
inline void ResetTaskRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_task_;
  }
  if (source_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ResetTaskRequest.source_task)
}

// -------------------------------------------------------------------

// ResetTaskResponse

// -------------------------------------------------------------------

// ReportErrorToTaskRequest

// int32 error_code = 1;
inline void ReportErrorToTaskRequest::clear_error_code() {
  error_code_ = 0;
}
inline ::google::protobuf::int32 ReportErrorToTaskRequest::error_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToTaskRequest.error_code)
  return error_code_;
}
inline void ReportErrorToTaskRequest::set_error_code(::google::protobuf::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToTaskRequest.error_code)
}

// string error_message = 2;
inline void ReportErrorToTaskRequest::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReportErrorToTaskRequest::error_message() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToTaskRequest.error_message)
  return error_message_.GetNoArena();
}
inline void ReportErrorToTaskRequest::set_error_message(const ::std::string& value) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToTaskRequest.error_message)
}
#if LANG_CXX11
inline void ReportErrorToTaskRequest::set_error_message(::std::string&& value) {
  
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.ReportErrorToTaskRequest.error_message)
}
#endif
inline void ReportErrorToTaskRequest::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.ReportErrorToTaskRequest.error_message)
}
inline void ReportErrorToTaskRequest::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.ReportErrorToTaskRequest.error_message)
}
inline ::std::string* ReportErrorToTaskRequest::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToTaskRequest.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReportErrorToTaskRequest::release_error_message() {
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToTaskRequest.error_message)
  
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReportErrorToTaskRequest::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToTaskRequest.error_message)
}

// .tensorflow.CoordinationServiceError error_payload = 5;
inline bool ReportErrorToTaskRequest::has_error_payload() const {
  return this != internal_default_instance() && error_payload_ != NULL;
}
inline void ReportErrorToTaskRequest::clear_error_payload() {
  if (GetArenaNoVirtual() == NULL && error_payload_ != NULL) {
    delete error_payload_;
  }
  error_payload_ = NULL;
}
inline const ::tensorflow::CoordinationServiceError& ReportErrorToTaskRequest::_internal_error_payload() const {
  return *error_payload_;
}
inline const ::tensorflow::CoordinationServiceError& ReportErrorToTaskRequest::error_payload() const {
  const ::tensorflow::CoordinationServiceError* p = error_payload_;
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToTaskRequest.error_payload)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinationServiceError*>(
      &::tensorflow::_CoordinationServiceError_default_instance_);
}
inline ::tensorflow::CoordinationServiceError* ReportErrorToTaskRequest::release_error_payload() {
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToTaskRequest.error_payload)
  
  ::tensorflow::CoordinationServiceError* temp = error_payload_;
  error_payload_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinationServiceError* ReportErrorToTaskRequest::mutable_error_payload() {
  
  if (error_payload_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinationServiceError>(GetArenaNoVirtual());
    error_payload_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToTaskRequest.error_payload)
  return error_payload_;
}
inline void ReportErrorToTaskRequest::set_allocated_error_payload(::tensorflow::CoordinationServiceError* error_payload) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_payload_;
  }
  if (error_payload) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error_payload = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error_payload, submessage_arena);
    }
    
  } else {
    
  }
  error_payload_ = error_payload;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToTaskRequest.error_payload)
}

// -------------------------------------------------------------------

// ReportErrorToTaskResponse

// -------------------------------------------------------------------

// ReportErrorToServiceRequest

// int32 error_code = 1;
inline void ReportErrorToServiceRequest::clear_error_code() {
  error_code_ = 0;
}
inline ::google::protobuf::int32 ReportErrorToServiceRequest::error_code() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToServiceRequest.error_code)
  return error_code_;
}
inline void ReportErrorToServiceRequest::set_error_code(::google::protobuf::int32 value) {
  
  error_code_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToServiceRequest.error_code)
}

// string error_message = 2;
inline void ReportErrorToServiceRequest::clear_error_message() {
  error_message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReportErrorToServiceRequest::error_message() const {
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToServiceRequest.error_message)
  return error_message_.GetNoArena();
}
inline void ReportErrorToServiceRequest::set_error_message(const ::std::string& value) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.ReportErrorToServiceRequest.error_message)
}
#if LANG_CXX11
inline void ReportErrorToServiceRequest::set_error_message(::std::string&& value) {
  
  error_message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.ReportErrorToServiceRequest.error_message)
}
#endif
inline void ReportErrorToServiceRequest::set_error_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.ReportErrorToServiceRequest.error_message)
}
inline void ReportErrorToServiceRequest::set_error_message(const char* value, size_t size) {
  
  error_message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.ReportErrorToServiceRequest.error_message)
}
inline ::std::string* ReportErrorToServiceRequest::mutable_error_message() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToServiceRequest.error_message)
  return error_message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReportErrorToServiceRequest::release_error_message() {
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToServiceRequest.error_message)
  
  return error_message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReportErrorToServiceRequest::set_allocated_error_message(::std::string* error_message) {
  if (error_message != NULL) {
    
  } else {
    
  }
  error_message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), error_message);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToServiceRequest.error_message)
}

// .tensorflow.CoordinatedTask error_origin = 5;
inline bool ReportErrorToServiceRequest::has_error_origin() const {
  return this != internal_default_instance() && error_origin_ != NULL;
}
inline void ReportErrorToServiceRequest::clear_error_origin() {
  if (GetArenaNoVirtual() == NULL && error_origin_ != NULL) {
    delete error_origin_;
  }
  error_origin_ = NULL;
}
inline const ::tensorflow::CoordinatedTask& ReportErrorToServiceRequest::_internal_error_origin() const {
  return *error_origin_;
}
inline const ::tensorflow::CoordinatedTask& ReportErrorToServiceRequest::error_origin() const {
  const ::tensorflow::CoordinatedTask* p = error_origin_;
  // @@protoc_insertion_point(field_get:tensorflow.ReportErrorToServiceRequest.error_origin)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* ReportErrorToServiceRequest::release_error_origin() {
  // @@protoc_insertion_point(field_release:tensorflow.ReportErrorToServiceRequest.error_origin)
  
  ::tensorflow::CoordinatedTask* temp = error_origin_;
  error_origin_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinatedTask* ReportErrorToServiceRequest::mutable_error_origin() {
  
  if (error_origin_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    error_origin_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.ReportErrorToServiceRequest.error_origin)
  return error_origin_;
}
inline void ReportErrorToServiceRequest::set_allocated_error_origin(::tensorflow::CoordinatedTask* error_origin) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete error_origin_;
  }
  if (error_origin) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      error_origin = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, error_origin, submessage_arena);
    }
    
  } else {
    
  }
  error_origin_ = error_origin;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.ReportErrorToServiceRequest.error_origin)
}

// -------------------------------------------------------------------

// ReportErrorToServiceResponse

// -------------------------------------------------------------------

// KeyValueEntry

// string key = 1;
inline void KeyValueEntry::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValueEntry::key() const {
  // @@protoc_insertion_point(field_get:tensorflow.KeyValueEntry.key)
  return key_.GetNoArena();
}
inline void KeyValueEntry::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.KeyValueEntry.key)
}
#if LANG_CXX11
inline void KeyValueEntry::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.KeyValueEntry.key)
}
#endif
inline void KeyValueEntry::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.KeyValueEntry.key)
}
inline void KeyValueEntry::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.KeyValueEntry.key)
}
inline ::std::string* KeyValueEntry::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.KeyValueEntry.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValueEntry::release_key() {
  // @@protoc_insertion_point(field_release:tensorflow.KeyValueEntry.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValueEntry::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.KeyValueEntry.key)
}

// bytes value = 2;
inline void KeyValueEntry::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyValueEntry::value() const {
  // @@protoc_insertion_point(field_get:tensorflow.KeyValueEntry.value)
  return value_.GetNoArena();
}
inline void KeyValueEntry::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.KeyValueEntry.value)
}
#if LANG_CXX11
inline void KeyValueEntry::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.KeyValueEntry.value)
}
#endif
inline void KeyValueEntry::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.KeyValueEntry.value)
}
inline void KeyValueEntry::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.KeyValueEntry.value)
}
inline ::std::string* KeyValueEntry::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.KeyValueEntry.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyValueEntry::release_value() {
  // @@protoc_insertion_point(field_release:tensorflow.KeyValueEntry.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyValueEntry::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.KeyValueEntry.value)
}

// -------------------------------------------------------------------

// InsertKeyValueRequest

// .tensorflow.KeyValueEntry kv = 1;
inline bool InsertKeyValueRequest::has_kv() const {
  return this != internal_default_instance() && kv_ != NULL;
}
inline void InsertKeyValueRequest::clear_kv() {
  if (GetArenaNoVirtual() == NULL && kv_ != NULL) {
    delete kv_;
  }
  kv_ = NULL;
}
inline const ::tensorflow::KeyValueEntry& InsertKeyValueRequest::_internal_kv() const {
  return *kv_;
}
inline const ::tensorflow::KeyValueEntry& InsertKeyValueRequest::kv() const {
  const ::tensorflow::KeyValueEntry* p = kv_;
  // @@protoc_insertion_point(field_get:tensorflow.InsertKeyValueRequest.kv)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::KeyValueEntry*>(
      &::tensorflow::_KeyValueEntry_default_instance_);
}
inline ::tensorflow::KeyValueEntry* InsertKeyValueRequest::release_kv() {
  // @@protoc_insertion_point(field_release:tensorflow.InsertKeyValueRequest.kv)
  
  ::tensorflow::KeyValueEntry* temp = kv_;
  kv_ = NULL;
  return temp;
}
inline ::tensorflow::KeyValueEntry* InsertKeyValueRequest::mutable_kv() {
  
  if (kv_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::KeyValueEntry>(GetArenaNoVirtual());
    kv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.InsertKeyValueRequest.kv)
  return kv_;
}
inline void InsertKeyValueRequest::set_allocated_kv(::tensorflow::KeyValueEntry* kv) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kv_;
  }
  if (kv) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kv = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kv, submessage_arena);
    }
    
  } else {
    
  }
  kv_ = kv;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.InsertKeyValueRequest.kv)
}

// -------------------------------------------------------------------

// InsertKeyValueResponse

// -------------------------------------------------------------------

// GetKeyValueRequest

// string key = 1;
inline void GetKeyValueRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetKeyValueRequest::key() const {
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueRequest.key)
  return key_.GetNoArena();
}
inline void GetKeyValueRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.GetKeyValueRequest.key)
}
#if LANG_CXX11
inline void GetKeyValueRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.GetKeyValueRequest.key)
}
#endif
inline void GetKeyValueRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.GetKeyValueRequest.key)
}
inline void GetKeyValueRequest::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.GetKeyValueRequest.key)
}
inline ::std::string* GetKeyValueRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetKeyValueRequest::release_key() {
  // @@protoc_insertion_point(field_release:tensorflow.GetKeyValueRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetKeyValueRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetKeyValueRequest.key)
}

// -------------------------------------------------------------------

// GetKeyValueResponse

// .tensorflow.KeyValueEntry kv = 1;
inline bool GetKeyValueResponse::has_kv() const {
  return this != internal_default_instance() && kv_ != NULL;
}
inline void GetKeyValueResponse::clear_kv() {
  if (GetArenaNoVirtual() == NULL && kv_ != NULL) {
    delete kv_;
  }
  kv_ = NULL;
}
inline const ::tensorflow::KeyValueEntry& GetKeyValueResponse::_internal_kv() const {
  return *kv_;
}
inline const ::tensorflow::KeyValueEntry& GetKeyValueResponse::kv() const {
  const ::tensorflow::KeyValueEntry* p = kv_;
  // @@protoc_insertion_point(field_get:tensorflow.GetKeyValueResponse.kv)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::KeyValueEntry*>(
      &::tensorflow::_KeyValueEntry_default_instance_);
}
inline ::tensorflow::KeyValueEntry* GetKeyValueResponse::release_kv() {
  // @@protoc_insertion_point(field_release:tensorflow.GetKeyValueResponse.kv)
  
  ::tensorflow::KeyValueEntry* temp = kv_;
  kv_ = NULL;
  return temp;
}
inline ::tensorflow::KeyValueEntry* GetKeyValueResponse::mutable_kv() {
  
  if (kv_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::KeyValueEntry>(GetArenaNoVirtual());
    kv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.GetKeyValueResponse.kv)
  return kv_;
}
inline void GetKeyValueResponse::set_allocated_kv(::tensorflow::KeyValueEntry* kv) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete kv_;
  }
  if (kv) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      kv = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, kv, submessage_arena);
    }
    
  } else {
    
  }
  kv_ = kv;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.GetKeyValueResponse.kv)
}

// -------------------------------------------------------------------

// DeleteKeyValueRequest

// string key = 1;
inline void DeleteKeyValueRequest::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteKeyValueRequest::key() const {
  // @@protoc_insertion_point(field_get:tensorflow.DeleteKeyValueRequest.key)
  return key_.GetNoArena();
}
inline void DeleteKeyValueRequest::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.DeleteKeyValueRequest.key)
}
#if LANG_CXX11
inline void DeleteKeyValueRequest::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.DeleteKeyValueRequest.key)
}
#endif
inline void DeleteKeyValueRequest::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.DeleteKeyValueRequest.key)
}
inline void DeleteKeyValueRequest::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.DeleteKeyValueRequest.key)
}
inline ::std::string* DeleteKeyValueRequest::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.DeleteKeyValueRequest.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteKeyValueRequest::release_key() {
  // @@protoc_insertion_point(field_release:tensorflow.DeleteKeyValueRequest.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteKeyValueRequest::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.DeleteKeyValueRequest.key)
}

// bool is_directory = 2;
inline void DeleteKeyValueRequest::clear_is_directory() {
  is_directory_ = false;
}
inline bool DeleteKeyValueRequest::is_directory() const {
  // @@protoc_insertion_point(field_get:tensorflow.DeleteKeyValueRequest.is_directory)
  return is_directory_;
}
inline void DeleteKeyValueRequest::set_is_directory(bool value) {
  
  is_directory_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.DeleteKeyValueRequest.is_directory)
}

// -------------------------------------------------------------------

// DeleteKeyValueResponse

// -------------------------------------------------------------------

// BarrierRequest

// string barrier_id = 1;
inline void BarrierRequest::clear_barrier_id() {
  barrier_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& BarrierRequest::barrier_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.barrier_id)
  return barrier_id_.GetNoArena();
}
inline void BarrierRequest::set_barrier_id(const ::std::string& value) {
  
  barrier_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.BarrierRequest.barrier_id)
}
#if LANG_CXX11
inline void BarrierRequest::set_barrier_id(::std::string&& value) {
  
  barrier_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.BarrierRequest.barrier_id)
}
#endif
inline void BarrierRequest::set_barrier_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  barrier_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.BarrierRequest.barrier_id)
}
inline void BarrierRequest::set_barrier_id(const char* value, size_t size) {
  
  barrier_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.BarrierRequest.barrier_id)
}
inline ::std::string* BarrierRequest::mutable_barrier_id() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.BarrierRequest.barrier_id)
  return barrier_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BarrierRequest::release_barrier_id() {
  // @@protoc_insertion_point(field_release:tensorflow.BarrierRequest.barrier_id)
  
  return barrier_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BarrierRequest::set_allocated_barrier_id(::std::string* barrier_id) {
  if (barrier_id != NULL) {
    
  } else {
    
  }
  barrier_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), barrier_id);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BarrierRequest.barrier_id)
}

// int64 barrier_timeout_in_ms = 2;
inline void BarrierRequest::clear_barrier_timeout_in_ms() {
  barrier_timeout_in_ms_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 BarrierRequest::barrier_timeout_in_ms() const {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.barrier_timeout_in_ms)
  return barrier_timeout_in_ms_;
}
inline void BarrierRequest::set_barrier_timeout_in_ms(::google::protobuf::int64 value) {
  
  barrier_timeout_in_ms_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.BarrierRequest.barrier_timeout_in_ms)
}

// repeated .tensorflow.CoordinatedTask tasks = 3;
inline int BarrierRequest::tasks_size() const {
  return tasks_.size();
}
inline void BarrierRequest::clear_tasks() {
  tasks_.Clear();
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.BarrierRequest.tasks)
  return tasks_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTask >*
BarrierRequest::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.BarrierRequest.tasks)
  return &tasks_;
}
inline const ::tensorflow::CoordinatedTask& BarrierRequest::tasks(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.tasks)
  return tasks_.Get(index);
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::add_tasks() {
  // @@protoc_insertion_point(field_add:tensorflow.BarrierRequest.tasks)
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::CoordinatedTask >&
BarrierRequest::tasks() const {
  // @@protoc_insertion_point(field_list:tensorflow.BarrierRequest.tasks)
  return tasks_;
}

// .tensorflow.CoordinatedTask source_task = 4;
inline bool BarrierRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != NULL;
}
inline void BarrierRequest::clear_source_task() {
  if (GetArenaNoVirtual() == NULL && source_task_ != NULL) {
    delete source_task_;
  }
  source_task_ = NULL;
}
inline const ::tensorflow::CoordinatedTask& BarrierRequest::_internal_source_task() const {
  return *source_task_;
}
inline const ::tensorflow::CoordinatedTask& BarrierRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.BarrierRequest.source_task)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.BarrierRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinatedTask* BarrierRequest::mutable_source_task() {
  
  if (source_task_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.BarrierRequest.source_task)
  return source_task_;
}
inline void BarrierRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_task_;
  }
  if (source_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.BarrierRequest.source_task)
}

// -------------------------------------------------------------------

// BarrierResponse

// -------------------------------------------------------------------

// CancelBarrierRequest

// string barrier_id = 1;
inline void CancelBarrierRequest::clear_barrier_id() {
  barrier_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CancelBarrierRequest::barrier_id() const {
  // @@protoc_insertion_point(field_get:tensorflow.CancelBarrierRequest.barrier_id)
  return barrier_id_.GetNoArena();
}
inline void CancelBarrierRequest::set_barrier_id(const ::std::string& value) {
  
  barrier_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.CancelBarrierRequest.barrier_id)
}
#if LANG_CXX11
inline void CancelBarrierRequest::set_barrier_id(::std::string&& value) {
  
  barrier_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.CancelBarrierRequest.barrier_id)
}
#endif
inline void CancelBarrierRequest::set_barrier_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  barrier_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.CancelBarrierRequest.barrier_id)
}
inline void CancelBarrierRequest::set_barrier_id(const char* value, size_t size) {
  
  barrier_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.CancelBarrierRequest.barrier_id)
}
inline ::std::string* CancelBarrierRequest::mutable_barrier_id() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.CancelBarrierRequest.barrier_id)
  return barrier_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CancelBarrierRequest::release_barrier_id() {
  // @@protoc_insertion_point(field_release:tensorflow.CancelBarrierRequest.barrier_id)
  
  return barrier_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CancelBarrierRequest::set_allocated_barrier_id(::std::string* barrier_id) {
  if (barrier_id != NULL) {
    
  } else {
    
  }
  barrier_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), barrier_id);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CancelBarrierRequest.barrier_id)
}

// .tensorflow.CoordinatedTask source_task = 2;
inline bool CancelBarrierRequest::has_source_task() const {
  return this != internal_default_instance() && source_task_ != NULL;
}
inline void CancelBarrierRequest::clear_source_task() {
  if (GetArenaNoVirtual() == NULL && source_task_ != NULL) {
    delete source_task_;
  }
  source_task_ = NULL;
}
inline const ::tensorflow::CoordinatedTask& CancelBarrierRequest::_internal_source_task() const {
  return *source_task_;
}
inline const ::tensorflow::CoordinatedTask& CancelBarrierRequest::source_task() const {
  const ::tensorflow::CoordinatedTask* p = source_task_;
  // @@protoc_insertion_point(field_get:tensorflow.CancelBarrierRequest.source_task)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::CoordinatedTask*>(
      &::tensorflow::_CoordinatedTask_default_instance_);
}
inline ::tensorflow::CoordinatedTask* CancelBarrierRequest::release_source_task() {
  // @@protoc_insertion_point(field_release:tensorflow.CancelBarrierRequest.source_task)
  
  ::tensorflow::CoordinatedTask* temp = source_task_;
  source_task_ = NULL;
  return temp;
}
inline ::tensorflow::CoordinatedTask* CancelBarrierRequest::mutable_source_task() {
  
  if (source_task_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::CoordinatedTask>(GetArenaNoVirtual());
    source_task_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.CancelBarrierRequest.source_task)
  return source_task_;
}
inline void CancelBarrierRequest::set_allocated_source_task(::tensorflow::CoordinatedTask* source_task) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete source_task_;
  }
  if (source_task) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      source_task = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, source_task, submessage_arena);
    }
    
  } else {
    
  }
  source_task_ = source_task;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.CancelBarrierRequest.source_task)
}

// -------------------------------------------------------------------

// CancelBarrierResponse

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fcore_2fprotobuf_2fcoordination_5fservice_2eproto
