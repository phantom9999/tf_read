// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: tensorflow/compiler/xla/rpc/xla_service.proto
// Original file comments:
// Copyright 2018 The TensorFlow Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// ==============================================================================
//
// XLA service API.
//
// Users 1) build up computations and 2) create allocations via this API.
// Computations are composed of data flowing between arbitrarily-sized
// vector-oriented operations.
//
// Users build up computations using a ComputationHandle, and talk about
// allocations using GlobalDataHandles.
//
// There are currently no checkpointing capabilities or distribution/replication
// guarantees. The service runs on a single machine (e.g. one task) and that is
// its failure domain.
//
// Canonical example of "alpha * X + Y":
// * Make a computation.
// * Add alpha and X and Y as parameters.
// * Request the multiplication of alpha and X.
// * Request the addition of that result and Y.
//
// Then, pass the computation and appropriately shaped inputs to the XLA
// service's Execute method, which provides a result as a GlobalDataHandle.
//
// All data in XLA computations are conceptually immutable.
//
// Note: this API is subject to change / refinement over time -- use the
// provided client libraries to insulate code from changes to this service API.
//
#ifndef GRPC_tensorflow_2fcompiler_2fxla_2frpc_2fxla_5fservice_2eproto__INCLUDED
#define GRPC_tensorflow_2fcompiler_2fxla_2frpc_2fxla_5fservice_2eproto__INCLUDED

#include "tensorflow/compiler/xla/rpc/xla_service.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

namespace xla {

class XlaService final {
 public:
  static constexpr char const* service_full_name() {
    return "xla.XlaService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Unregisters a global allocation.
    //
    // If the handle given is not currently allocated, a NOT_FOUND status is
    // returned.
    virtual ::grpc::Status Unregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::xla::UnregisterResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>> AsyncUnregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>>(AsyncUnregisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>> PrepareAsyncUnregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>>(PrepareAsyncUnregisterRaw(context, request, cq));
    }
    // Deconstructs a tuple. Returns a newly created GlobalDataHandle for each
    // element in the tuple.
    virtual ::grpc::Status DeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::xla::DeconstructTupleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>> AsyncDeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>>(AsyncDeconstructTupleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>> PrepareAsyncDeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>>(PrepareAsyncDeconstructTupleRaw(context, request, cq));
    }
    // Unpack requests that a global data handle, with a tuple shape, has global
    // data handles created for each of its constituent members. This is the
    // equivalent of the "destructuring assignment" present in various programming
    // languages.
    virtual ::grpc::Status Unpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::xla::UnpackResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>> AsyncUnpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>>(AsyncUnpackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>> PrepareAsyncUnpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>>(PrepareAsyncUnpackRaw(context, request, cq));
    }
    // Requests the shape of the referenced global data.
    virtual ::grpc::Status GetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::xla::GetShapeResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>> AsyncGetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>>(AsyncGetShapeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>> PrepareAsyncGetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>>(PrepareAsyncGetShapeRaw(context, request, cq));
    }
    // Requests the statistics of the given computation.
    virtual ::grpc::Status GetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::xla::ComputationStatsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>> AsyncGetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>>(AsyncGetComputationGraphStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>> PrepareAsyncGetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>>(PrepareAsyncGetComputationGraphStatsRaw(context, request, cq));
    }
    // Loads a variable number of values with a given element type from ColumnIO.
    virtual ::grpc::Status LoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::xla::LoadDataResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>> AsyncLoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>>(AsyncLoadDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>> PrepareAsyncLoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>>(PrepareAsyncLoadDataRaw(context, request, cq));
    }
    // Transfers the given global data to the client in the form of a Literal.
    virtual ::grpc::Status TransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::xla::TransferToClientResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>> AsyncTransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>>(AsyncTransferToClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>> PrepareAsyncTransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>>(PrepareAsyncTransferToClientRaw(context, request, cq));
    }
    // Transfers the given literal to the server to be stored in a global
    // allocation, which is returned.
    virtual ::grpc::Status TransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::xla::TransferToServerResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>> AsyncTransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>>(AsyncTransferToServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>> PrepareAsyncTransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>>(PrepareAsyncTransferToServerRaw(context, request, cq));
    }
    // Transfers the given literal to the Infeed buffer of the device.
    virtual ::grpc::Status TransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::xla::TransferToInfeedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>> AsyncTransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>>(AsyncTransferToInfeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>> PrepareAsyncTransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>>(PrepareAsyncTransferToInfeedRaw(context, request, cq));
    }
    // Transferred literal from the Outfeed buffer of the device.
    virtual ::grpc::Status TransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::xla::TransferFromOutfeedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>> AsyncTransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>>(AsyncTransferFromOutfeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>> PrepareAsyncTransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>>(PrepareAsyncTransferFromOutfeedRaw(context, request, cq));
    }
    // Resets the device, clearing all existing state on the device.
    virtual ::grpc::Status ResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::xla::ResetDeviceResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>> AsyncResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>>(AsyncResetDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>> PrepareAsyncResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>>(PrepareAsyncResetDeviceRaw(context, request, cq));
    }
    // Computes the value of a constant expression. The request contains the
    // computation graph for the constant expression.
    virtual ::grpc::Status ComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::xla::ComputeConstantResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>> AsyncComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>>(AsyncComputeConstantGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>> PrepareAsyncComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>>(PrepareAsyncComputeConstantGraphRaw(context, request, cq));
    }
    // Requests one or more device handles from the target. The returned device
    // handles can be used to specify the device on which to execute computations
    // or transfer data.
    virtual ::grpc::Status GetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::xla::GetDeviceHandlesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>> AsyncGetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>>(AsyncGetDeviceHandlesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>> PrepareAsyncGetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>>(PrepareAsyncGetDeviceHandlesRaw(context, request, cq));
    }
    // Creates a channel handle that can be used to transfer data between
    // two computations via a pair of Send and Recv instructions.
    virtual ::grpc::Status CreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::xla::CreateChannelHandleResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>> AsyncCreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>>(AsyncCreateChannelHandleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>> PrepareAsyncCreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>>(PrepareAsyncCreateChannelHandleRaw(context, request, cq));
    }
    // Compiles the provided computation into executable. Returns the handle of
    // the executable.
    virtual ::grpc::Status Compile(::grpc::ClientContext* context, const ::xla::CompileRequest& request, ::xla::CompileResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CompileResponse>> AsyncCompile(::grpc::ClientContext* context, const ::xla::CompileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CompileResponse>>(AsyncCompileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CompileResponse>> PrepareAsyncCompile(::grpc::ClientContext* context, const ::xla::CompileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::CompileResponse>>(PrepareAsyncCompileRaw(context, request, cq));
    }
    // Invokes the provided executable with the provided global data passed as
    // immutable arguments. The request contains the handle to the executable.
    // Returns global data output and execution timing.
    virtual ::grpc::Status Execute(::grpc::ClientContext* context, const ::xla::ExecuteRequest& request, ::xla::ExecuteResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>> AsyncExecute(::grpc::ClientContext* context, const ::xla::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>>(AsyncExecuteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>> PrepareAsyncExecute(::grpc::ClientContext* context, const ::xla::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>>(PrepareAsyncExecuteRaw(context, request, cq));
    }
    // Invokes the provided list of computations in parallel with the provided
    // global data for each computation. Returns a list of global data output and
    // execution timing.
    virtual ::grpc::Status ExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::xla::ExecuteParallelResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>> AsyncExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>>(AsyncExecuteGraphParallelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>> PrepareAsyncExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>>(PrepareAsyncExecuteGraphParallelRaw(context, request, cq));
    }
    // Waits until the given execution (aysnchronously launched) is complete, and
    // returns the global data output.
    virtual ::grpc::Status WaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::xla::WaitForExecutionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>> AsyncWaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>>(AsyncWaitForExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>> PrepareAsyncWaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>>(PrepareAsyncWaitForExecutionRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // Unregisters a global allocation.
      //
      // If the handle given is not currently allocated, a NOT_FOUND status is
      // returned.
      virtual void Unregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Deconstructs a tuple. Returns a newly created GlobalDataHandle for each
      // element in the tuple.
      virtual void DeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Unpack requests that a global data handle, with a tuple shape, has global
      // data handles created for each of its constituent members. This is the
      // equivalent of the "destructuring assignment" present in various programming
      // languages.
      virtual void Unpack(::grpc::ClientContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Requests the shape of the referenced global data.
      virtual void GetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Requests the statistics of the given computation.
      virtual void GetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Loads a variable number of values with a given element type from ColumnIO.
      virtual void LoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Transfers the given global data to the client in the form of a Literal.
      virtual void TransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Transfers the given literal to the server to be stored in a global
      // allocation, which is returned.
      virtual void TransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Transfers the given literal to the Infeed buffer of the device.
      virtual void TransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Transferred literal from the Outfeed buffer of the device.
      virtual void TransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Resets the device, clearing all existing state on the device.
      virtual void ResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Computes the value of a constant expression. The request contains the
      // computation graph for the constant expression.
      virtual void ComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Requests one or more device handles from the target. The returned device
      // handles can be used to specify the device on which to execute computations
      // or transfer data.
      virtual void GetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Creates a channel handle that can be used to transfer data between
      // two computations via a pair of Send and Recv instructions.
      virtual void CreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Compiles the provided computation into executable. Returns the handle of
      // the executable.
      virtual void Compile(::grpc::ClientContext* context, const ::xla::CompileRequest* request, ::xla::CompileResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Invokes the provided executable with the provided global data passed as
      // immutable arguments. The request contains the handle to the executable.
      // Returns global data output and execution timing.
      virtual void Execute(::grpc::ClientContext* context, const ::xla::ExecuteRequest* request, ::xla::ExecuteResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Invokes the provided list of computations in parallel with the provided
      // global data for each computation. Returns a list of global data output and
      // execution timing.
      virtual void ExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response, std::function<void(::grpc::Status)>) = 0;
      // Waits until the given execution (aysnchronously launched) is complete, and
      // returns the global data output.
      virtual void WaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response, std::function<void(::grpc::Status)>) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>* AsyncUnregisterRaw(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnregisterResponse>* PrepareAsyncUnregisterRaw(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>* AsyncDeconstructTupleRaw(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::DeconstructTupleResponse>* PrepareAsyncDeconstructTupleRaw(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>* AsyncUnpackRaw(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::UnpackResponse>* PrepareAsyncUnpackRaw(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>* AsyncGetShapeRaw(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetShapeResponse>* PrepareAsyncGetShapeRaw(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>* AsyncGetComputationGraphStatsRaw(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputationStatsResponse>* PrepareAsyncGetComputationGraphStatsRaw(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>* AsyncLoadDataRaw(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::LoadDataResponse>* PrepareAsyncLoadDataRaw(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>* AsyncTransferToClientRaw(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToClientResponse>* PrepareAsyncTransferToClientRaw(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>* AsyncTransferToServerRaw(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToServerResponse>* PrepareAsyncTransferToServerRaw(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>* AsyncTransferToInfeedRaw(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferToInfeedResponse>* PrepareAsyncTransferToInfeedRaw(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>* AsyncTransferFromOutfeedRaw(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::TransferFromOutfeedResponse>* PrepareAsyncTransferFromOutfeedRaw(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>* AsyncResetDeviceRaw(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ResetDeviceResponse>* PrepareAsyncResetDeviceRaw(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>* AsyncComputeConstantGraphRaw(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ComputeConstantResponse>* PrepareAsyncComputeConstantGraphRaw(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>* AsyncGetDeviceHandlesRaw(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::GetDeviceHandlesResponse>* PrepareAsyncGetDeviceHandlesRaw(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>* AsyncCreateChannelHandleRaw(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::CreateChannelHandleResponse>* PrepareAsyncCreateChannelHandleRaw(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::CompileResponse>* AsyncCompileRaw(::grpc::ClientContext* context, const ::xla::CompileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::CompileResponse>* PrepareAsyncCompileRaw(::grpc::ClientContext* context, const ::xla::CompileRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>* AsyncExecuteRaw(::grpc::ClientContext* context, const ::xla::ExecuteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteResponse>* PrepareAsyncExecuteRaw(::grpc::ClientContext* context, const ::xla::ExecuteRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>* AsyncExecuteGraphParallelRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::ExecuteParallelResponse>* PrepareAsyncExecuteGraphParallelRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>* AsyncWaitForExecutionRaw(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::xla::WaitForExecutionResponse>* PrepareAsyncWaitForExecutionRaw(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status Unregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::xla::UnregisterResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>> AsyncUnregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>>(AsyncUnregisterRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>> PrepareAsyncUnregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>>(PrepareAsyncUnregisterRaw(context, request, cq));
    }
    ::grpc::Status DeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::xla::DeconstructTupleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>> AsyncDeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>>(AsyncDeconstructTupleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>> PrepareAsyncDeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>>(PrepareAsyncDeconstructTupleRaw(context, request, cq));
    }
    ::grpc::Status Unpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::xla::UnpackResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>> AsyncUnpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>>(AsyncUnpackRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>> PrepareAsyncUnpack(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>>(PrepareAsyncUnpackRaw(context, request, cq));
    }
    ::grpc::Status GetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::xla::GetShapeResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>> AsyncGetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>>(AsyncGetShapeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>> PrepareAsyncGetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>>(PrepareAsyncGetShapeRaw(context, request, cq));
    }
    ::grpc::Status GetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::xla::ComputationStatsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>> AsyncGetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>>(AsyncGetComputationGraphStatsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>> PrepareAsyncGetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>>(PrepareAsyncGetComputationGraphStatsRaw(context, request, cq));
    }
    ::grpc::Status LoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::xla::LoadDataResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>> AsyncLoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>>(AsyncLoadDataRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>> PrepareAsyncLoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>>(PrepareAsyncLoadDataRaw(context, request, cq));
    }
    ::grpc::Status TransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::xla::TransferToClientResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>> AsyncTransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>>(AsyncTransferToClientRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>> PrepareAsyncTransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>>(PrepareAsyncTransferToClientRaw(context, request, cq));
    }
    ::grpc::Status TransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::xla::TransferToServerResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>> AsyncTransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>>(AsyncTransferToServerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>> PrepareAsyncTransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>>(PrepareAsyncTransferToServerRaw(context, request, cq));
    }
    ::grpc::Status TransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::xla::TransferToInfeedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>> AsyncTransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>>(AsyncTransferToInfeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>> PrepareAsyncTransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>>(PrepareAsyncTransferToInfeedRaw(context, request, cq));
    }
    ::grpc::Status TransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::xla::TransferFromOutfeedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>> AsyncTransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>>(AsyncTransferFromOutfeedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>> PrepareAsyncTransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>>(PrepareAsyncTransferFromOutfeedRaw(context, request, cq));
    }
    ::grpc::Status ResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::xla::ResetDeviceResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>> AsyncResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>>(AsyncResetDeviceRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>> PrepareAsyncResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>>(PrepareAsyncResetDeviceRaw(context, request, cq));
    }
    ::grpc::Status ComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::xla::ComputeConstantResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>> AsyncComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>>(AsyncComputeConstantGraphRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>> PrepareAsyncComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>>(PrepareAsyncComputeConstantGraphRaw(context, request, cq));
    }
    ::grpc::Status GetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::xla::GetDeviceHandlesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>> AsyncGetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>>(AsyncGetDeviceHandlesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>> PrepareAsyncGetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>>(PrepareAsyncGetDeviceHandlesRaw(context, request, cq));
    }
    ::grpc::Status CreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::xla::CreateChannelHandleResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>> AsyncCreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>>(AsyncCreateChannelHandleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>> PrepareAsyncCreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>>(PrepareAsyncCreateChannelHandleRaw(context, request, cq));
    }
    ::grpc::Status Compile(::grpc::ClientContext* context, const ::xla::CompileRequest& request, ::xla::CompileResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CompileResponse>> AsyncCompile(::grpc::ClientContext* context, const ::xla::CompileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CompileResponse>>(AsyncCompileRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CompileResponse>> PrepareAsyncCompile(::grpc::ClientContext* context, const ::xla::CompileRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::CompileResponse>>(PrepareAsyncCompileRaw(context, request, cq));
    }
    ::grpc::Status Execute(::grpc::ClientContext* context, const ::xla::ExecuteRequest& request, ::xla::ExecuteResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>> AsyncExecute(::grpc::ClientContext* context, const ::xla::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>>(AsyncExecuteRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>> PrepareAsyncExecute(::grpc::ClientContext* context, const ::xla::ExecuteRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>>(PrepareAsyncExecuteRaw(context, request, cq));
    }
    ::grpc::Status ExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::xla::ExecuteParallelResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>> AsyncExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>>(AsyncExecuteGraphParallelRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>> PrepareAsyncExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>>(PrepareAsyncExecuteGraphParallelRaw(context, request, cq));
    }
    ::grpc::Status WaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::xla::WaitForExecutionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>> AsyncWaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>>(AsyncWaitForExecutionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>> PrepareAsyncWaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>>(PrepareAsyncWaitForExecutionRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Unregister(::grpc::ClientContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response, std::function<void(::grpc::Status)>) override;
      void DeconstructTuple(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response, std::function<void(::grpc::Status)>) override;
      void Unpack(::grpc::ClientContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response, std::function<void(::grpc::Status)>) override;
      void GetShape(::grpc::ClientContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response, std::function<void(::grpc::Status)>) override;
      void GetComputationGraphStats(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response, std::function<void(::grpc::Status)>) override;
      void LoadData(::grpc::ClientContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response, std::function<void(::grpc::Status)>) override;
      void TransferToClient(::grpc::ClientContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response, std::function<void(::grpc::Status)>) override;
      void TransferToServer(::grpc::ClientContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response, std::function<void(::grpc::Status)>) override;
      void TransferToInfeed(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response, std::function<void(::grpc::Status)>) override;
      void TransferFromOutfeed(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response, std::function<void(::grpc::Status)>) override;
      void ResetDevice(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response, std::function<void(::grpc::Status)>) override;
      void ComputeConstantGraph(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response, std::function<void(::grpc::Status)>) override;
      void GetDeviceHandles(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateChannelHandle(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response, std::function<void(::grpc::Status)>) override;
      void Compile(::grpc::ClientContext* context, const ::xla::CompileRequest* request, ::xla::CompileResponse* response, std::function<void(::grpc::Status)>) override;
      void Execute(::grpc::ClientContext* context, const ::xla::ExecuteRequest* request, ::xla::ExecuteResponse* response, std::function<void(::grpc::Status)>) override;
      void ExecuteGraphParallel(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response, std::function<void(::grpc::Status)>) override;
      void WaitForExecution(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response, std::function<void(::grpc::Status)>) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>* AsyncUnregisterRaw(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::UnregisterResponse>* PrepareAsyncUnregisterRaw(::grpc::ClientContext* context, const ::xla::UnregisterRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>* AsyncDeconstructTupleRaw(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::DeconstructTupleResponse>* PrepareAsyncDeconstructTupleRaw(::grpc::ClientContext* context, const ::xla::DeconstructTupleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>* AsyncUnpackRaw(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::UnpackResponse>* PrepareAsyncUnpackRaw(::grpc::ClientContext* context, const ::xla::UnpackRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>* AsyncGetShapeRaw(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::GetShapeResponse>* PrepareAsyncGetShapeRaw(::grpc::ClientContext* context, const ::xla::GetShapeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>* AsyncGetComputationGraphStatsRaw(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ComputationStatsResponse>* PrepareAsyncGetComputationGraphStatsRaw(::grpc::ClientContext* context, const ::xla::ComputationGraphStatsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>* AsyncLoadDataRaw(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::LoadDataResponse>* PrepareAsyncLoadDataRaw(::grpc::ClientContext* context, const ::xla::LoadDataRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>* AsyncTransferToClientRaw(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToClientResponse>* PrepareAsyncTransferToClientRaw(::grpc::ClientContext* context, const ::xla::TransferToClientRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>* AsyncTransferToServerRaw(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToServerResponse>* PrepareAsyncTransferToServerRaw(::grpc::ClientContext* context, const ::xla::TransferToServerRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>* AsyncTransferToInfeedRaw(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferToInfeedResponse>* PrepareAsyncTransferToInfeedRaw(::grpc::ClientContext* context, const ::xla::TransferToInfeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>* AsyncTransferFromOutfeedRaw(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::TransferFromOutfeedResponse>* PrepareAsyncTransferFromOutfeedRaw(::grpc::ClientContext* context, const ::xla::TransferFromOutfeedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>* AsyncResetDeviceRaw(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ResetDeviceResponse>* PrepareAsyncResetDeviceRaw(::grpc::ClientContext* context, const ::xla::ResetDeviceRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>* AsyncComputeConstantGraphRaw(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ComputeConstantResponse>* PrepareAsyncComputeConstantGraphRaw(::grpc::ClientContext* context, const ::xla::ComputeConstantGraphRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>* AsyncGetDeviceHandlesRaw(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::GetDeviceHandlesResponse>* PrepareAsyncGetDeviceHandlesRaw(::grpc::ClientContext* context, const ::xla::GetDeviceHandlesRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>* AsyncCreateChannelHandleRaw(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::CreateChannelHandleResponse>* PrepareAsyncCreateChannelHandleRaw(::grpc::ClientContext* context, const ::xla::CreateChannelHandleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::CompileResponse>* AsyncCompileRaw(::grpc::ClientContext* context, const ::xla::CompileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::CompileResponse>* PrepareAsyncCompileRaw(::grpc::ClientContext* context, const ::xla::CompileRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>* AsyncExecuteRaw(::grpc::ClientContext* context, const ::xla::ExecuteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ExecuteResponse>* PrepareAsyncExecuteRaw(::grpc::ClientContext* context, const ::xla::ExecuteRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>* AsyncExecuteGraphParallelRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::ExecuteParallelResponse>* PrepareAsyncExecuteGraphParallelRaw(::grpc::ClientContext* context, const ::xla::ExecuteGraphParallelRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>* AsyncWaitForExecutionRaw(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::xla::WaitForExecutionResponse>* PrepareAsyncWaitForExecutionRaw(::grpc::ClientContext* context, const ::xla::WaitForExecutionRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Unregister_;
    const ::grpc::internal::RpcMethod rpcmethod_DeconstructTuple_;
    const ::grpc::internal::RpcMethod rpcmethod_Unpack_;
    const ::grpc::internal::RpcMethod rpcmethod_GetShape_;
    const ::grpc::internal::RpcMethod rpcmethod_GetComputationGraphStats_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadData_;
    const ::grpc::internal::RpcMethod rpcmethod_TransferToClient_;
    const ::grpc::internal::RpcMethod rpcmethod_TransferToServer_;
    const ::grpc::internal::RpcMethod rpcmethod_TransferToInfeed_;
    const ::grpc::internal::RpcMethod rpcmethod_TransferFromOutfeed_;
    const ::grpc::internal::RpcMethod rpcmethod_ResetDevice_;
    const ::grpc::internal::RpcMethod rpcmethod_ComputeConstantGraph_;
    const ::grpc::internal::RpcMethod rpcmethod_GetDeviceHandles_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateChannelHandle_;
    const ::grpc::internal::RpcMethod rpcmethod_Compile_;
    const ::grpc::internal::RpcMethod rpcmethod_Execute_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteGraphParallel_;
    const ::grpc::internal::RpcMethod rpcmethod_WaitForExecution_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Unregisters a global allocation.
    //
    // If the handle given is not currently allocated, a NOT_FOUND status is
    // returned.
    virtual ::grpc::Status Unregister(::grpc::ServerContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response);
    // Deconstructs a tuple. Returns a newly created GlobalDataHandle for each
    // element in the tuple.
    virtual ::grpc::Status DeconstructTuple(::grpc::ServerContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response);
    // Unpack requests that a global data handle, with a tuple shape, has global
    // data handles created for each of its constituent members. This is the
    // equivalent of the "destructuring assignment" present in various programming
    // languages.
    virtual ::grpc::Status Unpack(::grpc::ServerContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response);
    // Requests the shape of the referenced global data.
    virtual ::grpc::Status GetShape(::grpc::ServerContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response);
    // Requests the statistics of the given computation.
    virtual ::grpc::Status GetComputationGraphStats(::grpc::ServerContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response);
    // Loads a variable number of values with a given element type from ColumnIO.
    virtual ::grpc::Status LoadData(::grpc::ServerContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response);
    // Transfers the given global data to the client in the form of a Literal.
    virtual ::grpc::Status TransferToClient(::grpc::ServerContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response);
    // Transfers the given literal to the server to be stored in a global
    // allocation, which is returned.
    virtual ::grpc::Status TransferToServer(::grpc::ServerContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response);
    // Transfers the given literal to the Infeed buffer of the device.
    virtual ::grpc::Status TransferToInfeed(::grpc::ServerContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response);
    // Transferred literal from the Outfeed buffer of the device.
    virtual ::grpc::Status TransferFromOutfeed(::grpc::ServerContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response);
    // Resets the device, clearing all existing state on the device.
    virtual ::grpc::Status ResetDevice(::grpc::ServerContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response);
    // Computes the value of a constant expression. The request contains the
    // computation graph for the constant expression.
    virtual ::grpc::Status ComputeConstantGraph(::grpc::ServerContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response);
    // Requests one or more device handles from the target. The returned device
    // handles can be used to specify the device on which to execute computations
    // or transfer data.
    virtual ::grpc::Status GetDeviceHandles(::grpc::ServerContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response);
    // Creates a channel handle that can be used to transfer data between
    // two computations via a pair of Send and Recv instructions.
    virtual ::grpc::Status CreateChannelHandle(::grpc::ServerContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response);
    // Compiles the provided computation into executable. Returns the handle of
    // the executable.
    virtual ::grpc::Status Compile(::grpc::ServerContext* context, const ::xla::CompileRequest* request, ::xla::CompileResponse* response);
    // Invokes the provided executable with the provided global data passed as
    // immutable arguments. The request contains the handle to the executable.
    // Returns global data output and execution timing.
    virtual ::grpc::Status Execute(::grpc::ServerContext* context, const ::xla::ExecuteRequest* request, ::xla::ExecuteResponse* response);
    // Invokes the provided list of computations in parallel with the provided
    // global data for each computation. Returns a list of global data output and
    // execution timing.
    virtual ::grpc::Status ExecuteGraphParallel(::grpc::ServerContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response);
    // Waits until the given execution (aysnchronously launched) is complete, and
    // returns the global data output.
    virtual ::grpc::Status WaitForExecution(::grpc::ServerContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Unregister() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnregister(::grpc::ServerContext* context, ::xla::UnregisterRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::UnregisterResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DeconstructTuple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DeconstructTuple() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_DeconstructTuple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeconstructTuple(::grpc::ServerContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeconstructTuple(::grpc::ServerContext* context, ::xla::DeconstructTupleRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::DeconstructTupleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Unpack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Unpack() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Unpack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unpack(::grpc::ServerContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnpack(::grpc::ServerContext* context, ::xla::UnpackRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::UnpackResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetShape() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetShape(::grpc::ServerContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetShape(::grpc::ServerContext* context, ::xla::GetShapeRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::GetShapeResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetComputationGraphStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetComputationGraphStats() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetComputationGraphStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComputationGraphStats(::grpc::ServerContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetComputationGraphStats(::grpc::ServerContext* context, ::xla::ComputationGraphStatsRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::ComputationStatsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_LoadData() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_LoadData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadData(::grpc::ServerContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadData(::grpc::ServerContext* context, ::xla::LoadDataRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::LoadDataResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransferToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TransferToClient() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_TransferToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToClient(::grpc::ServerContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferToClient(::grpc::ServerContext* context, ::xla::TransferToClientRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::TransferToClientResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransferToServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TransferToServer() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_TransferToServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToServer(::grpc::ServerContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferToServer(::grpc::ServerContext* context, ::xla::TransferToServerRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::TransferToServerResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransferToInfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TransferToInfeed() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_TransferToInfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToInfeed(::grpc::ServerContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferToInfeed(::grpc::ServerContext* context, ::xla::TransferToInfeedRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::TransferToInfeedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TransferFromOutfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_TransferFromOutfeed() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_TransferFromOutfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferFromOutfeed(::grpc::ServerContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferFromOutfeed(::grpc::ServerContext* context, ::xla::TransferFromOutfeedRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::TransferFromOutfeedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ResetDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ResetDevice() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_ResetDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetDevice(::grpc::ServerContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetDevice(::grpc::ServerContext* context, ::xla::ResetDeviceRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::ResetDeviceResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ComputeConstantGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ComputeConstantGraph() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_ComputeConstantGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ComputeConstantGraph(::grpc::ServerContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestComputeConstantGraph(::grpc::ServerContext* context, ::xla::ComputeConstantGraphRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::ComputeConstantResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetDeviceHandles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetDeviceHandles() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetDeviceHandles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDeviceHandles(::grpc::ServerContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDeviceHandles(::grpc::ServerContext* context, ::xla::GetDeviceHandlesRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::GetDeviceHandlesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateChannelHandle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_CreateChannelHandle() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_CreateChannelHandle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateChannelHandle(::grpc::ServerContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateChannelHandle(::grpc::ServerContext* context, ::xla::CreateChannelHandleRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::CreateChannelHandleResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Compile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Compile() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_Compile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Compile(::grpc::ServerContext* context, const ::xla::CompileRequest* request, ::xla::CompileResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCompile(::grpc::ServerContext* context, ::xla::CompileRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::CompileResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Execute() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* context, const ::xla::ExecuteRequest* request, ::xla::ExecuteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecute(::grpc::ServerContext* context, ::xla::ExecuteRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::ExecuteResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteGraphParallel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_ExecuteGraphParallel() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_ExecuteGraphParallel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteGraphParallel(::grpc::ServerContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteGraphParallel(::grpc::ServerContext* context, ::xla::ExecuteGraphParallelRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::ExecuteParallelResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WaitForExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_WaitForExecution() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_WaitForExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitForExecution(::grpc::ServerContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitForExecution(::grpc::ServerContext* context, ::xla::WaitForExecutionRequest* request, ::grpc::ServerAsyncResponseWriter< ::xla::WaitForExecutionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Unregister<WithAsyncMethod_DeconstructTuple<WithAsyncMethod_Unpack<WithAsyncMethod_GetShape<WithAsyncMethod_GetComputationGraphStats<WithAsyncMethod_LoadData<WithAsyncMethod_TransferToClient<WithAsyncMethod_TransferToServer<WithAsyncMethod_TransferToInfeed<WithAsyncMethod_TransferFromOutfeed<WithAsyncMethod_ResetDevice<WithAsyncMethod_ComputeConstantGraph<WithAsyncMethod_GetDeviceHandles<WithAsyncMethod_CreateChannelHandle<WithAsyncMethod_Compile<WithAsyncMethod_Execute<WithAsyncMethod_ExecuteGraphParallel<WithAsyncMethod_WaitForExecution<Service > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Unregister() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DeconstructTuple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DeconstructTuple() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_DeconstructTuple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeconstructTuple(::grpc::ServerContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Unpack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Unpack() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Unpack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unpack(::grpc::ServerContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetShape() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetShape(::grpc::ServerContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetComputationGraphStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetComputationGraphStats() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetComputationGraphStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComputationGraphStats(::grpc::ServerContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_LoadData() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_LoadData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadData(::grpc::ServerContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransferToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TransferToClient() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_TransferToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToClient(::grpc::ServerContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransferToServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TransferToServer() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_TransferToServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToServer(::grpc::ServerContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransferToInfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TransferToInfeed() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_TransferToInfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToInfeed(::grpc::ServerContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TransferFromOutfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_TransferFromOutfeed() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_TransferFromOutfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferFromOutfeed(::grpc::ServerContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ResetDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ResetDevice() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_ResetDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetDevice(::grpc::ServerContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ComputeConstantGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ComputeConstantGraph() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_ComputeConstantGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ComputeConstantGraph(::grpc::ServerContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetDeviceHandles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetDeviceHandles() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetDeviceHandles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDeviceHandles(::grpc::ServerContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateChannelHandle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_CreateChannelHandle() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_CreateChannelHandle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateChannelHandle(::grpc::ServerContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Compile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Compile() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_Compile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Compile(::grpc::ServerContext* context, const ::xla::CompileRequest* request, ::xla::CompileResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Execute() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* context, const ::xla::ExecuteRequest* request, ::xla::ExecuteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteGraphParallel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_ExecuteGraphParallel() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_ExecuteGraphParallel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteGraphParallel(::grpc::ServerContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WaitForExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_WaitForExecution() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_WaitForExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitForExecution(::grpc::ServerContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Unregister() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnregister(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DeconstructTuple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_DeconstructTuple() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_DeconstructTuple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DeconstructTuple(::grpc::ServerContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDeconstructTuple(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Unpack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Unpack() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Unpack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Unpack(::grpc::ServerContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnpack(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetShape() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetShape(::grpc::ServerContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetShape(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetComputationGraphStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetComputationGraphStats() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetComputationGraphStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetComputationGraphStats(::grpc::ServerContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetComputationGraphStats(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoadData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_LoadData() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_LoadData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadData(::grpc::ServerContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadData(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TransferToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TransferToClient() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_TransferToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToClient(::grpc::ServerContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferToClient(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TransferToServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TransferToServer() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_TransferToServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToServer(::grpc::ServerContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferToServer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TransferToInfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TransferToInfeed() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_TransferToInfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferToInfeed(::grpc::ServerContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferToInfeed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TransferFromOutfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_TransferFromOutfeed() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_TransferFromOutfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TransferFromOutfeed(::grpc::ServerContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTransferFromOutfeed(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ResetDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ResetDevice() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_ResetDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ResetDevice(::grpc::ServerContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestResetDevice(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ComputeConstantGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ComputeConstantGraph() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_ComputeConstantGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ComputeConstantGraph(::grpc::ServerContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestComputeConstantGraph(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetDeviceHandles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_GetDeviceHandles() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetDeviceHandles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetDeviceHandles(::grpc::ServerContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetDeviceHandles(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateChannelHandle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_CreateChannelHandle() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_CreateChannelHandle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateChannelHandle(::grpc::ServerContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateChannelHandle(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Compile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Compile() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_Compile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Compile(::grpc::ServerContext* context, const ::xla::CompileRequest* request, ::xla::CompileResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCompile(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_Execute() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Execute(::grpc::ServerContext* context, const ::xla::ExecuteRequest* request, ::xla::ExecuteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecute(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteGraphParallel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_ExecuteGraphParallel() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_ExecuteGraphParallel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteGraphParallel(::grpc::ServerContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteGraphParallel(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WaitForExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithRawMethod_WaitForExecution() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_WaitForExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WaitForExecution(::grpc::ServerContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWaitForExecution(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unregister : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Unregister() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::UnregisterRequest, ::xla::UnregisterResponse>(std::bind(&WithStreamedUnaryMethod_Unregister<BaseClass>::StreamedUnregister, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Unregister() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Unregister(::grpc::ServerContext* context, const ::xla::UnregisterRequest* request, ::xla::UnregisterResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnregister(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::UnregisterRequest,::xla::UnregisterResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DeconstructTuple : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DeconstructTuple() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::DeconstructTupleRequest, ::xla::DeconstructTupleResponse>(std::bind(&WithStreamedUnaryMethod_DeconstructTuple<BaseClass>::StreamedDeconstructTuple, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DeconstructTuple() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DeconstructTuple(::grpc::ServerContext* context, const ::xla::DeconstructTupleRequest* request, ::xla::DeconstructTupleResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDeconstructTuple(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::DeconstructTupleRequest,::xla::DeconstructTupleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Unpack : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Unpack() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::UnpackRequest, ::xla::UnpackResponse>(std::bind(&WithStreamedUnaryMethod_Unpack<BaseClass>::StreamedUnpack, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Unpack() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Unpack(::grpc::ServerContext* context, const ::xla::UnpackRequest* request, ::xla::UnpackResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnpack(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::UnpackRequest,::xla::UnpackResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetShape : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetShape() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::GetShapeRequest, ::xla::GetShapeResponse>(std::bind(&WithStreamedUnaryMethod_GetShape<BaseClass>::StreamedGetShape, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetShape() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetShape(::grpc::ServerContext* context, const ::xla::GetShapeRequest* request, ::xla::GetShapeResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetShape(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::GetShapeRequest,::xla::GetShapeResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetComputationGraphStats : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetComputationGraphStats() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::ComputationGraphStatsRequest, ::xla::ComputationStatsResponse>(std::bind(&WithStreamedUnaryMethod_GetComputationGraphStats<BaseClass>::StreamedGetComputationGraphStats, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetComputationGraphStats() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetComputationGraphStats(::grpc::ServerContext* context, const ::xla::ComputationGraphStatsRequest* request, ::xla::ComputationStatsResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetComputationGraphStats(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::ComputationGraphStatsRequest,::xla::ComputationStatsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoadData : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_LoadData() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::LoadDataRequest, ::xla::LoadDataResponse>(std::bind(&WithStreamedUnaryMethod_LoadData<BaseClass>::StreamedLoadData, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_LoadData() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoadData(::grpc::ServerContext* context, const ::xla::LoadDataRequest* request, ::xla::LoadDataResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoadData(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::LoadDataRequest,::xla::LoadDataResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransferToClient : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TransferToClient() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::TransferToClientRequest, ::xla::TransferToClientResponse>(std::bind(&WithStreamedUnaryMethod_TransferToClient<BaseClass>::StreamedTransferToClient, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TransferToClient() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransferToClient(::grpc::ServerContext* context, const ::xla::TransferToClientRequest* request, ::xla::TransferToClientResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransferToClient(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::TransferToClientRequest,::xla::TransferToClientResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransferToServer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TransferToServer() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::TransferToServerRequest, ::xla::TransferToServerResponse>(std::bind(&WithStreamedUnaryMethod_TransferToServer<BaseClass>::StreamedTransferToServer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TransferToServer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransferToServer(::grpc::ServerContext* context, const ::xla::TransferToServerRequest* request, ::xla::TransferToServerResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransferToServer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::TransferToServerRequest,::xla::TransferToServerResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransferToInfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TransferToInfeed() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::TransferToInfeedRequest, ::xla::TransferToInfeedResponse>(std::bind(&WithStreamedUnaryMethod_TransferToInfeed<BaseClass>::StreamedTransferToInfeed, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TransferToInfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransferToInfeed(::grpc::ServerContext* context, const ::xla::TransferToInfeedRequest* request, ::xla::TransferToInfeedResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransferToInfeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::TransferToInfeedRequest,::xla::TransferToInfeedResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TransferFromOutfeed : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_TransferFromOutfeed() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::TransferFromOutfeedRequest, ::xla::TransferFromOutfeedResponse>(std::bind(&WithStreamedUnaryMethod_TransferFromOutfeed<BaseClass>::StreamedTransferFromOutfeed, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_TransferFromOutfeed() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TransferFromOutfeed(::grpc::ServerContext* context, const ::xla::TransferFromOutfeedRequest* request, ::xla::TransferFromOutfeedResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTransferFromOutfeed(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::TransferFromOutfeedRequest,::xla::TransferFromOutfeedResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ResetDevice : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ResetDevice() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::ResetDeviceRequest, ::xla::ResetDeviceResponse>(std::bind(&WithStreamedUnaryMethod_ResetDevice<BaseClass>::StreamedResetDevice, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ResetDevice() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ResetDevice(::grpc::ServerContext* context, const ::xla::ResetDeviceRequest* request, ::xla::ResetDeviceResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedResetDevice(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::ResetDeviceRequest,::xla::ResetDeviceResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ComputeConstantGraph : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ComputeConstantGraph() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::ComputeConstantGraphRequest, ::xla::ComputeConstantResponse>(std::bind(&WithStreamedUnaryMethod_ComputeConstantGraph<BaseClass>::StreamedComputeConstantGraph, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ComputeConstantGraph() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ComputeConstantGraph(::grpc::ServerContext* context, const ::xla::ComputeConstantGraphRequest* request, ::xla::ComputeConstantResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedComputeConstantGraph(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::ComputeConstantGraphRequest,::xla::ComputeConstantResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetDeviceHandles : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetDeviceHandles() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::GetDeviceHandlesRequest, ::xla::GetDeviceHandlesResponse>(std::bind(&WithStreamedUnaryMethod_GetDeviceHandles<BaseClass>::StreamedGetDeviceHandles, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetDeviceHandles() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetDeviceHandles(::grpc::ServerContext* context, const ::xla::GetDeviceHandlesRequest* request, ::xla::GetDeviceHandlesResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetDeviceHandles(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::GetDeviceHandlesRequest,::xla::GetDeviceHandlesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateChannelHandle : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_CreateChannelHandle() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::CreateChannelHandleRequest, ::xla::CreateChannelHandleResponse>(std::bind(&WithStreamedUnaryMethod_CreateChannelHandle<BaseClass>::StreamedCreateChannelHandle, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_CreateChannelHandle() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateChannelHandle(::grpc::ServerContext* context, const ::xla::CreateChannelHandleRequest* request, ::xla::CreateChannelHandleResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateChannelHandle(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::CreateChannelHandleRequest,::xla::CreateChannelHandleResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Compile : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Compile() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::CompileRequest, ::xla::CompileResponse>(std::bind(&WithStreamedUnaryMethod_Compile<BaseClass>::StreamedCompile, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Compile() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Compile(::grpc::ServerContext* context, const ::xla::CompileRequest* request, ::xla::CompileResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCompile(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::CompileRequest,::xla::CompileResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Execute : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Execute() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::ExecuteRequest, ::xla::ExecuteResponse>(std::bind(&WithStreamedUnaryMethod_Execute<BaseClass>::StreamedExecute, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Execute() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Execute(::grpc::ServerContext* context, const ::xla::ExecuteRequest* request, ::xla::ExecuteResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecute(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::ExecuteRequest,::xla::ExecuteResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteGraphParallel : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_ExecuteGraphParallel() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::ExecuteGraphParallelRequest, ::xla::ExecuteParallelResponse>(std::bind(&WithStreamedUnaryMethod_ExecuteGraphParallel<BaseClass>::StreamedExecuteGraphParallel, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ExecuteGraphParallel() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteGraphParallel(::grpc::ServerContext* context, const ::xla::ExecuteGraphParallelRequest* request, ::xla::ExecuteParallelResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteGraphParallel(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::ExecuteGraphParallelRequest,::xla::ExecuteParallelResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WaitForExecution : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_WaitForExecution() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::xla::WaitForExecutionRequest, ::xla::WaitForExecutionResponse>(std::bind(&WithStreamedUnaryMethod_WaitForExecution<BaseClass>::StreamedWaitForExecution, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_WaitForExecution() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WaitForExecution(::grpc::ServerContext* context, const ::xla::WaitForExecutionRequest* request, ::xla::WaitForExecutionResponse* response) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWaitForExecution(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::xla::WaitForExecutionRequest,::xla::WaitForExecutionResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Unregister<WithStreamedUnaryMethod_DeconstructTuple<WithStreamedUnaryMethod_Unpack<WithStreamedUnaryMethod_GetShape<WithStreamedUnaryMethod_GetComputationGraphStats<WithStreamedUnaryMethod_LoadData<WithStreamedUnaryMethod_TransferToClient<WithStreamedUnaryMethod_TransferToServer<WithStreamedUnaryMethod_TransferToInfeed<WithStreamedUnaryMethod_TransferFromOutfeed<WithStreamedUnaryMethod_ResetDevice<WithStreamedUnaryMethod_ComputeConstantGraph<WithStreamedUnaryMethod_GetDeviceHandles<WithStreamedUnaryMethod_CreateChannelHandle<WithStreamedUnaryMethod_Compile<WithStreamedUnaryMethod_Execute<WithStreamedUnaryMethod_ExecuteGraphParallel<WithStreamedUnaryMethod_WaitForExecution<Service > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Unregister<WithStreamedUnaryMethod_DeconstructTuple<WithStreamedUnaryMethod_Unpack<WithStreamedUnaryMethod_GetShape<WithStreamedUnaryMethod_GetComputationGraphStats<WithStreamedUnaryMethod_LoadData<WithStreamedUnaryMethod_TransferToClient<WithStreamedUnaryMethod_TransferToServer<WithStreamedUnaryMethod_TransferToInfeed<WithStreamedUnaryMethod_TransferFromOutfeed<WithStreamedUnaryMethod_ResetDevice<WithStreamedUnaryMethod_ComputeConstantGraph<WithStreamedUnaryMethod_GetDeviceHandles<WithStreamedUnaryMethod_CreateChannelHandle<WithStreamedUnaryMethod_Compile<WithStreamedUnaryMethod_Execute<WithStreamedUnaryMethod_ExecuteGraphParallel<WithStreamedUnaryMethod_WaitForExecution<Service > > > > > > > > > > > > > > > > > > StreamedService;
};
// ///////////////////////
// Global data requests

}  // namespace xla


#endif  // GRPC_tensorflow_2fcompiler_2fxla_2frpc_2fxla_5fservice_2eproto__INCLUDED
