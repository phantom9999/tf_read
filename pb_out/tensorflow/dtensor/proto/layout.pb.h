// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/dtensor/proto/layout.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fdtensor_2fproto_2flayout_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fdtensor_2fproto_2flayout_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fdtensor_2fproto_2flayout_2eproto 

namespace protobuf_tensorflow_2fdtensor_2fproto_2flayout_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[4];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fdtensor_2fproto_2flayout_2eproto
namespace tensorflow {
namespace dtensor {
class LayoutProto;
class LayoutProtoDefaultTypeInternal;
extern LayoutProtoDefaultTypeInternal _LayoutProto_default_instance_;
class MeshDimensionProto;
class MeshDimensionProtoDefaultTypeInternal;
extern MeshDimensionProtoDefaultTypeInternal _MeshDimensionProto_default_instance_;
class MeshProto;
class MeshProtoDefaultTypeInternal;
extern MeshProtoDefaultTypeInternal _MeshProto_default_instance_;
class ShardingSpec;
class ShardingSpecDefaultTypeInternal;
extern ShardingSpecDefaultTypeInternal _ShardingSpec_default_instance_;
}  // namespace dtensor
}  // namespace tensorflow
namespace google {
namespace protobuf {
template<> ::tensorflow::dtensor::LayoutProto* Arena::CreateMaybeMessage<::tensorflow::dtensor::LayoutProto>(Arena*);
template<> ::tensorflow::dtensor::MeshDimensionProto* Arena::CreateMaybeMessage<::tensorflow::dtensor::MeshDimensionProto>(Arena*);
template<> ::tensorflow::dtensor::MeshProto* Arena::CreateMaybeMessage<::tensorflow::dtensor::MeshProto>(Arena*);
template<> ::tensorflow::dtensor::ShardingSpec* Arena::CreateMaybeMessage<::tensorflow::dtensor::ShardingSpec>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace tensorflow {
namespace dtensor {

// ===================================================================

class ShardingSpec : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.dtensor.ShardingSpec) */ {
 public:
  ShardingSpec();
  virtual ~ShardingSpec();

  ShardingSpec(const ShardingSpec& from);

  inline ShardingSpec& operator=(const ShardingSpec& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShardingSpec(ShardingSpec&& from) noexcept
    : ShardingSpec() {
    *this = ::std::move(from);
  }

  inline ShardingSpec& operator=(ShardingSpec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ShardingSpec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ShardingSpec* internal_default_instance() {
    return reinterpret_cast<const ShardingSpec*>(
               &_ShardingSpec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ShardingSpec* other);
  friend void swap(ShardingSpec& a, ShardingSpec& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShardingSpec* New() const final {
    return CreateMaybeMessage<ShardingSpec>(NULL);
  }

  ShardingSpec* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ShardingSpec>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ShardingSpec& from);
  void MergeFrom(const ShardingSpec& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardingSpec* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string sharding_spec = 2;
  void clear_sharding_spec();
  static const int kShardingSpecFieldNumber = 2;
  const ::std::string& sharding_spec() const;
  void set_sharding_spec(const ::std::string& value);
  #if LANG_CXX11
  void set_sharding_spec(::std::string&& value);
  #endif
  void set_sharding_spec(const char* value);
  void set_sharding_spec(const char* value, size_t size);
  ::std::string* mutable_sharding_spec();
  ::std::string* release_sharding_spec();
  void set_allocated_sharding_spec(::std::string* sharding_spec);

  // @@protoc_insertion_point(class_scope:tensorflow.dtensor.ShardingSpec)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr sharding_spec_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fdtensor_2fproto_2flayout_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MeshDimensionProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.dtensor.MeshDimensionProto) */ {
 public:
  MeshDimensionProto();
  virtual ~MeshDimensionProto();

  MeshDimensionProto(const MeshDimensionProto& from);

  inline MeshDimensionProto& operator=(const MeshDimensionProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeshDimensionProto(MeshDimensionProto&& from) noexcept
    : MeshDimensionProto() {
    *this = ::std::move(from);
  }

  inline MeshDimensionProto& operator=(MeshDimensionProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MeshDimensionProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MeshDimensionProto* internal_default_instance() {
    return reinterpret_cast<const MeshDimensionProto*>(
               &_MeshDimensionProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(MeshDimensionProto* other);
  friend void swap(MeshDimensionProto& a, MeshDimensionProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeshDimensionProto* New() const final {
    return CreateMaybeMessage<MeshDimensionProto>(NULL);
  }

  MeshDimensionProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MeshDimensionProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MeshDimensionProto& from);
  void MergeFrom(const MeshDimensionProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeshDimensionProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string name = 1;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 size = 2;
  void clear_size();
  static const int kSizeFieldNumber = 2;
  ::google::protobuf::int64 size() const;
  void set_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:tensorflow.dtensor.MeshDimensionProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fdtensor_2fproto_2flayout_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LayoutProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.dtensor.LayoutProto) */ {
 public:
  LayoutProto();
  virtual ~LayoutProto();

  LayoutProto(const LayoutProto& from);

  inline LayoutProto& operator=(const LayoutProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LayoutProto(LayoutProto&& from) noexcept
    : LayoutProto() {
    *this = ::std::move(from);
  }

  inline LayoutProto& operator=(LayoutProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LayoutProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LayoutProto* internal_default_instance() {
    return reinterpret_cast<const LayoutProto*>(
               &_LayoutProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(LayoutProto* other);
  friend void swap(LayoutProto& a, LayoutProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LayoutProto* New() const final {
    return CreateMaybeMessage<LayoutProto>(NULL);
  }

  LayoutProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LayoutProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LayoutProto& from);
  void MergeFrom(const LayoutProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayoutProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.dtensor.ShardingSpec sharding_specs = 1;
  int sharding_specs_size() const;
  void clear_sharding_specs();
  static const int kShardingSpecsFieldNumber = 1;
  ::tensorflow::dtensor::ShardingSpec* mutable_sharding_specs(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::dtensor::ShardingSpec >*
      mutable_sharding_specs();
  const ::tensorflow::dtensor::ShardingSpec& sharding_specs(int index) const;
  ::tensorflow::dtensor::ShardingSpec* add_sharding_specs();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::dtensor::ShardingSpec >&
      sharding_specs() const;

  // .tensorflow.dtensor.MeshProto mesh_config = 2;
  bool has_mesh_config() const;
  void clear_mesh_config();
  static const int kMeshConfigFieldNumber = 2;
  private:
  const ::tensorflow::dtensor::MeshProto& _internal_mesh_config() const;
  public:
  const ::tensorflow::dtensor::MeshProto& mesh_config() const;
  ::tensorflow::dtensor::MeshProto* release_mesh_config();
  ::tensorflow::dtensor::MeshProto* mutable_mesh_config();
  void set_allocated_mesh_config(::tensorflow::dtensor::MeshProto* mesh_config);

  // @@protoc_insertion_point(class_scope:tensorflow.dtensor.LayoutProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::dtensor::ShardingSpec > sharding_specs_;
  ::tensorflow::dtensor::MeshProto* mesh_config_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fdtensor_2fproto_2flayout_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MeshProto : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tensorflow.dtensor.MeshProto) */ {
 public:
  MeshProto();
  virtual ~MeshProto();

  MeshProto(const MeshProto& from);

  inline MeshProto& operator=(const MeshProto& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MeshProto(MeshProto&& from) noexcept
    : MeshProto() {
    *this = ::std::move(from);
  }

  inline MeshProto& operator=(MeshProto&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MeshProto& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MeshProto* internal_default_instance() {
    return reinterpret_cast<const MeshProto*>(
               &_MeshProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(MeshProto* other);
  friend void swap(MeshProto& a, MeshProto& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MeshProto* New() const final {
    return CreateMaybeMessage<MeshProto>(NULL);
  }

  MeshProto* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MeshProto>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MeshProto& from);
  void MergeFrom(const MeshProto& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MeshProto* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .tensorflow.dtensor.MeshDimensionProto mesh_dimensions = 1;
  int mesh_dimensions_size() const;
  void clear_mesh_dimensions();
  static const int kMeshDimensionsFieldNumber = 1;
  ::tensorflow::dtensor::MeshDimensionProto* mutable_mesh_dimensions(int index);
  ::google::protobuf::RepeatedPtrField< ::tensorflow::dtensor::MeshDimensionProto >*
      mutable_mesh_dimensions();
  const ::tensorflow::dtensor::MeshDimensionProto& mesh_dimensions(int index) const;
  ::tensorflow::dtensor::MeshDimensionProto* add_mesh_dimensions();
  const ::google::protobuf::RepeatedPtrField< ::tensorflow::dtensor::MeshDimensionProto >&
      mesh_dimensions() const;

  // repeated int64 global_device_ids = 2;
  int global_device_ids_size() const;
  void clear_global_device_ids();
  static const int kGlobalDeviceIdsFieldNumber = 2;
  ::google::protobuf::int64 global_device_ids(int index) const;
  void set_global_device_ids(int index, ::google::protobuf::int64 value);
  void add_global_device_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      global_device_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_global_device_ids();

  // repeated int64 local_device_ids = 4;
  int local_device_ids_size() const;
  void clear_local_device_ids();
  static const int kLocalDeviceIdsFieldNumber = 4;
  ::google::protobuf::int64 local_device_ids(int index) const;
  void set_local_device_ids(int index, ::google::protobuf::int64 value);
  void add_local_device_ids(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      local_device_ids() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_local_device_ids();

  // repeated string local_devices = 5;
  int local_devices_size() const;
  void clear_local_devices();
  static const int kLocalDevicesFieldNumber = 5;
  const ::std::string& local_devices(int index) const;
  ::std::string* mutable_local_devices(int index);
  void set_local_devices(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_local_devices(int index, ::std::string&& value);
  #endif
  void set_local_devices(int index, const char* value);
  void set_local_devices(int index, const char* value, size_t size);
  ::std::string* add_local_devices();
  void add_local_devices(const ::std::string& value);
  #if LANG_CXX11
  void add_local_devices(::std::string&& value);
  #endif
  void add_local_devices(const char* value);
  void add_local_devices(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& local_devices() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_local_devices();

  // repeated string global_devices = 6;
  int global_devices_size() const;
  void clear_global_devices();
  static const int kGlobalDevicesFieldNumber = 6;
  const ::std::string& global_devices(int index) const;
  ::std::string* mutable_global_devices(int index);
  void set_global_devices(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_global_devices(int index, ::std::string&& value);
  #endif
  void set_global_devices(int index, const char* value);
  void set_global_devices(int index, const char* value, size_t size);
  ::std::string* add_global_devices();
  void add_global_devices(const ::std::string& value);
  #if LANG_CXX11
  void add_global_devices(::std::string&& value);
  #endif
  void add_global_devices(const char* value);
  void add_global_devices(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& global_devices() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_global_devices();

  // string name = 3;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:tensorflow.dtensor.MeshProto)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::tensorflow::dtensor::MeshDimensionProto > mesh_dimensions_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > global_device_ids_;
  mutable int _global_device_ids_cached_byte_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > local_device_ids_;
  mutable int _local_device_ids_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> local_devices_;
  ::google::protobuf::RepeatedPtrField< ::std::string> global_devices_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fdtensor_2fproto_2flayout_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ShardingSpec

// string sharding_spec = 2;
inline void ShardingSpec::clear_sharding_spec() {
  sharding_spec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ShardingSpec::sharding_spec() const {
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.ShardingSpec.sharding_spec)
  return sharding_spec_.GetNoArena();
}
inline void ShardingSpec::set_sharding_spec(const ::std::string& value) {
  
  sharding_spec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.dtensor.ShardingSpec.sharding_spec)
}
#if LANG_CXX11
inline void ShardingSpec::set_sharding_spec(::std::string&& value) {
  
  sharding_spec_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.dtensor.ShardingSpec.sharding_spec)
}
#endif
inline void ShardingSpec::set_sharding_spec(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  sharding_spec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.dtensor.ShardingSpec.sharding_spec)
}
inline void ShardingSpec::set_sharding_spec(const char* value, size_t size) {
  
  sharding_spec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.dtensor.ShardingSpec.sharding_spec)
}
inline ::std::string* ShardingSpec::mutable_sharding_spec() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.dtensor.ShardingSpec.sharding_spec)
  return sharding_spec_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ShardingSpec::release_sharding_spec() {
  // @@protoc_insertion_point(field_release:tensorflow.dtensor.ShardingSpec.sharding_spec)
  
  return sharding_spec_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ShardingSpec::set_allocated_sharding_spec(::std::string* sharding_spec) {
  if (sharding_spec != NULL) {
    
  } else {
    
  }
  sharding_spec_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), sharding_spec);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.dtensor.ShardingSpec.sharding_spec)
}

// -------------------------------------------------------------------

// MeshDimensionProto

// string name = 1;
inline void MeshDimensionProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MeshDimensionProto::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.MeshDimensionProto.name)
  return name_.GetNoArena();
}
inline void MeshDimensionProto::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.dtensor.MeshDimensionProto.name)
}
#if LANG_CXX11
inline void MeshDimensionProto::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.dtensor.MeshDimensionProto.name)
}
#endif
inline void MeshDimensionProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.dtensor.MeshDimensionProto.name)
}
inline void MeshDimensionProto::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.dtensor.MeshDimensionProto.name)
}
inline ::std::string* MeshDimensionProto::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.dtensor.MeshDimensionProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeshDimensionProto::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.dtensor.MeshDimensionProto.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeshDimensionProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.dtensor.MeshDimensionProto.name)
}

// int64 size = 2;
inline void MeshDimensionProto::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 MeshDimensionProto::size() const {
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.MeshDimensionProto.size)
  return size_;
}
inline void MeshDimensionProto::set_size(::google::protobuf::int64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:tensorflow.dtensor.MeshDimensionProto.size)
}

// -------------------------------------------------------------------

// LayoutProto

// repeated .tensorflow.dtensor.ShardingSpec sharding_specs = 1;
inline int LayoutProto::sharding_specs_size() const {
  return sharding_specs_.size();
}
inline void LayoutProto::clear_sharding_specs() {
  sharding_specs_.Clear();
}
inline ::tensorflow::dtensor::ShardingSpec* LayoutProto::mutable_sharding_specs(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.dtensor.LayoutProto.sharding_specs)
  return sharding_specs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::dtensor::ShardingSpec >*
LayoutProto::mutable_sharding_specs() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.dtensor.LayoutProto.sharding_specs)
  return &sharding_specs_;
}
inline const ::tensorflow::dtensor::ShardingSpec& LayoutProto::sharding_specs(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.LayoutProto.sharding_specs)
  return sharding_specs_.Get(index);
}
inline ::tensorflow::dtensor::ShardingSpec* LayoutProto::add_sharding_specs() {
  // @@protoc_insertion_point(field_add:tensorflow.dtensor.LayoutProto.sharding_specs)
  return sharding_specs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::dtensor::ShardingSpec >&
LayoutProto::sharding_specs() const {
  // @@protoc_insertion_point(field_list:tensorflow.dtensor.LayoutProto.sharding_specs)
  return sharding_specs_;
}

// .tensorflow.dtensor.MeshProto mesh_config = 2;
inline bool LayoutProto::has_mesh_config() const {
  return this != internal_default_instance() && mesh_config_ != NULL;
}
inline void LayoutProto::clear_mesh_config() {
  if (GetArenaNoVirtual() == NULL && mesh_config_ != NULL) {
    delete mesh_config_;
  }
  mesh_config_ = NULL;
}
inline const ::tensorflow::dtensor::MeshProto& LayoutProto::_internal_mesh_config() const {
  return *mesh_config_;
}
inline const ::tensorflow::dtensor::MeshProto& LayoutProto::mesh_config() const {
  const ::tensorflow::dtensor::MeshProto* p = mesh_config_;
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.LayoutProto.mesh_config)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::dtensor::MeshProto*>(
      &::tensorflow::dtensor::_MeshProto_default_instance_);
}
inline ::tensorflow::dtensor::MeshProto* LayoutProto::release_mesh_config() {
  // @@protoc_insertion_point(field_release:tensorflow.dtensor.LayoutProto.mesh_config)
  
  ::tensorflow::dtensor::MeshProto* temp = mesh_config_;
  mesh_config_ = NULL;
  return temp;
}
inline ::tensorflow::dtensor::MeshProto* LayoutProto::mutable_mesh_config() {
  
  if (mesh_config_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::dtensor::MeshProto>(GetArenaNoVirtual());
    mesh_config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:tensorflow.dtensor.LayoutProto.mesh_config)
  return mesh_config_;
}
inline void LayoutProto::set_allocated_mesh_config(::tensorflow::dtensor::MeshProto* mesh_config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete mesh_config_;
  }
  if (mesh_config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      mesh_config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, mesh_config, submessage_arena);
    }
    
  } else {
    
  }
  mesh_config_ = mesh_config;
  // @@protoc_insertion_point(field_set_allocated:tensorflow.dtensor.LayoutProto.mesh_config)
}

// -------------------------------------------------------------------

// MeshProto

// repeated .tensorflow.dtensor.MeshDimensionProto mesh_dimensions = 1;
inline int MeshProto::mesh_dimensions_size() const {
  return mesh_dimensions_.size();
}
inline void MeshProto::clear_mesh_dimensions() {
  mesh_dimensions_.Clear();
}
inline ::tensorflow::dtensor::MeshDimensionProto* MeshProto::mutable_mesh_dimensions(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.dtensor.MeshProto.mesh_dimensions)
  return mesh_dimensions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::tensorflow::dtensor::MeshDimensionProto >*
MeshProto::mutable_mesh_dimensions() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.dtensor.MeshProto.mesh_dimensions)
  return &mesh_dimensions_;
}
inline const ::tensorflow::dtensor::MeshDimensionProto& MeshProto::mesh_dimensions(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.MeshProto.mesh_dimensions)
  return mesh_dimensions_.Get(index);
}
inline ::tensorflow::dtensor::MeshDimensionProto* MeshProto::add_mesh_dimensions() {
  // @@protoc_insertion_point(field_add:tensorflow.dtensor.MeshProto.mesh_dimensions)
  return mesh_dimensions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tensorflow::dtensor::MeshDimensionProto >&
MeshProto::mesh_dimensions() const {
  // @@protoc_insertion_point(field_list:tensorflow.dtensor.MeshProto.mesh_dimensions)
  return mesh_dimensions_;
}

// repeated int64 global_device_ids = 2;
inline int MeshProto::global_device_ids_size() const {
  return global_device_ids_.size();
}
inline void MeshProto::clear_global_device_ids() {
  global_device_ids_.Clear();
}
inline ::google::protobuf::int64 MeshProto::global_device_ids(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.MeshProto.global_device_ids)
  return global_device_ids_.Get(index);
}
inline void MeshProto::set_global_device_ids(int index, ::google::protobuf::int64 value) {
  global_device_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.dtensor.MeshProto.global_device_ids)
}
inline void MeshProto::add_global_device_ids(::google::protobuf::int64 value) {
  global_device_ids_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.dtensor.MeshProto.global_device_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
MeshProto::global_device_ids() const {
  // @@protoc_insertion_point(field_list:tensorflow.dtensor.MeshProto.global_device_ids)
  return global_device_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
MeshProto::mutable_global_device_ids() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.dtensor.MeshProto.global_device_ids)
  return &global_device_ids_;
}

// repeated int64 local_device_ids = 4;
inline int MeshProto::local_device_ids_size() const {
  return local_device_ids_.size();
}
inline void MeshProto::clear_local_device_ids() {
  local_device_ids_.Clear();
}
inline ::google::protobuf::int64 MeshProto::local_device_ids(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.MeshProto.local_device_ids)
  return local_device_ids_.Get(index);
}
inline void MeshProto::set_local_device_ids(int index, ::google::protobuf::int64 value) {
  local_device_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:tensorflow.dtensor.MeshProto.local_device_ids)
}
inline void MeshProto::add_local_device_ids(::google::protobuf::int64 value) {
  local_device_ids_.Add(value);
  // @@protoc_insertion_point(field_add:tensorflow.dtensor.MeshProto.local_device_ids)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
MeshProto::local_device_ids() const {
  // @@protoc_insertion_point(field_list:tensorflow.dtensor.MeshProto.local_device_ids)
  return local_device_ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
MeshProto::mutable_local_device_ids() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.dtensor.MeshProto.local_device_ids)
  return &local_device_ids_;
}

// repeated string local_devices = 5;
inline int MeshProto::local_devices_size() const {
  return local_devices_.size();
}
inline void MeshProto::clear_local_devices() {
  local_devices_.Clear();
}
inline const ::std::string& MeshProto::local_devices(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.MeshProto.local_devices)
  return local_devices_.Get(index);
}
inline ::std::string* MeshProto::mutable_local_devices(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.dtensor.MeshProto.local_devices)
  return local_devices_.Mutable(index);
}
inline void MeshProto::set_local_devices(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.dtensor.MeshProto.local_devices)
  local_devices_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MeshProto::set_local_devices(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.dtensor.MeshProto.local_devices)
  local_devices_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MeshProto::set_local_devices(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  local_devices_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.dtensor.MeshProto.local_devices)
}
inline void MeshProto::set_local_devices(int index, const char* value, size_t size) {
  local_devices_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.dtensor.MeshProto.local_devices)
}
inline ::std::string* MeshProto::add_local_devices() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.dtensor.MeshProto.local_devices)
  return local_devices_.Add();
}
inline void MeshProto::add_local_devices(const ::std::string& value) {
  local_devices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.dtensor.MeshProto.local_devices)
}
#if LANG_CXX11
inline void MeshProto::add_local_devices(::std::string&& value) {
  local_devices_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.dtensor.MeshProto.local_devices)
}
#endif
inline void MeshProto::add_local_devices(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  local_devices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.dtensor.MeshProto.local_devices)
}
inline void MeshProto::add_local_devices(const char* value, size_t size) {
  local_devices_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.dtensor.MeshProto.local_devices)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MeshProto::local_devices() const {
  // @@protoc_insertion_point(field_list:tensorflow.dtensor.MeshProto.local_devices)
  return local_devices_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MeshProto::mutable_local_devices() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.dtensor.MeshProto.local_devices)
  return &local_devices_;
}

// repeated string global_devices = 6;
inline int MeshProto::global_devices_size() const {
  return global_devices_.size();
}
inline void MeshProto::clear_global_devices() {
  global_devices_.Clear();
}
inline const ::std::string& MeshProto::global_devices(int index) const {
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.MeshProto.global_devices)
  return global_devices_.Get(index);
}
inline ::std::string* MeshProto::mutable_global_devices(int index) {
  // @@protoc_insertion_point(field_mutable:tensorflow.dtensor.MeshProto.global_devices)
  return global_devices_.Mutable(index);
}
inline void MeshProto::set_global_devices(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tensorflow.dtensor.MeshProto.global_devices)
  global_devices_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MeshProto::set_global_devices(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tensorflow.dtensor.MeshProto.global_devices)
  global_devices_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MeshProto::set_global_devices(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  global_devices_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tensorflow.dtensor.MeshProto.global_devices)
}
inline void MeshProto::set_global_devices(int index, const char* value, size_t size) {
  global_devices_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tensorflow.dtensor.MeshProto.global_devices)
}
inline ::std::string* MeshProto::add_global_devices() {
  // @@protoc_insertion_point(field_add_mutable:tensorflow.dtensor.MeshProto.global_devices)
  return global_devices_.Add();
}
inline void MeshProto::add_global_devices(const ::std::string& value) {
  global_devices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tensorflow.dtensor.MeshProto.global_devices)
}
#if LANG_CXX11
inline void MeshProto::add_global_devices(::std::string&& value) {
  global_devices_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tensorflow.dtensor.MeshProto.global_devices)
}
#endif
inline void MeshProto::add_global_devices(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  global_devices_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tensorflow.dtensor.MeshProto.global_devices)
}
inline void MeshProto::add_global_devices(const char* value, size_t size) {
  global_devices_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tensorflow.dtensor.MeshProto.global_devices)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MeshProto::global_devices() const {
  // @@protoc_insertion_point(field_list:tensorflow.dtensor.MeshProto.global_devices)
  return global_devices_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MeshProto::mutable_global_devices() {
  // @@protoc_insertion_point(field_mutable_list:tensorflow.dtensor.MeshProto.global_devices)
  return &global_devices_;
}

// string name = 3;
inline void MeshProto::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MeshProto::name() const {
  // @@protoc_insertion_point(field_get:tensorflow.dtensor.MeshProto.name)
  return name_.GetNoArena();
}
inline void MeshProto::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tensorflow.dtensor.MeshProto.name)
}
#if LANG_CXX11
inline void MeshProto::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tensorflow.dtensor.MeshProto.name)
}
#endif
inline void MeshProto::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tensorflow.dtensor.MeshProto.name)
}
inline void MeshProto::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tensorflow.dtensor.MeshProto.name)
}
inline ::std::string* MeshProto::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:tensorflow.dtensor.MeshProto.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MeshProto::release_name() {
  // @@protoc_insertion_point(field_release:tensorflow.dtensor.MeshProto.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MeshProto::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tensorflow.dtensor.MeshProto.name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dtensor
}  // namespace tensorflow

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fdtensor_2fproto_2flayout_2eproto
