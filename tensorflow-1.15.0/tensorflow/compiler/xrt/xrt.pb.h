// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/compiler/xrt/xrt.proto

#ifndef PROTOBUF_INCLUDED_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto
#define PROTOBUF_INCLUDED_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "tensorflow/compiler/tf2xla/host_compute_metadata.pb.h"
#include "tensorflow/compiler/xla/service/hlo.pb.h"
#include "tensorflow/compiler/xla/xla.pb.h"
#include "tensorflow/compiler/xla/xla_data.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto 

namespace protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[13];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto
namespace xrt {
class DeviceAssignment;
class DeviceAssignmentDefaultTypeInternal;
extern DeviceAssignmentDefaultTypeInternal _DeviceAssignment_default_instance_;
class DeviceAssignment_ComputationDevice;
class DeviceAssignment_ComputationDeviceDefaultTypeInternal;
extern DeviceAssignment_ComputationDeviceDefaultTypeInternal _DeviceAssignment_ComputationDevice_default_instance_;
class DeviceAssignment_ComputationDevice_DeviceMeshCoordinates;
class DeviceAssignment_ComputationDevice_DeviceMeshCoordinatesDefaultTypeInternal;
extern DeviceAssignment_ComputationDevice_DeviceMeshCoordinatesDefaultTypeInternal _DeviceAssignment_ComputationDevice_DeviceMeshCoordinates_default_instance_;
class XLAAllocation;
class XLAAllocationDefaultTypeInternal;
extern XLAAllocationDefaultTypeInternal _XLAAllocation_default_instance_;
class XLAComputation;
class XLAComputationDefaultTypeInternal;
extern XLAComputationDefaultTypeInternal _XLAComputation_default_instance_;
class XLAComputationConfig;
class XLAComputationConfigDefaultTypeInternal;
extern XLAComputationConfigDefaultTypeInternal _XLAComputationConfig_default_instance_;
class XLATupleNode;
class XLATupleNodeDefaultTypeInternal;
extern XLATupleNodeDefaultTypeInternal _XLATupleNode_default_instance_;
class XRTChainedExecuteConfig;
class XRTChainedExecuteConfigDefaultTypeInternal;
extern XRTChainedExecuteConfigDefaultTypeInternal _XRTChainedExecuteConfig_default_instance_;
class XRTChainedExecuteOp;
class XRTChainedExecuteOpDefaultTypeInternal;
extern XRTChainedExecuteOpDefaultTypeInternal _XRTChainedExecuteOp_default_instance_;
class XRTChainedExecuteOp_Input;
class XRTChainedExecuteOp_InputDefaultTypeInternal;
extern XRTChainedExecuteOp_InputDefaultTypeInternal _XRTChainedExecuteOp_Input_default_instance_;
class XRTChainedExecuteOp_Output;
class XRTChainedExecuteOp_OutputDefaultTypeInternal;
extern XRTChainedExecuteOp_OutputDefaultTypeInternal _XRTChainedExecuteOp_Output_default_instance_;
class XRTChainedExecutePlan;
class XRTChainedExecutePlanDefaultTypeInternal;
extern XRTChainedExecutePlanDefaultTypeInternal _XRTChainedExecutePlan_default_instance_;
class XRTExecutionConfig;
class XRTExecutionConfigDefaultTypeInternal;
extern XRTExecutionConfigDefaultTypeInternal _XRTExecutionConfig_default_instance_;
}  // namespace xrt
namespace google {
namespace protobuf {
template<> ::xrt::DeviceAssignment* Arena::CreateMaybeMessage<::xrt::DeviceAssignment>(Arena*);
template<> ::xrt::DeviceAssignment_ComputationDevice* Arena::CreateMaybeMessage<::xrt::DeviceAssignment_ComputationDevice>(Arena*);
template<> ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates* Arena::CreateMaybeMessage<::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates>(Arena*);
template<> ::xrt::XLAAllocation* Arena::CreateMaybeMessage<::xrt::XLAAllocation>(Arena*);
template<> ::xrt::XLAComputation* Arena::CreateMaybeMessage<::xrt::XLAComputation>(Arena*);
template<> ::xrt::XLAComputationConfig* Arena::CreateMaybeMessage<::xrt::XLAComputationConfig>(Arena*);
template<> ::xrt::XLATupleNode* Arena::CreateMaybeMessage<::xrt::XLATupleNode>(Arena*);
template<> ::xrt::XRTChainedExecuteConfig* Arena::CreateMaybeMessage<::xrt::XRTChainedExecuteConfig>(Arena*);
template<> ::xrt::XRTChainedExecuteOp* Arena::CreateMaybeMessage<::xrt::XRTChainedExecuteOp>(Arena*);
template<> ::xrt::XRTChainedExecuteOp_Input* Arena::CreateMaybeMessage<::xrt::XRTChainedExecuteOp_Input>(Arena*);
template<> ::xrt::XRTChainedExecuteOp_Output* Arena::CreateMaybeMessage<::xrt::XRTChainedExecuteOp_Output>(Arena*);
template<> ::xrt::XRTChainedExecutePlan* Arena::CreateMaybeMessage<::xrt::XRTChainedExecutePlan>(Arena*);
template<> ::xrt::XRTExecutionConfig* Arena::CreateMaybeMessage<::xrt::XRTExecutionConfig>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace xrt {

// ===================================================================

class DeviceAssignment_ComputationDevice_DeviceMeshCoordinates : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.DeviceAssignment.ComputationDevice.DeviceMeshCoordinates) */ {
 public:
  DeviceAssignment_ComputationDevice_DeviceMeshCoordinates();
  virtual ~DeviceAssignment_ComputationDevice_DeviceMeshCoordinates();

  DeviceAssignment_ComputationDevice_DeviceMeshCoordinates(const DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& from);

  inline DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& operator=(const DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceAssignment_ComputationDevice_DeviceMeshCoordinates(DeviceAssignment_ComputationDevice_DeviceMeshCoordinates&& from) noexcept
    : DeviceAssignment_ComputationDevice_DeviceMeshCoordinates() {
    *this = ::std::move(from);
  }

  inline DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& operator=(DeviceAssignment_ComputationDevice_DeviceMeshCoordinates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceAssignment_ComputationDevice_DeviceMeshCoordinates* internal_default_instance() {
    return reinterpret_cast<const DeviceAssignment_ComputationDevice_DeviceMeshCoordinates*>(
               &_DeviceAssignment_ComputationDevice_DeviceMeshCoordinates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(DeviceAssignment_ComputationDevice_DeviceMeshCoordinates* other);
  friend void swap(DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& a, DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceAssignment_ComputationDevice_DeviceMeshCoordinates* New() const final {
    return CreateMaybeMessage<DeviceAssignment_ComputationDevice_DeviceMeshCoordinates>(NULL);
  }

  DeviceAssignment_ComputationDevice_DeviceMeshCoordinates* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeviceAssignment_ComputationDevice_DeviceMeshCoordinates>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& from);
  void MergeFrom(const DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceAssignment_ComputationDevice_DeviceMeshCoordinates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 value = 1;
  int value_size() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value(int index) const;
  void set_value(int index, ::google::protobuf::int32 value);
  void add_value(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      value() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_value();

  // @@protoc_insertion_point(class_scope:xrt.DeviceAssignment.ComputationDevice.DeviceMeshCoordinates)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > value_;
  mutable int _value_cached_byte_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeviceAssignment_ComputationDevice : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.DeviceAssignment.ComputationDevice) */ {
 public:
  DeviceAssignment_ComputationDevice();
  virtual ~DeviceAssignment_ComputationDevice();

  DeviceAssignment_ComputationDevice(const DeviceAssignment_ComputationDevice& from);

  inline DeviceAssignment_ComputationDevice& operator=(const DeviceAssignment_ComputationDevice& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceAssignment_ComputationDevice(DeviceAssignment_ComputationDevice&& from) noexcept
    : DeviceAssignment_ComputationDevice() {
    *this = ::std::move(from);
  }

  inline DeviceAssignment_ComputationDevice& operator=(DeviceAssignment_ComputationDevice&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceAssignment_ComputationDevice& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceAssignment_ComputationDevice* internal_default_instance() {
    return reinterpret_cast<const DeviceAssignment_ComputationDevice*>(
               &_DeviceAssignment_ComputationDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DeviceAssignment_ComputationDevice* other);
  friend void swap(DeviceAssignment_ComputationDevice& a, DeviceAssignment_ComputationDevice& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceAssignment_ComputationDevice* New() const final {
    return CreateMaybeMessage<DeviceAssignment_ComputationDevice>(NULL);
  }

  DeviceAssignment_ComputationDevice* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeviceAssignment_ComputationDevice>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeviceAssignment_ComputationDevice& from);
  void MergeFrom(const DeviceAssignment_ComputationDevice& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceAssignment_ComputationDevice* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeviceAssignment_ComputationDevice_DeviceMeshCoordinates DeviceMeshCoordinates;

  // accessors -------------------------------------------------------

  // repeated .xrt.DeviceAssignment.ComputationDevice.DeviceMeshCoordinates replica_devices = 1;
  int replica_devices_size() const;
  void clear_replica_devices();
  static const int kReplicaDevicesFieldNumber = 1;
  ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates* mutable_replica_devices(int index);
  ::google::protobuf::RepeatedPtrField< ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates >*
      mutable_replica_devices();
  const ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& replica_devices(int index) const;
  ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates* add_replica_devices();
  const ::google::protobuf::RepeatedPtrField< ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates >&
      replica_devices() const;

  // @@protoc_insertion_point(class_scope:xrt.DeviceAssignment.ComputationDevice)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates > replica_devices_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeviceAssignment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.DeviceAssignment) */ {
 public:
  DeviceAssignment();
  virtual ~DeviceAssignment();

  DeviceAssignment(const DeviceAssignment& from);

  inline DeviceAssignment& operator=(const DeviceAssignment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeviceAssignment(DeviceAssignment&& from) noexcept
    : DeviceAssignment() {
    *this = ::std::move(from);
  }

  inline DeviceAssignment& operator=(DeviceAssignment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceAssignment& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeviceAssignment* internal_default_instance() {
    return reinterpret_cast<const DeviceAssignment*>(
               &_DeviceAssignment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DeviceAssignment* other);
  friend void swap(DeviceAssignment& a, DeviceAssignment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeviceAssignment* New() const final {
    return CreateMaybeMessage<DeviceAssignment>(NULL);
  }

  DeviceAssignment* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeviceAssignment>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeviceAssignment& from);
  void MergeFrom(const DeviceAssignment& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceAssignment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeviceAssignment_ComputationDevice ComputationDevice;

  // accessors -------------------------------------------------------

  // repeated .xrt.DeviceAssignment.ComputationDevice computation_devices = 1;
  int computation_devices_size() const;
  void clear_computation_devices();
  static const int kComputationDevicesFieldNumber = 1;
  ::xrt::DeviceAssignment_ComputationDevice* mutable_computation_devices(int index);
  ::google::protobuf::RepeatedPtrField< ::xrt::DeviceAssignment_ComputationDevice >*
      mutable_computation_devices();
  const ::xrt::DeviceAssignment_ComputationDevice& computation_devices(int index) const;
  ::xrt::DeviceAssignment_ComputationDevice* add_computation_devices();
  const ::google::protobuf::RepeatedPtrField< ::xrt::DeviceAssignment_ComputationDevice >&
      computation_devices() const;

  // @@protoc_insertion_point(class_scope:xrt.DeviceAssignment)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xrt::DeviceAssignment_ComputationDevice > computation_devices_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XLAComputationConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.XLAComputationConfig) */ {
 public:
  XLAComputationConfig();
  virtual ~XLAComputationConfig();

  XLAComputationConfig(const XLAComputationConfig& from);

  inline XLAComputationConfig& operator=(const XLAComputationConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XLAComputationConfig(XLAComputationConfig&& from) noexcept
    : XLAComputationConfig() {
    *this = ::std::move(from);
  }

  inline XLAComputationConfig& operator=(XLAComputationConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XLAComputationConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XLAComputationConfig* internal_default_instance() {
    return reinterpret_cast<const XLAComputationConfig*>(
               &_XLAComputationConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(XLAComputationConfig* other);
  friend void swap(XLAComputationConfig& a, XLAComputationConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XLAComputationConfig* New() const final {
    return CreateMaybeMessage<XLAComputationConfig>(NULL);
  }

  XLAComputationConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XLAComputationConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XLAComputationConfig& from);
  void MergeFrom(const XLAComputationConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XLAComputationConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xla.ProgramShapeProto per_core_program_shape = 5;
  int per_core_program_shape_size() const;
  void clear_per_core_program_shape();
  static const int kPerCoreProgramShapeFieldNumber = 5;
  ::xla::ProgramShapeProto* mutable_per_core_program_shape(int index);
  ::google::protobuf::RepeatedPtrField< ::xla::ProgramShapeProto >*
      mutable_per_core_program_shape();
  const ::xla::ProgramShapeProto& per_core_program_shape(int index) const;
  ::xla::ProgramShapeProto* add_per_core_program_shape();
  const ::google::protobuf::RepeatedPtrField< ::xla::ProgramShapeProto >&
      per_core_program_shape() const;

  // .tensorflow.tf2xla.HostComputeMetadata host_compute_metadata = 3;
  bool has_host_compute_metadata() const;
  void clear_host_compute_metadata();
  static const int kHostComputeMetadataFieldNumber = 3;
  private:
  const ::tensorflow::tf2xla::HostComputeMetadata& _internal_host_compute_metadata() const;
  public:
  const ::tensorflow::tf2xla::HostComputeMetadata& host_compute_metadata() const;
  ::tensorflow::tf2xla::HostComputeMetadata* release_host_compute_metadata();
  ::tensorflow::tf2xla::HostComputeMetadata* mutable_host_compute_metadata();
  void set_allocated_host_compute_metadata(::tensorflow::tf2xla::HostComputeMetadata* host_compute_metadata);

  // .xla.ProgramShapeProto program_shape = 4;
  bool has_program_shape() const;
  void clear_program_shape();
  static const int kProgramShapeFieldNumber = 4;
  private:
  const ::xla::ProgramShapeProto& _internal_program_shape() const;
  public:
  const ::xla::ProgramShapeProto& program_shape() const;
  ::xla::ProgramShapeProto* release_program_shape();
  ::xla::ProgramShapeProto* mutable_program_shape();
  void set_allocated_program_shape(::xla::ProgramShapeProto* program_shape);

  // .xrt.DeviceAssignment device_assignment = 6;
  bool has_device_assignment() const;
  void clear_device_assignment();
  static const int kDeviceAssignmentFieldNumber = 6;
  private:
  const ::xrt::DeviceAssignment& _internal_device_assignment() const;
  public:
  const ::xrt::DeviceAssignment& device_assignment() const;
  ::xrt::DeviceAssignment* release_device_assignment();
  ::xrt::DeviceAssignment* mutable_device_assignment();
  void set_allocated_device_assignment(::xrt::DeviceAssignment* device_assignment);

  // .xla.DebugOptions debug_options = 7;
  bool has_debug_options() const;
  void clear_debug_options();
  static const int kDebugOptionsFieldNumber = 7;
  private:
  const ::xla::DebugOptions& _internal_debug_options() const;
  public:
  const ::xla::DebugOptions& debug_options() const;
  ::xla::DebugOptions* release_debug_options();
  ::xla::DebugOptions* mutable_debug_options();
  void set_allocated_debug_options(::xla::DebugOptions* debug_options);

  // int32 num_replicas = 1;
  void clear_num_replicas();
  static const int kNumReplicasFieldNumber = 1;
  ::google::protobuf::int32 num_replicas() const;
  void set_num_replicas(::google::protobuf::int32 value);

  // int32 num_cores_per_replica = 2;
  void clear_num_cores_per_replica();
  static const int kNumCoresPerReplicaFieldNumber = 2;
  ::google::protobuf::int32 num_cores_per_replica() const;
  void set_num_cores_per_replica(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xrt.XLAComputationConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xla::ProgramShapeProto > per_core_program_shape_;
  ::tensorflow::tf2xla::HostComputeMetadata* host_compute_metadata_;
  ::xla::ProgramShapeProto* program_shape_;
  ::xrt::DeviceAssignment* device_assignment_;
  ::xla::DebugOptions* debug_options_;
  ::google::protobuf::int32 num_replicas_;
  ::google::protobuf::int32 num_cores_per_replica_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XLAComputation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.XLAComputation) */ {
 public:
  XLAComputation();
  virtual ~XLAComputation();

  XLAComputation(const XLAComputation& from);

  inline XLAComputation& operator=(const XLAComputation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XLAComputation(XLAComputation&& from) noexcept
    : XLAComputation() {
    *this = ::std::move(from);
  }

  inline XLAComputation& operator=(XLAComputation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XLAComputation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XLAComputation* internal_default_instance() {
    return reinterpret_cast<const XLAComputation*>(
               &_XLAComputation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(XLAComputation* other);
  friend void swap(XLAComputation& a, XLAComputation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XLAComputation* New() const final {
    return CreateMaybeMessage<XLAComputation>(NULL);
  }

  XLAComputation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XLAComputation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XLAComputation& from);
  void MergeFrom(const XLAComputation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XLAComputation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xrt.XLAComputationConfig config = 1;
  bool has_config() const;
  void clear_config();
  static const int kConfigFieldNumber = 1;
  private:
  const ::xrt::XLAComputationConfig& _internal_config() const;
  public:
  const ::xrt::XLAComputationConfig& config() const;
  ::xrt::XLAComputationConfig* release_config();
  ::xrt::XLAComputationConfig* mutable_config();
  void set_allocated_config(::xrt::XLAComputationConfig* config);

  // .xla.HloSnapshot hlo_snapshot = 2;
  bool has_hlo_snapshot() const;
  void clear_hlo_snapshot();
  static const int kHloSnapshotFieldNumber = 2;
  private:
  const ::xla::HloSnapshot& _internal_hlo_snapshot() const;
  public:
  const ::xla::HloSnapshot& hlo_snapshot() const;
  ::xla::HloSnapshot* release_hlo_snapshot();
  ::xla::HloSnapshot* mutable_hlo_snapshot();
  void set_allocated_hlo_snapshot(::xla::HloSnapshot* hlo_snapshot);

  // @@protoc_insertion_point(class_scope:xrt.XLAComputation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xrt::XLAComputationConfig* config_;
  ::xla::HloSnapshot* hlo_snapshot_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XLAAllocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.XLAAllocation) */ {
 public:
  XLAAllocation();
  virtual ~XLAAllocation();

  XLAAllocation(const XLAAllocation& from);

  inline XLAAllocation& operator=(const XLAAllocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XLAAllocation(XLAAllocation&& from) noexcept
    : XLAAllocation() {
    *this = ::std::move(from);
  }

  inline XLAAllocation& operator=(XLAAllocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XLAAllocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XLAAllocation* internal_default_instance() {
    return reinterpret_cast<const XLAAllocation*>(
               &_XLAAllocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(XLAAllocation* other);
  friend void swap(XLAAllocation& a, XLAAllocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XLAAllocation* New() const final {
    return CreateMaybeMessage<XLAAllocation>(NULL);
  }

  XLAAllocation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XLAAllocation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XLAAllocation& from);
  void MergeFrom(const XLAAllocation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XLAAllocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .xla.LiteralProto value = 2;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 2;
  private:
  const ::xla::LiteralProto& _internal_value() const;
  public:
  const ::xla::LiteralProto& value() const;
  ::xla::LiteralProto* release_value();
  ::xla::LiteralProto* mutable_value();
  void set_allocated_value(::xla::LiteralProto* value);

  // @@protoc_insertion_point(class_scope:xrt.XLAAllocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::xla::LiteralProto* value_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XLATupleNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.XLATupleNode) */ {
 public:
  XLATupleNode();
  virtual ~XLATupleNode();

  XLATupleNode(const XLATupleNode& from);

  inline XLATupleNode& operator=(const XLATupleNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XLATupleNode(XLATupleNode&& from) noexcept
    : XLATupleNode() {
    *this = ::std::move(from);
  }

  inline XLATupleNode& operator=(XLATupleNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XLATupleNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XLATupleNode* internal_default_instance() {
    return reinterpret_cast<const XLATupleNode*>(
               &_XLATupleNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(XLATupleNode* other);
  friend void swap(XLATupleNode& a, XLATupleNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XLATupleNode* New() const final {
    return CreateMaybeMessage<XLATupleNode>(NULL);
  }

  XLATupleNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XLATupleNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XLATupleNode& from);
  void MergeFrom(const XLATupleNode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XLATupleNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xrt.XLATupleNode tuples = 3;
  int tuples_size() const;
  void clear_tuples();
  static const int kTuplesFieldNumber = 3;
  ::xrt::XLATupleNode* mutable_tuples(int index);
  ::google::protobuf::RepeatedPtrField< ::xrt::XLATupleNode >*
      mutable_tuples();
  const ::xrt::XLATupleNode& tuples(int index) const;
  ::xrt::XLATupleNode* add_tuples();
  const ::google::protobuf::RepeatedPtrField< ::xrt::XLATupleNode >&
      tuples() const;

  // int32 input_index = 1;
  void clear_input_index();
  static const int kInputIndexFieldNumber = 1;
  ::google::protobuf::int32 input_index() const;
  void set_input_index(::google::protobuf::int32 value);

  // bool release_input_handle = 2;
  void clear_release_input_handle();
  static const int kReleaseInputHandleFieldNumber = 2;
  bool release_input_handle() const;
  void set_release_input_handle(bool value);

  // @@protoc_insertion_point(class_scope:xrt.XLATupleNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xrt::XLATupleNode > tuples_;
  ::google::protobuf::int32 input_index_;
  bool release_input_handle_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XRTExecutionConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.XRTExecutionConfig) */ {
 public:
  XRTExecutionConfig();
  virtual ~XRTExecutionConfig();

  XRTExecutionConfig(const XRTExecutionConfig& from);

  inline XRTExecutionConfig& operator=(const XRTExecutionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XRTExecutionConfig(XRTExecutionConfig&& from) noexcept
    : XRTExecutionConfig() {
    *this = ::std::move(from);
  }

  inline XRTExecutionConfig& operator=(XRTExecutionConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XRTExecutionConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XRTExecutionConfig* internal_default_instance() {
    return reinterpret_cast<const XRTExecutionConfig*>(
               &_XRTExecutionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(XRTExecutionConfig* other);
  friend void swap(XRTExecutionConfig& a, XRTExecutionConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XRTExecutionConfig* New() const final {
    return CreateMaybeMessage<XRTExecutionConfig>(NULL);
  }

  XRTExecutionConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XRTExecutionConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XRTExecutionConfig& from);
  void MergeFrom(const XRTExecutionConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XRTExecutionConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string execution_instance_key = 3;
  void clear_execution_instance_key();
  static const int kExecutionInstanceKeyFieldNumber = 3;
  const ::std::string& execution_instance_key() const;
  void set_execution_instance_key(const ::std::string& value);
  #if LANG_CXX11
  void set_execution_instance_key(::std::string&& value);
  #endif
  void set_execution_instance_key(const char* value);
  void set_execution_instance_key(const char* value, size_t size);
  ::std::string* mutable_execution_instance_key();
  ::std::string* release_execution_instance_key();
  void set_allocated_execution_instance_key(::std::string* execution_instance_key);

  // int32 device_ordinal = 1;
  void clear_device_ordinal();
  static const int kDeviceOrdinalFieldNumber = 1;
  ::google::protobuf::int32 device_ordinal() const;
  void set_device_ordinal(::google::protobuf::int32 value);

  // int32 core_index_in_replica = 2;
  void clear_core_index_in_replica();
  static const int kCoreIndexInReplicaFieldNumber = 2;
  ::google::protobuf::int32 core_index_in_replica() const;
  void set_core_index_in_replica(::google::protobuf::int32 value);

  // uint32 rng_seed = 4;
  void clear_rng_seed();
  static const int kRngSeedFieldNumber = 4;
  ::google::protobuf::uint32 rng_seed() const;
  void set_rng_seed(::google::protobuf::uint32 value);

  // bool release_input_handles = 5;
  void clear_release_input_handles();
  static const int kReleaseInputHandlesFieldNumber = 5;
  bool release_input_handles() const;
  void set_release_input_handles(bool value);

  // bool release_compilation_handle = 6;
  void clear_release_compilation_handle();
  static const int kReleaseCompilationHandleFieldNumber = 6;
  bool release_compilation_handle() const;
  void set_release_compilation_handle(bool value);

  // bool return_exploded_tuple = 7;
  void clear_return_exploded_tuple();
  static const int kReturnExplodedTupleFieldNumber = 7;
  bool return_exploded_tuple() const;
  void set_return_exploded_tuple(bool value);

  // @@protoc_insertion_point(class_scope:xrt.XRTExecutionConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr execution_instance_key_;
  ::google::protobuf::int32 device_ordinal_;
  ::google::protobuf::int32 core_index_in_replica_;
  ::google::protobuf::uint32 rng_seed_;
  bool release_input_handles_;
  bool release_compilation_handle_;
  bool return_exploded_tuple_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XRTChainedExecuteConfig : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.XRTChainedExecuteConfig) */ {
 public:
  XRTChainedExecuteConfig();
  virtual ~XRTChainedExecuteConfig();

  XRTChainedExecuteConfig(const XRTChainedExecuteConfig& from);

  inline XRTChainedExecuteConfig& operator=(const XRTChainedExecuteConfig& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XRTChainedExecuteConfig(XRTChainedExecuteConfig&& from) noexcept
    : XRTChainedExecuteConfig() {
    *this = ::std::move(from);
  }

  inline XRTChainedExecuteConfig& operator=(XRTChainedExecuteConfig&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XRTChainedExecuteConfig& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XRTChainedExecuteConfig* internal_default_instance() {
    return reinterpret_cast<const XRTChainedExecuteConfig*>(
               &_XRTChainedExecuteConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(XRTChainedExecuteConfig* other);
  friend void swap(XRTChainedExecuteConfig& a, XRTChainedExecuteConfig& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XRTChainedExecuteConfig* New() const final {
    return CreateMaybeMessage<XRTChainedExecuteConfig>(NULL);
  }

  XRTChainedExecuteConfig* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XRTChainedExecuteConfig>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XRTChainedExecuteConfig& from);
  void MergeFrom(const XRTChainedExecuteConfig& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XRTChainedExecuteConfig* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string execution_instance_key = 3;
  void clear_execution_instance_key();
  static const int kExecutionInstanceKeyFieldNumber = 3;
  const ::std::string& execution_instance_key() const;
  void set_execution_instance_key(const ::std::string& value);
  #if LANG_CXX11
  void set_execution_instance_key(::std::string&& value);
  #endif
  void set_execution_instance_key(const char* value);
  void set_execution_instance_key(const char* value, size_t size);
  ::std::string* mutable_execution_instance_key();
  ::std::string* release_execution_instance_key();
  void set_allocated_execution_instance_key(::std::string* execution_instance_key);

  // uint32 rng_seed = 1;
  void clear_rng_seed();
  static const int kRngSeedFieldNumber = 1;
  ::google::protobuf::uint32 rng_seed() const;
  void set_rng_seed(::google::protobuf::uint32 value);

  // int32 core_index_in_replica = 2;
  void clear_core_index_in_replica();
  static const int kCoreIndexInReplicaFieldNumber = 2;
  ::google::protobuf::int32 core_index_in_replica() const;
  void set_core_index_in_replica(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xrt.XRTChainedExecuteConfig)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr execution_instance_key_;
  ::google::protobuf::uint32 rng_seed_;
  ::google::protobuf::int32 core_index_in_replica_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XRTChainedExecuteOp_Input : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.XRTChainedExecuteOp.Input) */ {
 public:
  XRTChainedExecuteOp_Input();
  virtual ~XRTChainedExecuteOp_Input();

  XRTChainedExecuteOp_Input(const XRTChainedExecuteOp_Input& from);

  inline XRTChainedExecuteOp_Input& operator=(const XRTChainedExecuteOp_Input& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XRTChainedExecuteOp_Input(XRTChainedExecuteOp_Input&& from) noexcept
    : XRTChainedExecuteOp_Input() {
    *this = ::std::move(from);
  }

  inline XRTChainedExecuteOp_Input& operator=(XRTChainedExecuteOp_Input&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XRTChainedExecuteOp_Input& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XRTChainedExecuteOp_Input* internal_default_instance() {
    return reinterpret_cast<const XRTChainedExecuteOp_Input*>(
               &_XRTChainedExecuteOp_Input_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(XRTChainedExecuteOp_Input* other);
  friend void swap(XRTChainedExecuteOp_Input& a, XRTChainedExecuteOp_Input& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XRTChainedExecuteOp_Input* New() const final {
    return CreateMaybeMessage<XRTChainedExecuteOp_Input>(NULL);
  }

  XRTChainedExecuteOp_Input* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XRTChainedExecuteOp_Input>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XRTChainedExecuteOp_Input& from);
  void MergeFrom(const XRTChainedExecuteOp_Input& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XRTChainedExecuteOp_Input* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 op_index = 1;
  void clear_op_index();
  static const int kOpIndexFieldNumber = 1;
  ::google::protobuf::int64 op_index() const;
  void set_op_index(::google::protobuf::int64 value);

  // int64 output_index = 2;
  void clear_output_index();
  static const int kOutputIndexFieldNumber = 2;
  ::google::protobuf::int64 output_index() const;
  void set_output_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xrt.XRTChainedExecuteOp.Input)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 op_index_;
  ::google::protobuf::int64 output_index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XRTChainedExecuteOp_Output : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.XRTChainedExecuteOp.Output) */ {
 public:
  XRTChainedExecuteOp_Output();
  virtual ~XRTChainedExecuteOp_Output();

  XRTChainedExecuteOp_Output(const XRTChainedExecuteOp_Output& from);

  inline XRTChainedExecuteOp_Output& operator=(const XRTChainedExecuteOp_Output& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XRTChainedExecuteOp_Output(XRTChainedExecuteOp_Output&& from) noexcept
    : XRTChainedExecuteOp_Output() {
    *this = ::std::move(from);
  }

  inline XRTChainedExecuteOp_Output& operator=(XRTChainedExecuteOp_Output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XRTChainedExecuteOp_Output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XRTChainedExecuteOp_Output* internal_default_instance() {
    return reinterpret_cast<const XRTChainedExecuteOp_Output*>(
               &_XRTChainedExecuteOp_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(XRTChainedExecuteOp_Output* other);
  friend void swap(XRTChainedExecuteOp_Output& a, XRTChainedExecuteOp_Output& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XRTChainedExecuteOp_Output* New() const final {
    return CreateMaybeMessage<XRTChainedExecuteOp_Output>(NULL);
  }

  XRTChainedExecuteOp_Output* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XRTChainedExecuteOp_Output>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XRTChainedExecuteOp_Output& from);
  void MergeFrom(const XRTChainedExecuteOp_Output& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XRTChainedExecuteOp_Output* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 output_index = 1;
  void clear_output_index();
  static const int kOutputIndexFieldNumber = 1;
  ::google::protobuf::int64 output_index() const;
  void set_output_index(::google::protobuf::int64 value);

  // int64 result_index = 2;
  void clear_result_index();
  static const int kResultIndexFieldNumber = 2;
  ::google::protobuf::int64 result_index() const;
  void set_result_index(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:xrt.XRTChainedExecuteOp.Output)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 output_index_;
  ::google::protobuf::int64 result_index_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XRTChainedExecuteOp : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.XRTChainedExecuteOp) */ {
 public:
  XRTChainedExecuteOp();
  virtual ~XRTChainedExecuteOp();

  XRTChainedExecuteOp(const XRTChainedExecuteOp& from);

  inline XRTChainedExecuteOp& operator=(const XRTChainedExecuteOp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XRTChainedExecuteOp(XRTChainedExecuteOp&& from) noexcept
    : XRTChainedExecuteOp() {
    *this = ::std::move(from);
  }

  inline XRTChainedExecuteOp& operator=(XRTChainedExecuteOp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XRTChainedExecuteOp& default_instance();

  enum OpOneofCase {
    kDataHandle = 1,
    kComputationHandle = 2,
    OP_ONEOF_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XRTChainedExecuteOp* internal_default_instance() {
    return reinterpret_cast<const XRTChainedExecuteOp*>(
               &_XRTChainedExecuteOp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(XRTChainedExecuteOp* other);
  friend void swap(XRTChainedExecuteOp& a, XRTChainedExecuteOp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XRTChainedExecuteOp* New() const final {
    return CreateMaybeMessage<XRTChainedExecuteOp>(NULL);
  }

  XRTChainedExecuteOp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XRTChainedExecuteOp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XRTChainedExecuteOp& from);
  void MergeFrom(const XRTChainedExecuteOp& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XRTChainedExecuteOp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef XRTChainedExecuteOp_Input Input;
  typedef XRTChainedExecuteOp_Output Output;

  // accessors -------------------------------------------------------

  // repeated .xrt.XRTChainedExecuteOp.Output outputs = 3;
  int outputs_size() const;
  void clear_outputs();
  static const int kOutputsFieldNumber = 3;
  ::xrt::XRTChainedExecuteOp_Output* mutable_outputs(int index);
  ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp_Output >*
      mutable_outputs();
  const ::xrt::XRTChainedExecuteOp_Output& outputs(int index) const;
  ::xrt::XRTChainedExecuteOp_Output* add_outputs();
  const ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp_Output >&
      outputs() const;

  // repeated .xrt.XRTChainedExecuteOp.Input inputs = 4;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 4;
  ::xrt::XRTChainedExecuteOp_Input* mutable_inputs(int index);
  ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp_Input >*
      mutable_inputs();
  const ::xrt::XRTChainedExecuteOp_Input& inputs(int index) const;
  ::xrt::XRTChainedExecuteOp_Input* add_inputs();
  const ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp_Input >&
      inputs() const;

  // int64 data_handle = 1;
  private:
  bool has_data_handle() const;
  public:
  void clear_data_handle();
  static const int kDataHandleFieldNumber = 1;
  ::google::protobuf::int64 data_handle() const;
  void set_data_handle(::google::protobuf::int64 value);

  // int64 computation_handle = 2;
  private:
  bool has_computation_handle() const;
  public:
  void clear_computation_handle();
  static const int kComputationHandleFieldNumber = 2;
  ::google::protobuf::int64 computation_handle() const;
  void set_computation_handle(::google::protobuf::int64 value);

  void clear_op_oneof();
  OpOneofCase op_oneof_case() const;
  // @@protoc_insertion_point(class_scope:xrt.XRTChainedExecuteOp)
 private:
  void set_has_data_handle();
  void set_has_computation_handle();

  inline bool has_op_oneof() const;
  inline void clear_has_op_oneof();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp_Output > outputs_;
  ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp_Input > inputs_;
  union OpOneofUnion {
    OpOneofUnion() {}
    ::google::protobuf::int64 data_handle_;
    ::google::protobuf::int64 computation_handle_;
  } op_oneof_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class XRTChainedExecutePlan : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:xrt.XRTChainedExecutePlan) */ {
 public:
  XRTChainedExecutePlan();
  virtual ~XRTChainedExecutePlan();

  XRTChainedExecutePlan(const XRTChainedExecutePlan& from);

  inline XRTChainedExecutePlan& operator=(const XRTChainedExecutePlan& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  XRTChainedExecutePlan(XRTChainedExecutePlan&& from) noexcept
    : XRTChainedExecutePlan() {
    *this = ::std::move(from);
  }

  inline XRTChainedExecutePlan& operator=(XRTChainedExecutePlan&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const XRTChainedExecutePlan& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const XRTChainedExecutePlan* internal_default_instance() {
    return reinterpret_cast<const XRTChainedExecutePlan*>(
               &_XRTChainedExecutePlan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(XRTChainedExecutePlan* other);
  friend void swap(XRTChainedExecutePlan& a, XRTChainedExecutePlan& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline XRTChainedExecutePlan* New() const final {
    return CreateMaybeMessage<XRTChainedExecutePlan>(NULL);
  }

  XRTChainedExecutePlan* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<XRTChainedExecutePlan>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const XRTChainedExecutePlan& from);
  void MergeFrom(const XRTChainedExecutePlan& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(XRTChainedExecutePlan* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xrt.XRTChainedExecuteOp ops = 1;
  int ops_size() const;
  void clear_ops();
  static const int kOpsFieldNumber = 1;
  ::xrt::XRTChainedExecuteOp* mutable_ops(int index);
  ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp >*
      mutable_ops();
  const ::xrt::XRTChainedExecuteOp& ops(int index) const;
  ::xrt::XRTChainedExecuteOp* add_ops();
  const ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp >&
      ops() const;

  // @@protoc_insertion_point(class_scope:xrt.XRTChainedExecutePlan)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp > ops_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DeviceAssignment_ComputationDevice_DeviceMeshCoordinates

// repeated int32 value = 1;
inline int DeviceAssignment_ComputationDevice_DeviceMeshCoordinates::value_size() const {
  return value_.size();
}
inline void DeviceAssignment_ComputationDevice_DeviceMeshCoordinates::clear_value() {
  value_.Clear();
}
inline ::google::protobuf::int32 DeviceAssignment_ComputationDevice_DeviceMeshCoordinates::value(int index) const {
  // @@protoc_insertion_point(field_get:xrt.DeviceAssignment.ComputationDevice.DeviceMeshCoordinates.value)
  return value_.Get(index);
}
inline void DeviceAssignment_ComputationDevice_DeviceMeshCoordinates::set_value(int index, ::google::protobuf::int32 value) {
  value_.Set(index, value);
  // @@protoc_insertion_point(field_set:xrt.DeviceAssignment.ComputationDevice.DeviceMeshCoordinates.value)
}
inline void DeviceAssignment_ComputationDevice_DeviceMeshCoordinates::add_value(::google::protobuf::int32 value) {
  value_.Add(value);
  // @@protoc_insertion_point(field_add:xrt.DeviceAssignment.ComputationDevice.DeviceMeshCoordinates.value)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
DeviceAssignment_ComputationDevice_DeviceMeshCoordinates::value() const {
  // @@protoc_insertion_point(field_list:xrt.DeviceAssignment.ComputationDevice.DeviceMeshCoordinates.value)
  return value_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
DeviceAssignment_ComputationDevice_DeviceMeshCoordinates::mutable_value() {
  // @@protoc_insertion_point(field_mutable_list:xrt.DeviceAssignment.ComputationDevice.DeviceMeshCoordinates.value)
  return &value_;
}

// -------------------------------------------------------------------

// DeviceAssignment_ComputationDevice

// repeated .xrt.DeviceAssignment.ComputationDevice.DeviceMeshCoordinates replica_devices = 1;
inline int DeviceAssignment_ComputationDevice::replica_devices_size() const {
  return replica_devices_.size();
}
inline void DeviceAssignment_ComputationDevice::clear_replica_devices() {
  replica_devices_.Clear();
}
inline ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates* DeviceAssignment_ComputationDevice::mutable_replica_devices(int index) {
  // @@protoc_insertion_point(field_mutable:xrt.DeviceAssignment.ComputationDevice.replica_devices)
  return replica_devices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates >*
DeviceAssignment_ComputationDevice::mutable_replica_devices() {
  // @@protoc_insertion_point(field_mutable_list:xrt.DeviceAssignment.ComputationDevice.replica_devices)
  return &replica_devices_;
}
inline const ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates& DeviceAssignment_ComputationDevice::replica_devices(int index) const {
  // @@protoc_insertion_point(field_get:xrt.DeviceAssignment.ComputationDevice.replica_devices)
  return replica_devices_.Get(index);
}
inline ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates* DeviceAssignment_ComputationDevice::add_replica_devices() {
  // @@protoc_insertion_point(field_add:xrt.DeviceAssignment.ComputationDevice.replica_devices)
  return replica_devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xrt::DeviceAssignment_ComputationDevice_DeviceMeshCoordinates >&
DeviceAssignment_ComputationDevice::replica_devices() const {
  // @@protoc_insertion_point(field_list:xrt.DeviceAssignment.ComputationDevice.replica_devices)
  return replica_devices_;
}

// -------------------------------------------------------------------

// DeviceAssignment

// repeated .xrt.DeviceAssignment.ComputationDevice computation_devices = 1;
inline int DeviceAssignment::computation_devices_size() const {
  return computation_devices_.size();
}
inline void DeviceAssignment::clear_computation_devices() {
  computation_devices_.Clear();
}
inline ::xrt::DeviceAssignment_ComputationDevice* DeviceAssignment::mutable_computation_devices(int index) {
  // @@protoc_insertion_point(field_mutable:xrt.DeviceAssignment.computation_devices)
  return computation_devices_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xrt::DeviceAssignment_ComputationDevice >*
DeviceAssignment::mutable_computation_devices() {
  // @@protoc_insertion_point(field_mutable_list:xrt.DeviceAssignment.computation_devices)
  return &computation_devices_;
}
inline const ::xrt::DeviceAssignment_ComputationDevice& DeviceAssignment::computation_devices(int index) const {
  // @@protoc_insertion_point(field_get:xrt.DeviceAssignment.computation_devices)
  return computation_devices_.Get(index);
}
inline ::xrt::DeviceAssignment_ComputationDevice* DeviceAssignment::add_computation_devices() {
  // @@protoc_insertion_point(field_add:xrt.DeviceAssignment.computation_devices)
  return computation_devices_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xrt::DeviceAssignment_ComputationDevice >&
DeviceAssignment::computation_devices() const {
  // @@protoc_insertion_point(field_list:xrt.DeviceAssignment.computation_devices)
  return computation_devices_;
}

// -------------------------------------------------------------------

// XLAComputationConfig

// int32 num_replicas = 1;
inline void XLAComputationConfig::clear_num_replicas() {
  num_replicas_ = 0;
}
inline ::google::protobuf::int32 XLAComputationConfig::num_replicas() const {
  // @@protoc_insertion_point(field_get:xrt.XLAComputationConfig.num_replicas)
  return num_replicas_;
}
inline void XLAComputationConfig::set_num_replicas(::google::protobuf::int32 value) {
  
  num_replicas_ = value;
  // @@protoc_insertion_point(field_set:xrt.XLAComputationConfig.num_replicas)
}

// int32 num_cores_per_replica = 2;
inline void XLAComputationConfig::clear_num_cores_per_replica() {
  num_cores_per_replica_ = 0;
}
inline ::google::protobuf::int32 XLAComputationConfig::num_cores_per_replica() const {
  // @@protoc_insertion_point(field_get:xrt.XLAComputationConfig.num_cores_per_replica)
  return num_cores_per_replica_;
}
inline void XLAComputationConfig::set_num_cores_per_replica(::google::protobuf::int32 value) {
  
  num_cores_per_replica_ = value;
  // @@protoc_insertion_point(field_set:xrt.XLAComputationConfig.num_cores_per_replica)
}

// .tensorflow.tf2xla.HostComputeMetadata host_compute_metadata = 3;
inline bool XLAComputationConfig::has_host_compute_metadata() const {
  return this != internal_default_instance() && host_compute_metadata_ != NULL;
}
inline const ::tensorflow::tf2xla::HostComputeMetadata& XLAComputationConfig::_internal_host_compute_metadata() const {
  return *host_compute_metadata_;
}
inline const ::tensorflow::tf2xla::HostComputeMetadata& XLAComputationConfig::host_compute_metadata() const {
  const ::tensorflow::tf2xla::HostComputeMetadata* p = host_compute_metadata_;
  // @@protoc_insertion_point(field_get:xrt.XLAComputationConfig.host_compute_metadata)
  return p != NULL ? *p : *reinterpret_cast<const ::tensorflow::tf2xla::HostComputeMetadata*>(
      &::tensorflow::tf2xla::_HostComputeMetadata_default_instance_);
}
inline ::tensorflow::tf2xla::HostComputeMetadata* XLAComputationConfig::release_host_compute_metadata() {
  // @@protoc_insertion_point(field_release:xrt.XLAComputationConfig.host_compute_metadata)
  
  ::tensorflow::tf2xla::HostComputeMetadata* temp = host_compute_metadata_;
  host_compute_metadata_ = NULL;
  return temp;
}
inline ::tensorflow::tf2xla::HostComputeMetadata* XLAComputationConfig::mutable_host_compute_metadata() {
  
  if (host_compute_metadata_ == NULL) {
    auto* p = CreateMaybeMessage<::tensorflow::tf2xla::HostComputeMetadata>(GetArenaNoVirtual());
    host_compute_metadata_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xrt.XLAComputationConfig.host_compute_metadata)
  return host_compute_metadata_;
}
inline void XLAComputationConfig::set_allocated_host_compute_metadata(::tensorflow::tf2xla::HostComputeMetadata* host_compute_metadata) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(host_compute_metadata_);
  }
  if (host_compute_metadata) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(host_compute_metadata)->GetArena();
    if (message_arena != submessage_arena) {
      host_compute_metadata = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, host_compute_metadata, submessage_arena);
    }
    
  } else {
    
  }
  host_compute_metadata_ = host_compute_metadata;
  // @@protoc_insertion_point(field_set_allocated:xrt.XLAComputationConfig.host_compute_metadata)
}

// .xla.ProgramShapeProto program_shape = 4;
inline bool XLAComputationConfig::has_program_shape() const {
  return this != internal_default_instance() && program_shape_ != NULL;
}
inline const ::xla::ProgramShapeProto& XLAComputationConfig::_internal_program_shape() const {
  return *program_shape_;
}
inline const ::xla::ProgramShapeProto& XLAComputationConfig::program_shape() const {
  const ::xla::ProgramShapeProto* p = program_shape_;
  // @@protoc_insertion_point(field_get:xrt.XLAComputationConfig.program_shape)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::ProgramShapeProto*>(
      &::xla::_ProgramShapeProto_default_instance_);
}
inline ::xla::ProgramShapeProto* XLAComputationConfig::release_program_shape() {
  // @@protoc_insertion_point(field_release:xrt.XLAComputationConfig.program_shape)
  
  ::xla::ProgramShapeProto* temp = program_shape_;
  program_shape_ = NULL;
  return temp;
}
inline ::xla::ProgramShapeProto* XLAComputationConfig::mutable_program_shape() {
  
  if (program_shape_ == NULL) {
    auto* p = CreateMaybeMessage<::xla::ProgramShapeProto>(GetArenaNoVirtual());
    program_shape_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xrt.XLAComputationConfig.program_shape)
  return program_shape_;
}
inline void XLAComputationConfig::set_allocated_program_shape(::xla::ProgramShapeProto* program_shape) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(program_shape_);
  }
  if (program_shape) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(program_shape)->GetArena();
    if (message_arena != submessage_arena) {
      program_shape = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, program_shape, submessage_arena);
    }
    
  } else {
    
  }
  program_shape_ = program_shape;
  // @@protoc_insertion_point(field_set_allocated:xrt.XLAComputationConfig.program_shape)
}

// repeated .xla.ProgramShapeProto per_core_program_shape = 5;
inline int XLAComputationConfig::per_core_program_shape_size() const {
  return per_core_program_shape_.size();
}
inline ::xla::ProgramShapeProto* XLAComputationConfig::mutable_per_core_program_shape(int index) {
  // @@protoc_insertion_point(field_mutable:xrt.XLAComputationConfig.per_core_program_shape)
  return per_core_program_shape_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xla::ProgramShapeProto >*
XLAComputationConfig::mutable_per_core_program_shape() {
  // @@protoc_insertion_point(field_mutable_list:xrt.XLAComputationConfig.per_core_program_shape)
  return &per_core_program_shape_;
}
inline const ::xla::ProgramShapeProto& XLAComputationConfig::per_core_program_shape(int index) const {
  // @@protoc_insertion_point(field_get:xrt.XLAComputationConfig.per_core_program_shape)
  return per_core_program_shape_.Get(index);
}
inline ::xla::ProgramShapeProto* XLAComputationConfig::add_per_core_program_shape() {
  // @@protoc_insertion_point(field_add:xrt.XLAComputationConfig.per_core_program_shape)
  return per_core_program_shape_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xla::ProgramShapeProto >&
XLAComputationConfig::per_core_program_shape() const {
  // @@protoc_insertion_point(field_list:xrt.XLAComputationConfig.per_core_program_shape)
  return per_core_program_shape_;
}

// .xrt.DeviceAssignment device_assignment = 6;
inline bool XLAComputationConfig::has_device_assignment() const {
  return this != internal_default_instance() && device_assignment_ != NULL;
}
inline void XLAComputationConfig::clear_device_assignment() {
  if (GetArenaNoVirtual() == NULL && device_assignment_ != NULL) {
    delete device_assignment_;
  }
  device_assignment_ = NULL;
}
inline const ::xrt::DeviceAssignment& XLAComputationConfig::_internal_device_assignment() const {
  return *device_assignment_;
}
inline const ::xrt::DeviceAssignment& XLAComputationConfig::device_assignment() const {
  const ::xrt::DeviceAssignment* p = device_assignment_;
  // @@protoc_insertion_point(field_get:xrt.XLAComputationConfig.device_assignment)
  return p != NULL ? *p : *reinterpret_cast<const ::xrt::DeviceAssignment*>(
      &::xrt::_DeviceAssignment_default_instance_);
}
inline ::xrt::DeviceAssignment* XLAComputationConfig::release_device_assignment() {
  // @@protoc_insertion_point(field_release:xrt.XLAComputationConfig.device_assignment)
  
  ::xrt::DeviceAssignment* temp = device_assignment_;
  device_assignment_ = NULL;
  return temp;
}
inline ::xrt::DeviceAssignment* XLAComputationConfig::mutable_device_assignment() {
  
  if (device_assignment_ == NULL) {
    auto* p = CreateMaybeMessage<::xrt::DeviceAssignment>(GetArenaNoVirtual());
    device_assignment_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xrt.XLAComputationConfig.device_assignment)
  return device_assignment_;
}
inline void XLAComputationConfig::set_allocated_device_assignment(::xrt::DeviceAssignment* device_assignment) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete device_assignment_;
  }
  if (device_assignment) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      device_assignment = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, device_assignment, submessage_arena);
    }
    
  } else {
    
  }
  device_assignment_ = device_assignment;
  // @@protoc_insertion_point(field_set_allocated:xrt.XLAComputationConfig.device_assignment)
}

// .xla.DebugOptions debug_options = 7;
inline bool XLAComputationConfig::has_debug_options() const {
  return this != internal_default_instance() && debug_options_ != NULL;
}
inline const ::xla::DebugOptions& XLAComputationConfig::_internal_debug_options() const {
  return *debug_options_;
}
inline const ::xla::DebugOptions& XLAComputationConfig::debug_options() const {
  const ::xla::DebugOptions* p = debug_options_;
  // @@protoc_insertion_point(field_get:xrt.XLAComputationConfig.debug_options)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::DebugOptions*>(
      &::xla::_DebugOptions_default_instance_);
}
inline ::xla::DebugOptions* XLAComputationConfig::release_debug_options() {
  // @@protoc_insertion_point(field_release:xrt.XLAComputationConfig.debug_options)
  
  ::xla::DebugOptions* temp = debug_options_;
  debug_options_ = NULL;
  return temp;
}
inline ::xla::DebugOptions* XLAComputationConfig::mutable_debug_options() {
  
  if (debug_options_ == NULL) {
    auto* p = CreateMaybeMessage<::xla::DebugOptions>(GetArenaNoVirtual());
    debug_options_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xrt.XLAComputationConfig.debug_options)
  return debug_options_;
}
inline void XLAComputationConfig::set_allocated_debug_options(::xla::DebugOptions* debug_options) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(debug_options_);
  }
  if (debug_options) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      debug_options = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, debug_options, submessage_arena);
    }
    
  } else {
    
  }
  debug_options_ = debug_options;
  // @@protoc_insertion_point(field_set_allocated:xrt.XLAComputationConfig.debug_options)
}

// -------------------------------------------------------------------

// XLAComputation

// .xrt.XLAComputationConfig config = 1;
inline bool XLAComputation::has_config() const {
  return this != internal_default_instance() && config_ != NULL;
}
inline void XLAComputation::clear_config() {
  if (GetArenaNoVirtual() == NULL && config_ != NULL) {
    delete config_;
  }
  config_ = NULL;
}
inline const ::xrt::XLAComputationConfig& XLAComputation::_internal_config() const {
  return *config_;
}
inline const ::xrt::XLAComputationConfig& XLAComputation::config() const {
  const ::xrt::XLAComputationConfig* p = config_;
  // @@protoc_insertion_point(field_get:xrt.XLAComputation.config)
  return p != NULL ? *p : *reinterpret_cast<const ::xrt::XLAComputationConfig*>(
      &::xrt::_XLAComputationConfig_default_instance_);
}
inline ::xrt::XLAComputationConfig* XLAComputation::release_config() {
  // @@protoc_insertion_point(field_release:xrt.XLAComputation.config)
  
  ::xrt::XLAComputationConfig* temp = config_;
  config_ = NULL;
  return temp;
}
inline ::xrt::XLAComputationConfig* XLAComputation::mutable_config() {
  
  if (config_ == NULL) {
    auto* p = CreateMaybeMessage<::xrt::XLAComputationConfig>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xrt.XLAComputation.config)
  return config_;
}
inline void XLAComputation::set_allocated_config(::xrt::XLAComputationConfig* config) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete config_;
  }
  if (config) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      config = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    
  } else {
    
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:xrt.XLAComputation.config)
}

// .xla.HloSnapshot hlo_snapshot = 2;
inline bool XLAComputation::has_hlo_snapshot() const {
  return this != internal_default_instance() && hlo_snapshot_ != NULL;
}
inline const ::xla::HloSnapshot& XLAComputation::_internal_hlo_snapshot() const {
  return *hlo_snapshot_;
}
inline const ::xla::HloSnapshot& XLAComputation::hlo_snapshot() const {
  const ::xla::HloSnapshot* p = hlo_snapshot_;
  // @@protoc_insertion_point(field_get:xrt.XLAComputation.hlo_snapshot)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::HloSnapshot*>(
      &::xla::_HloSnapshot_default_instance_);
}
inline ::xla::HloSnapshot* XLAComputation::release_hlo_snapshot() {
  // @@protoc_insertion_point(field_release:xrt.XLAComputation.hlo_snapshot)
  
  ::xla::HloSnapshot* temp = hlo_snapshot_;
  hlo_snapshot_ = NULL;
  return temp;
}
inline ::xla::HloSnapshot* XLAComputation::mutable_hlo_snapshot() {
  
  if (hlo_snapshot_ == NULL) {
    auto* p = CreateMaybeMessage<::xla::HloSnapshot>(GetArenaNoVirtual());
    hlo_snapshot_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xrt.XLAComputation.hlo_snapshot)
  return hlo_snapshot_;
}
inline void XLAComputation::set_allocated_hlo_snapshot(::xla::HloSnapshot* hlo_snapshot) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(hlo_snapshot_);
  }
  if (hlo_snapshot) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(hlo_snapshot)->GetArena();
    if (message_arena != submessage_arena) {
      hlo_snapshot = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, hlo_snapshot, submessage_arena);
    }
    
  } else {
    
  }
  hlo_snapshot_ = hlo_snapshot;
  // @@protoc_insertion_point(field_set_allocated:xrt.XLAComputation.hlo_snapshot)
}

// -------------------------------------------------------------------

// XLAAllocation

// .xla.LiteralProto value = 2;
inline bool XLAAllocation::has_value() const {
  return this != internal_default_instance() && value_ != NULL;
}
inline const ::xla::LiteralProto& XLAAllocation::_internal_value() const {
  return *value_;
}
inline const ::xla::LiteralProto& XLAAllocation::value() const {
  const ::xla::LiteralProto* p = value_;
  // @@protoc_insertion_point(field_get:xrt.XLAAllocation.value)
  return p != NULL ? *p : *reinterpret_cast<const ::xla::LiteralProto*>(
      &::xla::_LiteralProto_default_instance_);
}
inline ::xla::LiteralProto* XLAAllocation::release_value() {
  // @@protoc_insertion_point(field_release:xrt.XLAAllocation.value)
  
  ::xla::LiteralProto* temp = value_;
  value_ = NULL;
  return temp;
}
inline ::xla::LiteralProto* XLAAllocation::mutable_value() {
  
  if (value_ == NULL) {
    auto* p = CreateMaybeMessage<::xla::LiteralProto>(GetArenaNoVirtual());
    value_ = p;
  }
  // @@protoc_insertion_point(field_mutable:xrt.XLAAllocation.value)
  return value_;
}
inline void XLAAllocation::set_allocated_value(::xla::LiteralProto* value) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(value_);
  }
  if (value) {
    ::google::protobuf::Arena* submessage_arena =
      reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, value, submessage_arena);
    }
    
  } else {
    
  }
  value_ = value;
  // @@protoc_insertion_point(field_set_allocated:xrt.XLAAllocation.value)
}

// -------------------------------------------------------------------

// XLATupleNode

// int32 input_index = 1;
inline void XLATupleNode::clear_input_index() {
  input_index_ = 0;
}
inline ::google::protobuf::int32 XLATupleNode::input_index() const {
  // @@protoc_insertion_point(field_get:xrt.XLATupleNode.input_index)
  return input_index_;
}
inline void XLATupleNode::set_input_index(::google::protobuf::int32 value) {
  
  input_index_ = value;
  // @@protoc_insertion_point(field_set:xrt.XLATupleNode.input_index)
}

// bool release_input_handle = 2;
inline void XLATupleNode::clear_release_input_handle() {
  release_input_handle_ = false;
}
inline bool XLATupleNode::release_input_handle() const {
  // @@protoc_insertion_point(field_get:xrt.XLATupleNode.release_input_handle)
  return release_input_handle_;
}
inline void XLATupleNode::set_release_input_handle(bool value) {
  
  release_input_handle_ = value;
  // @@protoc_insertion_point(field_set:xrt.XLATupleNode.release_input_handle)
}

// repeated .xrt.XLATupleNode tuples = 3;
inline int XLATupleNode::tuples_size() const {
  return tuples_.size();
}
inline void XLATupleNode::clear_tuples() {
  tuples_.Clear();
}
inline ::xrt::XLATupleNode* XLATupleNode::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:xrt.XLATupleNode.tuples)
  return tuples_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xrt::XLATupleNode >*
XLATupleNode::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:xrt.XLATupleNode.tuples)
  return &tuples_;
}
inline const ::xrt::XLATupleNode& XLATupleNode::tuples(int index) const {
  // @@protoc_insertion_point(field_get:xrt.XLATupleNode.tuples)
  return tuples_.Get(index);
}
inline ::xrt::XLATupleNode* XLATupleNode::add_tuples() {
  // @@protoc_insertion_point(field_add:xrt.XLATupleNode.tuples)
  return tuples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xrt::XLATupleNode >&
XLATupleNode::tuples() const {
  // @@protoc_insertion_point(field_list:xrt.XLATupleNode.tuples)
  return tuples_;
}

// -------------------------------------------------------------------

// XRTExecutionConfig

// int32 device_ordinal = 1;
inline void XRTExecutionConfig::clear_device_ordinal() {
  device_ordinal_ = 0;
}
inline ::google::protobuf::int32 XRTExecutionConfig::device_ordinal() const {
  // @@protoc_insertion_point(field_get:xrt.XRTExecutionConfig.device_ordinal)
  return device_ordinal_;
}
inline void XRTExecutionConfig::set_device_ordinal(::google::protobuf::int32 value) {
  
  device_ordinal_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTExecutionConfig.device_ordinal)
}

// int32 core_index_in_replica = 2;
inline void XRTExecutionConfig::clear_core_index_in_replica() {
  core_index_in_replica_ = 0;
}
inline ::google::protobuf::int32 XRTExecutionConfig::core_index_in_replica() const {
  // @@protoc_insertion_point(field_get:xrt.XRTExecutionConfig.core_index_in_replica)
  return core_index_in_replica_;
}
inline void XRTExecutionConfig::set_core_index_in_replica(::google::protobuf::int32 value) {
  
  core_index_in_replica_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTExecutionConfig.core_index_in_replica)
}

// string execution_instance_key = 3;
inline void XRTExecutionConfig::clear_execution_instance_key() {
  execution_instance_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& XRTExecutionConfig::execution_instance_key() const {
  // @@protoc_insertion_point(field_get:xrt.XRTExecutionConfig.execution_instance_key)
  return execution_instance_key_.GetNoArena();
}
inline void XRTExecutionConfig::set_execution_instance_key(const ::std::string& value) {
  
  execution_instance_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xrt.XRTExecutionConfig.execution_instance_key)
}
#if LANG_CXX11
inline void XRTExecutionConfig::set_execution_instance_key(::std::string&& value) {
  
  execution_instance_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xrt.XRTExecutionConfig.execution_instance_key)
}
#endif
inline void XRTExecutionConfig::set_execution_instance_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  execution_instance_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xrt.XRTExecutionConfig.execution_instance_key)
}
inline void XRTExecutionConfig::set_execution_instance_key(const char* value, size_t size) {
  
  execution_instance_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xrt.XRTExecutionConfig.execution_instance_key)
}
inline ::std::string* XRTExecutionConfig::mutable_execution_instance_key() {
  
  // @@protoc_insertion_point(field_mutable:xrt.XRTExecutionConfig.execution_instance_key)
  return execution_instance_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XRTExecutionConfig::release_execution_instance_key() {
  // @@protoc_insertion_point(field_release:xrt.XRTExecutionConfig.execution_instance_key)
  
  return execution_instance_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XRTExecutionConfig::set_allocated_execution_instance_key(::std::string* execution_instance_key) {
  if (execution_instance_key != NULL) {
    
  } else {
    
  }
  execution_instance_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), execution_instance_key);
  // @@protoc_insertion_point(field_set_allocated:xrt.XRTExecutionConfig.execution_instance_key)
}

// uint32 rng_seed = 4;
inline void XRTExecutionConfig::clear_rng_seed() {
  rng_seed_ = 0u;
}
inline ::google::protobuf::uint32 XRTExecutionConfig::rng_seed() const {
  // @@protoc_insertion_point(field_get:xrt.XRTExecutionConfig.rng_seed)
  return rng_seed_;
}
inline void XRTExecutionConfig::set_rng_seed(::google::protobuf::uint32 value) {
  
  rng_seed_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTExecutionConfig.rng_seed)
}

// bool release_input_handles = 5;
inline void XRTExecutionConfig::clear_release_input_handles() {
  release_input_handles_ = false;
}
inline bool XRTExecutionConfig::release_input_handles() const {
  // @@protoc_insertion_point(field_get:xrt.XRTExecutionConfig.release_input_handles)
  return release_input_handles_;
}
inline void XRTExecutionConfig::set_release_input_handles(bool value) {
  
  release_input_handles_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTExecutionConfig.release_input_handles)
}

// bool release_compilation_handle = 6;
inline void XRTExecutionConfig::clear_release_compilation_handle() {
  release_compilation_handle_ = false;
}
inline bool XRTExecutionConfig::release_compilation_handle() const {
  // @@protoc_insertion_point(field_get:xrt.XRTExecutionConfig.release_compilation_handle)
  return release_compilation_handle_;
}
inline void XRTExecutionConfig::set_release_compilation_handle(bool value) {
  
  release_compilation_handle_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTExecutionConfig.release_compilation_handle)
}

// bool return_exploded_tuple = 7;
inline void XRTExecutionConfig::clear_return_exploded_tuple() {
  return_exploded_tuple_ = false;
}
inline bool XRTExecutionConfig::return_exploded_tuple() const {
  // @@protoc_insertion_point(field_get:xrt.XRTExecutionConfig.return_exploded_tuple)
  return return_exploded_tuple_;
}
inline void XRTExecutionConfig::set_return_exploded_tuple(bool value) {
  
  return_exploded_tuple_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTExecutionConfig.return_exploded_tuple)
}

// -------------------------------------------------------------------

// XRTChainedExecuteConfig

// uint32 rng_seed = 1;
inline void XRTChainedExecuteConfig::clear_rng_seed() {
  rng_seed_ = 0u;
}
inline ::google::protobuf::uint32 XRTChainedExecuteConfig::rng_seed() const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteConfig.rng_seed)
  return rng_seed_;
}
inline void XRTChainedExecuteConfig::set_rng_seed(::google::protobuf::uint32 value) {
  
  rng_seed_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTChainedExecuteConfig.rng_seed)
}

// int32 core_index_in_replica = 2;
inline void XRTChainedExecuteConfig::clear_core_index_in_replica() {
  core_index_in_replica_ = 0;
}
inline ::google::protobuf::int32 XRTChainedExecuteConfig::core_index_in_replica() const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteConfig.core_index_in_replica)
  return core_index_in_replica_;
}
inline void XRTChainedExecuteConfig::set_core_index_in_replica(::google::protobuf::int32 value) {
  
  core_index_in_replica_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTChainedExecuteConfig.core_index_in_replica)
}

// string execution_instance_key = 3;
inline void XRTChainedExecuteConfig::clear_execution_instance_key() {
  execution_instance_key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& XRTChainedExecuteConfig::execution_instance_key() const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteConfig.execution_instance_key)
  return execution_instance_key_.GetNoArena();
}
inline void XRTChainedExecuteConfig::set_execution_instance_key(const ::std::string& value) {
  
  execution_instance_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:xrt.XRTChainedExecuteConfig.execution_instance_key)
}
#if LANG_CXX11
inline void XRTChainedExecuteConfig::set_execution_instance_key(::std::string&& value) {
  
  execution_instance_key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:xrt.XRTChainedExecuteConfig.execution_instance_key)
}
#endif
inline void XRTChainedExecuteConfig::set_execution_instance_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  execution_instance_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:xrt.XRTChainedExecuteConfig.execution_instance_key)
}
inline void XRTChainedExecuteConfig::set_execution_instance_key(const char* value, size_t size) {
  
  execution_instance_key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:xrt.XRTChainedExecuteConfig.execution_instance_key)
}
inline ::std::string* XRTChainedExecuteConfig::mutable_execution_instance_key() {
  
  // @@protoc_insertion_point(field_mutable:xrt.XRTChainedExecuteConfig.execution_instance_key)
  return execution_instance_key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* XRTChainedExecuteConfig::release_execution_instance_key() {
  // @@protoc_insertion_point(field_release:xrt.XRTChainedExecuteConfig.execution_instance_key)
  
  return execution_instance_key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void XRTChainedExecuteConfig::set_allocated_execution_instance_key(::std::string* execution_instance_key) {
  if (execution_instance_key != NULL) {
    
  } else {
    
  }
  execution_instance_key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), execution_instance_key);
  // @@protoc_insertion_point(field_set_allocated:xrt.XRTChainedExecuteConfig.execution_instance_key)
}

// -------------------------------------------------------------------

// XRTChainedExecuteOp_Input

// int64 op_index = 1;
inline void XRTChainedExecuteOp_Input::clear_op_index() {
  op_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 XRTChainedExecuteOp_Input::op_index() const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteOp.Input.op_index)
  return op_index_;
}
inline void XRTChainedExecuteOp_Input::set_op_index(::google::protobuf::int64 value) {
  
  op_index_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTChainedExecuteOp.Input.op_index)
}

// int64 output_index = 2;
inline void XRTChainedExecuteOp_Input::clear_output_index() {
  output_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 XRTChainedExecuteOp_Input::output_index() const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteOp.Input.output_index)
  return output_index_;
}
inline void XRTChainedExecuteOp_Input::set_output_index(::google::protobuf::int64 value) {
  
  output_index_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTChainedExecuteOp.Input.output_index)
}

// -------------------------------------------------------------------

// XRTChainedExecuteOp_Output

// int64 output_index = 1;
inline void XRTChainedExecuteOp_Output::clear_output_index() {
  output_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 XRTChainedExecuteOp_Output::output_index() const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteOp.Output.output_index)
  return output_index_;
}
inline void XRTChainedExecuteOp_Output::set_output_index(::google::protobuf::int64 value) {
  
  output_index_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTChainedExecuteOp.Output.output_index)
}

// int64 result_index = 2;
inline void XRTChainedExecuteOp_Output::clear_result_index() {
  result_index_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 XRTChainedExecuteOp_Output::result_index() const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteOp.Output.result_index)
  return result_index_;
}
inline void XRTChainedExecuteOp_Output::set_result_index(::google::protobuf::int64 value) {
  
  result_index_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTChainedExecuteOp.Output.result_index)
}

// -------------------------------------------------------------------

// XRTChainedExecuteOp

// int64 data_handle = 1;
inline bool XRTChainedExecuteOp::has_data_handle() const {
  return op_oneof_case() == kDataHandle;
}
inline void XRTChainedExecuteOp::set_has_data_handle() {
  _oneof_case_[0] = kDataHandle;
}
inline void XRTChainedExecuteOp::clear_data_handle() {
  if (has_data_handle()) {
    op_oneof_.data_handle_ = GOOGLE_LONGLONG(0);
    clear_has_op_oneof();
  }
}
inline ::google::protobuf::int64 XRTChainedExecuteOp::data_handle() const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteOp.data_handle)
  if (has_data_handle()) {
    return op_oneof_.data_handle_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void XRTChainedExecuteOp::set_data_handle(::google::protobuf::int64 value) {
  if (!has_data_handle()) {
    clear_op_oneof();
    set_has_data_handle();
  }
  op_oneof_.data_handle_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTChainedExecuteOp.data_handle)
}

// int64 computation_handle = 2;
inline bool XRTChainedExecuteOp::has_computation_handle() const {
  return op_oneof_case() == kComputationHandle;
}
inline void XRTChainedExecuteOp::set_has_computation_handle() {
  _oneof_case_[0] = kComputationHandle;
}
inline void XRTChainedExecuteOp::clear_computation_handle() {
  if (has_computation_handle()) {
    op_oneof_.computation_handle_ = GOOGLE_LONGLONG(0);
    clear_has_op_oneof();
  }
}
inline ::google::protobuf::int64 XRTChainedExecuteOp::computation_handle() const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteOp.computation_handle)
  if (has_computation_handle()) {
    return op_oneof_.computation_handle_;
  }
  return GOOGLE_LONGLONG(0);
}
inline void XRTChainedExecuteOp::set_computation_handle(::google::protobuf::int64 value) {
  if (!has_computation_handle()) {
    clear_op_oneof();
    set_has_computation_handle();
  }
  op_oneof_.computation_handle_ = value;
  // @@protoc_insertion_point(field_set:xrt.XRTChainedExecuteOp.computation_handle)
}

// repeated .xrt.XRTChainedExecuteOp.Output outputs = 3;
inline int XRTChainedExecuteOp::outputs_size() const {
  return outputs_.size();
}
inline void XRTChainedExecuteOp::clear_outputs() {
  outputs_.Clear();
}
inline ::xrt::XRTChainedExecuteOp_Output* XRTChainedExecuteOp::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:xrt.XRTChainedExecuteOp.outputs)
  return outputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp_Output >*
XRTChainedExecuteOp::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:xrt.XRTChainedExecuteOp.outputs)
  return &outputs_;
}
inline const ::xrt::XRTChainedExecuteOp_Output& XRTChainedExecuteOp::outputs(int index) const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteOp.outputs)
  return outputs_.Get(index);
}
inline ::xrt::XRTChainedExecuteOp_Output* XRTChainedExecuteOp::add_outputs() {
  // @@protoc_insertion_point(field_add:xrt.XRTChainedExecuteOp.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp_Output >&
XRTChainedExecuteOp::outputs() const {
  // @@protoc_insertion_point(field_list:xrt.XRTChainedExecuteOp.outputs)
  return outputs_;
}

// repeated .xrt.XRTChainedExecuteOp.Input inputs = 4;
inline int XRTChainedExecuteOp::inputs_size() const {
  return inputs_.size();
}
inline void XRTChainedExecuteOp::clear_inputs() {
  inputs_.Clear();
}
inline ::xrt::XRTChainedExecuteOp_Input* XRTChainedExecuteOp::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:xrt.XRTChainedExecuteOp.inputs)
  return inputs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp_Input >*
XRTChainedExecuteOp::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:xrt.XRTChainedExecuteOp.inputs)
  return &inputs_;
}
inline const ::xrt::XRTChainedExecuteOp_Input& XRTChainedExecuteOp::inputs(int index) const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecuteOp.inputs)
  return inputs_.Get(index);
}
inline ::xrt::XRTChainedExecuteOp_Input* XRTChainedExecuteOp::add_inputs() {
  // @@protoc_insertion_point(field_add:xrt.XRTChainedExecuteOp.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp_Input >&
XRTChainedExecuteOp::inputs() const {
  // @@protoc_insertion_point(field_list:xrt.XRTChainedExecuteOp.inputs)
  return inputs_;
}

inline bool XRTChainedExecuteOp::has_op_oneof() const {
  return op_oneof_case() != OP_ONEOF_NOT_SET;
}
inline void XRTChainedExecuteOp::clear_has_op_oneof() {
  _oneof_case_[0] = OP_ONEOF_NOT_SET;
}
inline XRTChainedExecuteOp::OpOneofCase XRTChainedExecuteOp::op_oneof_case() const {
  return XRTChainedExecuteOp::OpOneofCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// XRTChainedExecutePlan

// repeated .xrt.XRTChainedExecuteOp ops = 1;
inline int XRTChainedExecutePlan::ops_size() const {
  return ops_.size();
}
inline void XRTChainedExecutePlan::clear_ops() {
  ops_.Clear();
}
inline ::xrt::XRTChainedExecuteOp* XRTChainedExecutePlan::mutable_ops(int index) {
  // @@protoc_insertion_point(field_mutable:xrt.XRTChainedExecutePlan.ops)
  return ops_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp >*
XRTChainedExecutePlan::mutable_ops() {
  // @@protoc_insertion_point(field_mutable_list:xrt.XRTChainedExecutePlan.ops)
  return &ops_;
}
inline const ::xrt::XRTChainedExecuteOp& XRTChainedExecutePlan::ops(int index) const {
  // @@protoc_insertion_point(field_get:xrt.XRTChainedExecutePlan.ops)
  return ops_.Get(index);
}
inline ::xrt::XRTChainedExecuteOp* XRTChainedExecutePlan::add_ops() {
  // @@protoc_insertion_point(field_add:xrt.XRTChainedExecutePlan.ops)
  return ops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xrt::XRTChainedExecuteOp >&
XRTChainedExecutePlan::ops() const {
  // @@protoc_insertion_point(field_list:xrt.XRTChainedExecutePlan.ops)
  return ops_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace xrt

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_tensorflow_2fcompiler_2fxrt_2fxrt_2eproto
